<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>王道数据结构 | 醉卿枫 の 博客</title><meta name="keywords" content="数据结构"><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="王道考研数据结构笔记第二章 线性表2.1 线性表的定义和基本操作要点：  线性表的基本操作——创销、增删、改查 传入参数时，何时要用引用 &amp;  2.2 线性表的顺序表示2.2.1 顺序表的定义 顺序表的实现———静态分配  123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define MaxSize 10">
<meta property="og:type" content="article">
<meta property="og:title" content="王道数据结构">
<meta property="og:url" content="https://wjl-a.github.io/blot.github.io/2022/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB/index.html">
<meta property="og:site_name" content="醉卿枫 の 博客">
<meta property="og:description" content="王道考研数据结构笔记第二章 线性表2.1 线性表的定义和基本操作要点：  线性表的基本操作——创销、增删、改查 传入参数时，何时要用引用 &amp;  2.2 线性表的顺序表示2.2.1 顺序表的定义 顺序表的实现———静态分配  123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define MaxSize 10">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-04-04T00:00:00.000Z">
<meta property="article:modified_time" content="2022-07-12T05:10:33.314Z">
<meta property="article:author" content="醉卿枫">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/blot.github.io/img/favicon.png"><link rel="canonical" href="https://wjl-a.github.io/blot.github.io/2022/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blot.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/blot.github.io/',
  algolia: undefined,
  localSearch: {"path":"/blot.github.io/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王道数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-12 13:10:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206041656239.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blot.github.io/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/blot.github.io/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/blot.github.io/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blot.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blot.github.io/">醉卿枫 の 博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blot.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blot.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">王道数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-04T00:00:00.000Z" title="发表于 2022-04-04 08:00:00">2022-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-12T05:10:33.314Z" title="更新于 2022-07-12 13:10:33">2022-07-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>98分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="王道数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h5 id="王道考研数据结构笔记"><a href="#王道考研数据结构笔记" class="headerlink" title="王道考研数据结构笔记"></a>王道考研<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=数据结构&amp;spm=1001.2101.3001.7020">数据结构</a>笔记</h5><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h2><p>要点：</p>
<ol>
<li>线性表的基本操作——创销、增删、改查</li>
<li>传入参数时，何时要用引用 <code>&amp;</code></li>
</ol>
<h2 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=顺序表&amp;spm=1001.2101.3001.7020">顺序表</a>示</h2><h3 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h3><ol>
<li>顺序表的实现———<strong>静态分配</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;   <span class="comment">//将所有数据元素设置为默认初始值0,如果没有这一步，内存中会有遗留的“脏数据”</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.Length=<span class="number">0</span>;        <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">                       <span class="comment">//在内存里分配存储顺序表L的空间</span></span><br><span class="line">                       <span class="comment">//包括MaxSize*sizeof(ElemType)和存储length的空间</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>
<ol>
<li>顺序表的实现——<strong>动态分配</strong></li>
</ol>
<p><code>malloc</code>函数:</p>
<p><code>L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)</code> 其中<code>(ElemType*)</code>可强制转换数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;          <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;       <span class="comment">//最大容量</span></span><br><span class="line">    <span class="type">int</span> length;       <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;              <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *L)</span>&#123;</span><br><span class="line">    <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    L-&gt;MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SqList *L,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=L-&gt;data;   <span class="comment">//地址赋值</span></span><br><span class="line"></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L-&gt;MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i]=p[i];                 <span class="comment">//将旧数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;MaxSize=L-&gt;MaxSize+len;           <span class="comment">//数组最大长度</span></span><br><span class="line">    <span class="built_in">free</span>(p);                           <span class="comment">//释放原来的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(&amp;L);<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="comment">//以下代码对比</span></span><br><span class="line">    IncreaseSize(&amp;L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-顺序表上基本操作的实现-插入和删除"><a href="#2-2-2-顺序表上基本操作的实现-插入和删除" class="headerlink" title="2.2.2 顺序表上基本操作的实现 (插入和删除)"></a>2.2.2 顺序表上基本操作的实现 (插入和删除)</h3><ol>
<li>顺序表基本操作——插入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListInsert(&amp;L,i,e)</span><br></pre></td></tr></table></figure>
<p><strong>基于静态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——在L的位序i处插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span>&#123; </span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length&gt;MaxSize) <span class="comment">//当前存储空间已满，不能插入  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--)&#123;    <span class="comment">//将第i个元素及其之后的元素后移</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>]=e;  <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;      <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    ListInsert(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>关注最深层循环语句——<code>L.data[j]=L.data[j-1]</code>的执行次数与问题规模n——<code>L.length</code>的关系;</li>
<li>最好情况：插入表尾，不需要移动元素，i=n+1，循环0次；最好时间复杂度 = O(1)</li>
<li>最坏情况：插入表头，需要将原有的n个元素全都向后移动，i=1，循环n次；最坏时间复杂度 = O(n)</li>
<li>平均情况：假设新元素插入到任何一个位置的概率p(=1/n+1)相同</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>插入到第i个位置</th>
<th>循环次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>n</td>
</tr>
<tr>
<td>2</td>
<td>n-1</td>
</tr>
<tr>
<td>3</td>
<td>n-2</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n+1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>平均循环次数</strong> = np + (n-1)p + (n-2)p + … + 1×p = [ n(n+1)/2 ]×[ 1/(n+1) ] = n/2</p>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<ol>
<li>顺序表基本操作——删除</li>
</ol>
<p><code>ListDelete(&amp;L,i,e)</code>:删除表L中的第i个位置的元素，并用e返回删除元素的值<br><strong>基于静态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">LisDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span>&#123; <span class="comment">// e用引用型参数 </span></span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    e = L.data[i<span class="number">-1</span>]    <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--)&#123;    <span class="comment">//将第i个后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;      <span class="comment">//长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">-1</span>;        <span class="comment">//用变量e把删除的元素“带回来”</span></span><br><span class="line">    <span class="keyword">if</span>(LisDelete(L,<span class="number">3</span>,e))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已删除第三个元素，删除元素值=%d\n&quot;</span>,e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位序i不合法，删除失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>关注最深层循环语句——<code>L.data[j-1]=L.data[j]</code>的执行次数与问题规模n——<code>L.length</code>的关系;</li>
<li>最好情况：删除表尾元素，不需要移动元素，i=n，循环0次；最好时间复杂度 = O(1);</li>
<li>最坏情况：删除表头元素，需要将后续的n-1个元素全都向前移动，i=1，循环n-1次；最坏时间复杂度 = O(n);</li>
<li>平均情况：假设删除任何一个元素(1,2,3,…,length)的概率相同 p=1/n</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>删除第i个元素</th>
<th>循环次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>n-1</td>
</tr>
<tr>
<td>2</td>
<td>n-2</td>
</tr>
<tr>
<td>3</td>
<td>n-3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>平均循环次数</strong> = (n-1)p + (n-2)p + … + 1×p = [ n(n-1)/2 ]×[ 1/(n) ] = n-1/2</p>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<ol>
<li>顺序表基本操作——按位查找(顺序表)</li>
</ol>
<p><code>GetElem(L,i)</code> : 按位查找操作——获取表L中第i个位置元素的值</p>
<p><strong>基于静态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                     <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="comment">// ...判断i的值是否合法</span></span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];      <span class="comment">//注意是i-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p><strong>基于动态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;     <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;      <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="comment">// ...判断i的值是否合法</span></span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>]; <span class="comment">//就算是指针也能用数组下标哦!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<p><strong>O(1)</strong><br>由于顺序表的各个数据元素在内存中连续存放，因此可以根据<strong>起始地址</strong>和<strong>数据元素大小</strong>立即找到第i个元素———“随机存取”特性；</p>
<ol>
<li>顺序表基本操作——按值查找</li>
</ol>
<p><code>LocateElem(L, e)</code>: 按值查找操作，在表L中查找具有给定关键字值的元素；</p>
<p><strong>基于动态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemTyp *data;  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L.lengthl i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)  </span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;     <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;               <span class="comment">//推出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>Q:</strong> 如果顺序表里存放的是结构类型的数据元素，可不可以用 <code>==</code> 进行比较？</p>
<p><strong>A:</strong> 不能！结构类型的比较，需要依次对比各个分量来判断两个结构体是否相等；</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> people;</span><br><span class="line">&#125;Customer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    Customer a;</span><br><span class="line">    Customer b;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people == b.people)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不相等&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>最深处循环语句: <code>if(L.data[i] == e)</code> 与问题规模n=<code>L.length(表长)</code>的关系；</li>
<li>最好情况：查找目标元素在表头，循环1次，最好时间复杂度=O(1)</li>
<li>最坏情况：查找目标元素在表尾，循环n次，最好时间复杂度=O(n)</li>
<li>平均情况：假设目标元素出现在任何一个位置的概率相同，p=1/n</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>目标元素所在位置i</th>
<th>循环次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n</td>
<td>n</td>
</tr>
</tbody>
</table>
</div>
<p><strong>平均循环次数</strong> = 1×1/n + 2×1/n +…+ n×1/n = [ n(n+1)/2 ] × 1/n = (n+1)/2</p>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<p><img src="https://img-blog.csdnimg.cn/20210422220005304.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxNjQzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h2><h3 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h3><ol>
<li>何为单链表？</li>
</ol>
<ul>
<li>链式存储</li>
<li>每个结点存储：数据元素自身信息 &amp; 指向下一个结点(后继)的指针</li>
<li>优点：不要求大片连续空间，改变容量方便</li>
<li>缺点：不可随机存取，要耗费一定空间存放指针</li>
</ul>
<ol>
<li>代码定义单链表</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            <span class="comment">//定义单链表节点类型  LNode:结点</span></span><br><span class="line">    ElemType data;       <span class="comment">//每个结点存放一个数据元素 data:数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针指向下一个结点 next:指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>增加一个新的结点：在内存中申请一个结点所需的空间，并用指针p指向这个结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><em>如果每次都要写struct很麻烦，所以可以利用typedef关键字——数据类型重命名：<code>type&lt;数据类型&gt;&lt;别名&gt;</code></em></p>
<p>Eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> zhengshu;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *zhengshuzhizhen;  <span class="comment">//指向int型的指针</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>上面操作可以化简为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span></span><br><span class="line"></span><br><span class="line">LNode* p = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p><strong>最简洁代码实现:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>以上代码等同于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>           </span><br><span class="line">    ElemType data;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span> <span class="comment">//重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span> </span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>要表示一个单链表时，只需声明一个<strong>头指针L</strong>，指向单链表的第一个结点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LNode *L;    <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是结点</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">LinkList L;  <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是链表</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>两种实现方法</li>
</ol>
<ul>
<li>不带头结点的单链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;  <span class="comment">//注意用引用 &amp;</span></span><br><span class="line">    L = <span class="literal">NULL</span>; <span class="comment">//空表，暂时还没有任何结点；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>
<ul>
<li>带头结点的单链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//头指针指向的结点——分配一个头结点（不存储数据）</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)          <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;       <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>
<p><strong>不带头结点 V.S. 带头结点</strong></p>
<ul>
<li>不带头结点：写代码麻烦！对第一个数据节点和后续数据节点的处理需要用不同的代码逻辑，对空表和非空表的处理也需要用不同的代码逻辑; <strong>头指针指向的结点用于存放实际数据;</strong></li>
<li>带头结点：<strong>头指针指向的头结点不存放实际数据,头结点指向的下一个结点才存放实际数据;</strong></li>
</ul>
<h3 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h3><p><strong>1. 单链表的插入</strong></p>
<ul>
<li><strong>按位序插入 (带头结点)</strong></li>
</ul>
<p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后；其中头结点可以看作第0个结点，故i=1时也适用。</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="comment">//判断i的合法性, i是位序号(从1开始)</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    </span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                 <span class="comment">//将结点s连到p后,后两步千万不能颠倒qwq</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析</p>
<blockquote>
<p>最好情况：插入第1个位置 O(1)</p>
<p>最坏情况：插入表尾 O(n)</p>
<p>平均时间复杂度 = O(n)</p>
</blockquote>
<ul>
<li><strong>按位序插入 (不带头结点)</strong></li>
</ul>
<p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后; 因为不带头结点，所以不存在“第0个”结点，因此！<strong>i=1 时，需要特殊处理——插入(删除)第1个元素时，需要更改头指针L;</strong></p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入到第1个位置时的操作有所不同！</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(size of(LNode));</span><br><span class="line">        s-&gt;data =e;</span><br><span class="line">        s-&gt;next =L;</span><br><span class="line">        L=s;          <span class="comment">//头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i&gt;1的情况与带头结点一样！唯一区别是j的初始值为1</span></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>
<p><em>除非特别声明，否则之后的代码都默认为带头结点哦，做题注意审题</em></p>
<ul>
<li><strong>指定结点的后插操作</strong></li>
</ul>
<p><code>InsertNextNode(LNode *p, ElemType e)</code>: 给定一个结点p，在其之后插入元素e; 根据单链表的链接指针只能往后查找，故给定一个结点p，那么p之后的结点我们都可知，但是p结点之前的结点无法得知;</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">//某些情况下分配失败，比如内存不足</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;          <span class="comment">//用结点s保存数据元素e </span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          <span class="comment">//将结点s连到p之后</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;                         <span class="comment">//平均时间复杂度 = O(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有了后插操作，那么在第i个位置上插入指定元素e的代码可以改成：</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    </span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> InsertNextNode(p, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>指定结点的前插操作</strong></li>
</ul>
<p><strong>Q:</strong> 如何找到p结点的前驱节点？</p>
<p><strong>A:</strong> 传入头指针L！就可以知道整个链表的信息了！</p>
<p><code>InsertPriorNode(LinkList L, LNode *p, ElemType e)</code>：循环查找p的前驱q，再对q进行后插操作，时间复杂度为O(n);</p>
<p><strong>Q:</strong> 那如果不传入头指针L呢？</p>
<p>不传入头指针L的代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, ElenType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>) <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点来了！</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;       <span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data; <span class="comment">//将p中元素复制到s</span></span><br><span class="line">    p-&gt;data = e;       <span class="comment">//p中元素覆盖为e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>；</span><br><span class="line">&#125;  <span class="comment">//时间复杂度为O(1)</span></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>
<p>王道书版本代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, LNode *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;  <span class="comment">///s连接到p</span></span><br><span class="line">    ELemType temp = p-&gt;data;  <span class="comment">//交换数据域部分</span></span><br><span class="line">    p-&gt;data = s-&gt;data;</span><br><span class="line">    s-&gt;data = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 单链表的删除</strong></p>
<ul>
<li><strong>按位序删除(带头结点)</strong></li>
</ul>
<p><code>ListDelete(&amp;L, i, &amp;e)</code>: 删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值;头结点视为“第0个”结点；</p>
<p><em>思路：找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点；</em></p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElenType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;         <span class="comment">//令q指向被删除的结点</span></span><br><span class="line">    e = q-&gt;data;                <span class="comment">//用e返回被删除元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;          <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q)                     <span class="comment">//释放结点的存储空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：</p>
<blockquote>
<p>最坏，平均时间复杂度：O(n)</p>
<p>最好时间复杂度：删除第一个结点 O(1)</p>
</blockquote>
<ul>
<li><strong>指定结点的删除</strong></li>
</ul>
<p>删除结点p，需要修改其前驱结点的next指针(两个方法)；</p>
<p>“偷天换日”代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *q = p-&gt;next;      <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data; <span class="comment">//让p和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;       <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//时间复杂度 = O(1)</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p><strong>但是</strong> 如果p是最后一个结点，那么<code>p-&gt;next = q-&gt;next</code> and <code>p-&gt;data = p-&gt;next-&gt;data</code> 就会出错，只能从表头开始依次寻找o的前驱，时间复杂度为O(n); 这就是单链表的<strong>局限性</strong>——无法逆向检索。</p>
<p><strong>3. 单链表的查找</strong></p>
<p><em>探讨带头结点！</em></p>
<ul>
<li><strong>按位查找</strong></li>
</ul>
<p><code>GetElem(L, i):</code> 按位查找操作，获取表L中第i个位置的元素的值;</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *p;               <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;                <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                  <span class="comment">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;  <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;               <span class="comment">//返回p指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<p>王道书版本代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;                <span class="comment">//从第一个结点开始</span></span><br><span class="line">    LNode *p = L-&gt;next      <span class="comment">//p先指向第一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;  <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;               <span class="comment">//返回p指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>那么上一节的按位插入和按位删除就可以封装了！<br><img src="https://img-blog.csdnimg.cn/20210422215801163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxNjQzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>按值查找</strong></li>
</ul>
<p><code>LocateElem(L, e):</code>按值查找操作，在表L中查找具有给定关键字值的元素;</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span>&#123;</span><br><span class="line">    LNode *P = L-&gt;next;    <span class="comment">//p指向第一个结点</span></span><br><span class="line">    <span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;           <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p><strong>注意当ElemType是结构体时的操作</strong></p>
<p><strong>4. 求单链表的长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length(LinkList L)</span><br></pre></td></tr></table></figure>
<p>代码实现 (带头结点)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;       <span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>平均时间复杂度=</strong> O(n)</p>
<p><strong>5. 单链表的建立</strong></p>
<p><strong>思路：</strong> 初始化一个单链表 -&gt; 每取一个数据元素，插入到表尾/表头</p>
<p><strong>核心：</strong> 初始化操作 and 指定结点的后插操作</p>
<p><em>探讨带头结点！</em></p>
<ul>
<li>尾插法建立单链表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">初始化单链表</span><br><span class="line"></span><br><span class="line">设置变量length记录链表当前的长度</span><br><span class="line"></span><br><span class="line">while循环&#123;</span><br><span class="line">    每次取一个数据元素e;</span><br><span class="line">    ListInsert(L, length+1, e)插到尾部;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>
<p><strong>但是</strong>,因为每次都要执行↓,就是每次都要从头开始遍历，时间复杂度为O(n²)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(p!=NULL &amp;&amp; j&lt;i-1)&#123;     </span><br><span class="line">    p = p-&gt;next;             </span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>：设置一个表尾指针r，对r这个结点进行后插操作<code>InsertNextNode()</code></p>
<p>最终代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="type">int</span> x;                                   <span class="comment">//设ElemType为整型int</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点(初始化空表)</span></span><br><span class="line">    LNode *s, *r = L;                        <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s                                <span class="comment">//r指针指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p><strong>平均时间复杂度</strong>：O(n)</p>
<ul>
<li>头插法建立单链表</li>
</ul>
<p>对头结点进行后插操作<code>InsertNextNode()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化单链表</span><br><span class="line"></span><br><span class="line">while循环&#123;</span><br><span class="line">    每次取一个数据元素e;</span><br><span class="line">    InsertNextNode(L, e);</span><br><span class="line">&#125;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>最终代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//初始为空链表,这步不能少！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;                         <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>
<p><strong>PS: 只要是初始化单链表，都先将头指针指向NULL — <code>L-&gt;next = NULL</code>;</strong></p>
<h2 id="重要应用：链表的逆置"><a href="#重要应用：链表的逆置" class="headerlink" title="重要应用：链表的逆置"></a><strong>重要应用</strong>：链表的逆置</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42322103/article/details/82668765">详细见CSDN:单链表逆置—头插法图解</a></p>
<ul>
<li>算法思想：逆置链表初始为空，原表中结点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">Inverse</span><span class="params">(LNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *p, *q;</span><br><span class="line">	p = L-&gt;next;     <span class="comment">//p指针指向第一个结点</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指向NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q-&gt;next = L-&gt;next;  </span><br><span class="line">		L-&gt;next = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h3><p>双链表中节点类型的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<ol>
<li>双链表的初始化 (带头结点)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(Dlinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));      <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                              <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;   <span class="comment">//头结点的prior指针永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    DLinklist L;         <span class="comment">// 定义指向头结点的指针L</span></span><br><span class="line">    InitDLinkList(L);    <span class="comment">//申请一片空间用于存放头结点，指针L指向这个头结点</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的next指针是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>
<p>与单链表中一样，<code>DLinklist</code> 强调链表， <code>DNode *</code>强调结点，二者本质上等价;</p>
<ol>
<li>双链表的插入操作</li>
</ol>
<ul>
<li>后插操作</li>
</ul>
<p><code>InsertNextDNode(p, s)</code>: 在p结点后插入s结点</p>
<p>代码实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; <span class="comment">//将结点 *s 插入到结点 *p之后</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>) <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)   <span class="comment">//p不是最后一个结点=p有后继结点  </span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<ul>
<li>按位序插入操作</li>
</ul>
<p>思路：从头结点开始，找到某个位序的前驱结点，对该前驱结点执行后插操作；</p>
<ul>
<li>前插操作</li>
</ul>
<p>思路：找到给定结点的前驱结点，再对该前驱结点执行后插操作；</p>
<ol>
<li>双链表的删除操作</li>
</ol>
<p>删除p的后继结点q</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>如果要删除的结点q是最后一个结点，会出现错误，故增加条件判断以提高代码健壮性</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeletNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q =p-&gt;next;            <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//p没有后继结点;</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)           <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        DeletNextDNode(L);  <span class="comment">//删除头结点的后继结点</span></span><br><span class="line">    <span class="built_in">free</span>(L); <span class="comment">//释放头结点</span></span><br><span class="line">    L=<span class="literal">NULL</span>;  <span class="comment">//头指针指向NULL</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>
<ol>
<li>双链表的遍历操作<br><strong>后向遍历</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><strong>前向遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>如果我们不想处理头结点，那就跳过头结点！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 双链表不可随机存取，按位查找和按值查找操作都只能用遍历的方式实现，时间复杂度为<strong>O(n)</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210422215943132.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxNjQzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-3-4-循环链表"><a href="#2-3-4-循环链表" class="headerlink" title="2.3.4 循环链表"></a>2.3.4 循环链表</h3><p><strong>1. 循环单链表</strong></p>
<p><strong>最后一个结点的指针不是NULL,而是指向头结点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *Linklist;</span><br><span class="line"></span><br><span class="line">/初始化一个循环单链表</span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)             <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;            <span class="comment">//头结点next指针指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L, LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>
<h2 id="单链表-amp-循环单链表"><a href="#单链表-amp-循环单链表" class="headerlink" title="单链表 &amp; 循环单链表"></a>单链表 &amp; 循环单链表</h2><ul>
<li><strong>单链表</strong>：从一个结点出发只能找到该结点后续的各个结点；对链表的操作大多都在头部或者尾部；设立头指针，从头结点找到尾部的时间复杂度=O(n)，即对表尾进行操作需要O(n)的时间复杂度;</li>
<li><strong>循环单链表</strong>：从一个结点出发，可以找到其他任何一个结点；设立尾指针，从尾部找到头部的时间复杂度为O(1)，即对表头和表尾进行操作都只需要O(1)的时间复杂度;</li>
</ul>
<blockquote>
<p>可以让L指向表尾元素(插入，删除时可能需要修改L)</p>
</blockquote>
<p><strong>2. 循环双链表</strong></p>
<p><strong>表头结点的<code>prior</code>指向表尾结点，表尾结点的<code>next</code>指向头结点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>          </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));    <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    L-&gt;prior = L;          <span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;           <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化循环单链表</span></span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环双链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(DLinklist L, DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536</span></span><br></pre></td></tr></table></figure>
<h2 id="双链表-amp-循环双链表"><a href="#双链表-amp-循环双链表" class="headerlink" title="双链表 &amp; 循环双链表"></a>双链表 &amp; 循环双链表</h2><ul>
<li><strong>插入操作</strong></li>
</ul>
<p>对于循环双链表，操作 <code>p-&gt;next-&gt;prior = s</code> 不会出问题辣！因为就算p是最后一个结点，也不会出现空指针现象了(这个问题在双链表里会出现！)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>删除操作</strong></li>
</ul>
<p>和插入操作一样！<code>q-&gt;next-&gt;prior</code> 对于循环双链表不会出错了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p的后继结点q</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-静态链表"><a href="#2-3-5-静态链表" class="headerlink" title="2.3.5 静态链表"></a>2.3.5 静态链表</h3><ol>
<li>何为静态链表</li>
</ol>
<ul>
<li>单链表: 各个结点散落在内存中的各个角落，每个结点有指向下一个节点的指针(下一个结点在内存中的地址);</li>
<li>静态链表——用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=数组&amp;spm=1001.2101.3001.7020">数组</a>的方式实现的链表: 分配一整片连续的内存空间，各个结点集中安置，包括了——数据元素and下一个结点的数组下标(游标)<ul>
<li>其中数组下标为0的结点充当”头结点”</li>
<li>游标为-1表示已经到达表尾</li>
<li>若每个数据元素为4B，每个游标为4B，则每个结点共8B；假设起始地址为<code>addr</code>，则数据下标为2的存放地址为：<code>addr</code>+8*2</li>
<li><strong>注意</strong>： 数组下标——物理顺序，位序——逻辑顺序；</li>
<li>优点：增、删操作不需要大量移动元素；</li>
<li>缺点：不能随机存取，只能从头结点开始依次往后查找，<strong>容量固定不变！</strong></li>
</ul>
</li>
</ul>
<ol>
<li>代码定义一个静态链表</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组定义多个连续存放的结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//数组a作为静态链表, 每一个数组元素的类型都是struct Node</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ELemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>上面这个代码等同于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span> <span class="comment">//重命名struct Node，用SLinkList定义“一个长度为MaxSize的Node型数组;</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>PS: <code>SLinkList a</code> 强调a是静态链表；<code>struct Node a</code> 强调a是一个Node型数组；</p>
<ol>
<li>静态链表基本操作的实现</li>
</ol>
<ul>
<li>初始化静态链表：把<code>a[0]</code>的<code>next</code>设为-1</li>
<li>查找某个位序（不是数组下标，位序是各个结点在逻辑上的顺序）的结点：从头结点出发挨个往后遍历结点，时间复杂度O=(n)</li>
<li>在位序为i上插入结点：① 找到一个空的结点，存入数据元素；② 从头结点出发找到位序为i-1的结点；③修改新结点的next；④ 修改i-1号结点的next；</li>
</ul>
<blockquote>
<p>Q：如何判断结点为空？</p>
<p>A：在初始化时，将空闲结点的next设置为某个特殊值，eg：-2；</p>
</blockquote>
<ul>
<li>删除某个结点：① 从头结点出发找到前驱结点；② 修改前驱节点的游标；③ 被删除节点next设为-2；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ELemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-顺序表和链表的比较"><a href="#2-3-6-顺序表和链表的比较" class="headerlink" title="2.3.6 顺序表和链表的比较"></a>2.3.6 顺序表和链表的比较</h3><p><strong>1. 逻辑结构</strong></p>
<ul>
<li>顺序表和链表都属于线性表，都是线性结构</li>
</ul>
<p><strong>2. 存储结构</strong></p>
<ul>
<li>顺序表：顺序存储<ul>
<li>优点：支持随机存取，存储密度高</li>
<li>缺点：大片连续空间分配不方便，改变容量不方便</li>
</ul>
</li>
<li>链表：链式存储<ul>
<li>优点：离散的小空间分配方便，改变容量方便</li>
<li>缺点：不可随机存取，存储密度低</li>
</ul>
</li>
</ul>
<p><strong>3. 基本操作 - 创</strong></p>
<ul>
<li>顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源；<ul>
<li>静态分配：静态数组，容量不可改变</li>
<li>动态分配：动态数组，容量可以改变，但是需要移动大量元素，时间代价高（<code>malloc()</code>,<code>free()</code>）</li>
</ul>
</li>
<li>链表：只需要分配一个头结点或者只声明一个头指针</li>
</ul>
<p><strong>4. 基本操作 - 销毁</strong></p>
<ul>
<li><p>顺序表：修改 <code>Length</code> = 0</p>
<ul>
<li><p>静态分配：静态数组——系统自动回收空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态分配：动态数组——需要手动free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创</span></span><br><span class="line">L.data = (ELemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) *InitSize)</span><br><span class="line"><span class="comment">//销</span></span><br><span class="line"><span class="built_in">free</span>(L.data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//！malloc() 和 free() 必须成对出现</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>链表：依次删除各个结点 <code>free()</code></p>
</li>
</ul>
<p><strong>5. 基本操作 - 增/删</strong></p>
<ul>
<li>顺序表：插入/删除元素要将后续元素后移/前移；时间复杂度=O(n)，时间开销主要来自于移动元素；</li>
<li>链表：插入/删除元素只需要修改指针；时间复杂度=O(n)，时间开销主要来自查找目标元素</li>
</ul>
<p><strong>6. 基本操作 - 查</strong></p>
<ul>
<li>顺序表<ul>
<li>按位查找：O(1)</li>
<li>按值查找：O(n)，若表内元素有序，可在O(log2n)时间内找到</li>
</ul>
</li>
<li>链表：<ul>
<li>按位查找：O(n)</li>
<li>按值查找：O(n)</li>
</ul>
</li>
</ul>
<p><strong>7. 开放式问题答题思路</strong></p>
<p><strong>Q:</strong> 请描述顺序表和链表的balabalabala…实现线性表时，用顺序表还是链表好？</p>
<p><strong>A:</strong> 顺序表和链表的<strong>存储结构</strong>都是线性结构，都属于线性表；但是二者的<strong>存储结构</strong>不同，顺序表采用顺序存储…(特点，优缺点)；链表采用链式存储…(特点，优缺点)；由于采用不同的存储方式实现，因此<strong>基本操作</strong>的实现效率也不同；当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…；</p>
<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1-栈-stack"><a href="#3-1-栈-stack" class="headerlink" title="3.1 栈 (stack)"></a>3.1 栈 (stack)</h2><h3 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h3><ol>
<li>栈的定义</li>
</ol>
<ul>
<li>栈是特殊的线性表：<strong>只允许在一端进行插入或删除操作，</strong> 其逻辑结构与普通线性表相同；</li>
<li>栈顶：允许进行插入和删除的一端 （最上面的为<strong>栈顶元素</strong>）；</li>
<li>栈底：不允许进行插入和删除的一端 （最下面的为<strong>栈底元素</strong>）；</li>
<li>空栈：不含任何元素的空表；</li>
<li>特点：后进先出（后进栈的元素先出栈）；</li>
<li>缺点：栈的大小不可变，解决方法——共享栈；</li>
</ul>
<ol>
<li>栈的基本操作 （运算）</li>
</ol>
<h3 id="“创-amp-销”"><a href="#“创-amp-销”" class="headerlink" title="“创&amp;销”"></a><strong>“创&amp;销”</strong></h3><ul>
<li><code>InitStack(&amp;S)</code> <strong>初始化栈</strong>：构造一个空栈S，分配内存空间；</li>
<li><code>DestroyStack(&amp;S)</code> <strong>销毁栈</strong>：销毁并释放栈S所占用的内存空间；</li>
</ul>
<h3 id="“增-amp-删”"><a href="#“增-amp-删”" class="headerlink" title="“增&amp;删”"></a><strong>“增&amp;删”</strong></h3><ul>
<li><code>Push(&amp;S, x)</code> <strong>进栈</strong>：若栈S未满，则将x加入使其成为新栈顶；</li>
<li><code>Pop(&amp;S, &amp;x)</code> <strong>出栈</strong>：若栈S非空，则弹出（删除）栈顶元素，并用x返回；</li>
</ul>
<h3 id="“查-amp-其他”"><a href="#“查-amp-其他”" class="headerlink" title="“查&amp;其他”"></a><strong>“查&amp;其他”</strong></h3><ul>
<li><code>GetTop(S, &amp;x)</code> <strong>读取栈顶元素</strong>：若栈S非空，则用x返回栈顶元素；（栈的使用场景大多只访问栈顶元素）；</li>
<li><code>StackEmpty(S)</code> <strong>判空</strong>： 断一个栈S是否为空，若S为空，则返回<code>true</code>,否则返回<code>false</code>；</li>
</ul>
<ol>
<li>栈的常见题型</li>
</ol>
<ul>
<li>给个进栈顺序，判断有哪些合法的出栈顺序；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：进栈顺序为：a -&gt; b -&gt; c -&gt; d -&gt; e</span><br><span class="line">    </span><br><span class="line">    合法的出栈顺序：e d c b a / b e d c a (出栈和进栈交替进行) / ... </span><br><span class="line">    </span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-栈的顺序存储"><a href="#3-1-2-栈的顺序存储" class="headerlink" title="3.1.2 栈的顺序存储"></a>3.1.2 栈的顺序存储</h3><ol>
<li>顺序栈的定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶元素</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">                     <span class="comment">//连续的存储空间大小为 MaxSize*sizeof(ElemType)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<ol>
<li>顺序栈的基本操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶元素</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)      <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>                 <span class="comment">//栈不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>)        <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    S.top = S.top + <span class="number">1</span>;    <span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;    <span class="comment">//新元素入栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    S.data[++S.top] = x;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;x, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];       <span class="comment">//先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;       <span class="comment">//栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x = S.data[S.top--];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是逻辑上的删除，数据依然残留在内存里</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];      <span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566</span></span><br></pre></td></tr></table></figure>
<p><strong>PS:</strong> 也可以初始化时定义 <code>S.top = 0</code> ：top指针指向下一个可以插入元素的位置(栈顶元素的后一个位置)；</p>
<ul>
<li>判空：<code>if(S.top == 0)</code></li>
<li>进栈使用：<code>S.data[S.top++] = x;</code></li>
<li>出栈使用：<code>x = S.data[--S.top];</code></li>
<li>判断栈满：<code>s.top == MaxSize</code></li>
</ul>
<ol>
<li>共享栈</li>
</ol>
<p>两个栈共享同一片空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;        <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1 = MaxSize;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>栈满条件：<code>top0 + 1 == top1</code></p>
<h3 id="3-1-3-栈的链式存储结构"><a href="#3-1-3-栈的链式存储结构" class="headerlink" title="3.1.3 栈的链式存储结构"></a>3.1.3 栈的链式存储结构</h3><ol>
<li>用链式存储方式实现的栈</li>
</ol>
<ul>
<li>进栈和出栈都只能在栈顶一端进行(链头作为栈顶)</li>
<li>链表的头部作为栈顶，意味着：<ul>
<li>在实现数据”入栈”操作时，需要将数据从链表的头部插入；</li>
<li>在实现数据”出栈”操作时，需要删除链表头部的首元节点；</li>
</ul>
</li>
</ul>
<p><strong>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表;</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125;*LiStack;                      <span class="comment">//栈类型的定义</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<ol>
<li>链栈的基本操作 (类比单链表的操作 / <strong>带头结点&amp;不带头结点</strong>)</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Xulidanga/article/details/108895669">参考：链栈基本操作(带头结点及不带头结点)</a></p>
<ul>
<li>初始化</li>
<li>进栈</li>
<li>出栈</li>
<li>获取栈顶元素</li>
<li>判空、判满</li>
</ul>
<p><strong>带有头结点的链栈基本操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    Linknode *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;L)</span>&#123;   <span class="comment">//L为头指针</span></span><br><span class="line">    L = new Linknode; </span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 进栈(：链栈基本上不会出现栈满的情况)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = new Linknode;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    Linknode s;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="comment">//栈空不能出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s = L-&gt;next;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L-&gt;next = L-&gt;next-&gt;next;</span><br><span class="line">    delete(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span></span><br></pre></td></tr></table></figure>
<p><strong>不带头结点的链栈基本操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    Linknode *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        teturn <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = new Linknode;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = L;</span><br><span class="line">    L = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    Linknode s; </span><br><span class="line">    <span class="keyword">if</span>(L = <span class="literal">NULL</span>)     <span class="comment">//栈空不出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s = L;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    delete(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-队列-Queue"><a href="#3-2-队列-Queue" class="headerlink" title="3.2 队列(Queue)"></a>3.2 队列(Queue)</h2><h3 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h3><ol>
<li>队列的定义</li>
</ol>
<ul>
<li>队列是操作受限的<strong>线性表</strong>，只允许在一端进行插入 (入队)，另一端进行删除 (出队)</li>
<li>操作特性：<strong>先进先出 FIFO</strong></li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>空队列：不含任何元素的空表</li>
</ul>
<ol>
<li>队列的基本操作</li>
</ol>
<h3 id="“创-amp-销”-1"><a href="#“创-amp-销”-1" class="headerlink" title="“创&amp;销”"></a><strong>“创&amp;销”</strong></h3><ul>
<li><code>InitQueue(&amp;Q)</code>: 初始化队列，构造一个空列表Q</li>
<li><code>DestroyQueue(&amp;Q)</code>: 销毁队列，并释放队列Q所占用的内存空间</li>
</ul>
<h3 id="“增-amp-删”-1"><a href="#“增-amp-删”-1" class="headerlink" title="“增&amp;删”"></a><strong>“增&amp;删”</strong></h3><ul>
<li><code>EnQueue(&amp;Q, x)</code>: 入队，若队列Q未满，将x加入，使之成为新的队尾</li>
<li><code>DeQueue(&amp;Q, &amp;x)</code>: 出队，若队列Q非空，删除队头元素，并用x返回</li>
</ul>
<h3 id="“查-amp-其他”-1"><a href="#“查-amp-其他”-1" class="headerlink" title="“查&amp;其他”"></a><strong>“查&amp;其他”</strong></h3><ul>
<li><code>GetHead(Q,&amp;x)</code>: 读队头元素，若队列Q非空，则将队头元素赋值给x</li>
<li><code>QueueEmpty(Q)</code>: 判队列空，若队列Q为空，则返回true</li>
</ul>
<h3 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h3><ul>
<li>队头指针：指向队头元素；</li>
<li>队尾指针：指向队尾元素的后一个位置（下一个应该插入的位置）</li>
</ul>
<ol>
<li>队列的顺序存储结构的基本操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列的顺序存储类型</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">                              <span class="comment">//连续的存储空间，大小为——MaxSize*sizeof(ElemType)</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> test&#123;</span><br><span class="line">    SqQueue Q;                <span class="comment">//声明一个队列</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue <span class="number">0</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)    <span class="comment">//判空条件后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>
<ol>
<li>循环队列</li>
</ol>
<p><strong>Q:</strong> 能否用 <code>Q.rear == MaxSize</code> 作为队列满的条件？</p>
<p><strong>A:</strong> 不能！会有假溢出, 所以需要用 <strong>模运算</strong> 将存储空间 {0,1,2,…,MaxSize} 在逻辑上变成“环状”——<strong>循环队列！</strong></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7CPbzxxS-1620744230788)(循环队列.PNG)]</p>
<blockquote>
<p>a%b == a除以b的余数</p>
<p>初始：Q.front = Q.rear = 0;</p>
<p>队首指针进1：Q.front = (Q.front + 1) % MaxSize</p>
<p>队尾指针进1：Q.rear = (Q.rear + 1) % MaxSize —— 队尾指针后移，当移到最后一个后，下次移动会到第一个位置</p>
<p>队列长度：(Q.rear + MaxSize - Q.front) % MaxSize</p>
</blockquote>
<h3 id="循环队列如何判满"><a href="#循环队列如何判满" class="headerlink" title="循环队列如何判满"></a><strong>循环队列如何判满</strong></h3><p><strong>Q:</strong> 能否用<code>Q.rear == Q.front</code> 作为队列满的条件？</p>
<p><strong>A:</strong> 不能！这已经作为队列空的判断条件了；</p>
<h3 id="方案一-牺牲一个单元来区分队空和队满"><a href="#方案一-牺牲一个单元来区分队空和队满" class="headerlink" title="方案一: 牺牲一个单元来区分队空和队满"></a><strong>方案一</strong>: 牺牲一个单元来区分队空和队满</h3><p>队尾指针的再下一个位置就是队头，即 <code>(Q.rear+1)%MaxSize == Q.front</code></p>
<ul>
<li>循环队列——入队：只能从队尾插入（判满使用方案一）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front)        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;                      <span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;         <span class="comment">//队尾指针加1取模</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<ul>
<li>循环队列——出队：只能让队头元素出队</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队，删除一个队头元素，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针后移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ul>
<li>循环队列——获得队头元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="方案二-不牺牲存储空间，设置size"><a href="#方案二-不牺牲存储空间，设置size" class="headerlink" title="方案二: 不牺牲存储空间，设置size"></a><strong>方案二</strong>: 不牺牲存储空间，设置size</h3><p>定义一个变量 <code>size</code>用于记录队列此时记录了几个数据元素，初始化 <code>size = 0</code>，进队成功 <code>size++</code>，出队成功<code>size--</code>，根据size的值判断队满与队空</p>
<p>队满条件：<code>size == MaxSize</code></p>
<p>队空条件：<code>size == 0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">//队列当前长度</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<h3 id="方案三-不牺牲存储空间，设置tag"><a href="#方案三-不牺牲存储空间，设置tag" class="headerlink" title="方案三: 不牺牲存储空间，设置tag"></a><strong>方案三</strong>: 不牺牲存储空间，设置tag</h3><p>定义一个变量 <code>tag</code>，<code>tag = 0</code> —最近进行的是删除操作；<code>tag = 1</code> —最近进行的是插入操作；</p>
<ul>
<li>每次删除操作成功时，都令<code>tag = 0</code>；只有删除操作，才可能导致队空；</li>
<li>每次插入操作成功时，都令<code>tag = 1</code>；只有插入操作，才可能导致队满；</li>
</ul>
<p>队满条件：<code>Q.front == Q.rear &amp;&amp; tag == 1</code></p>
<p>队空条件：<code>Q.front == Q.rear &amp;&amp; tag == 0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> tag;               <span class="comment">//最近进行的是删除or插入</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="其他出题方法——队尾指针指向队尾元素"><a href="#其他出题方法——队尾指针指向队尾元素" class="headerlink" title="其他出题方法——队尾指针指向队尾元素"></a>其他出题方法——队尾指针指向队尾元素</h3><ul>
<li>判空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Q.rear + <span class="number">1</span>) % MaxSize == Q.front</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判满<ul>
<li>方案一：牺牲一个存储单元</li>
<li>方案二：增加辅助变量</li>
</ul>
</li>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize; <span class="comment">//后移一位</span></span><br><span class="line">Q.data[Q.rear] = x; </span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bJHGyMSI-1620744230792)(队列顺序实现.PNG)]</p>
<h3 id="3-2-3-队列的链式存储结构"><a href="#3-2-3-队列的链式存储结构" class="headerlink" title="3.2.3 队列的链式存储结构"></a>3.2.3 队列的链式存储结构</h3><ol>
<li>队列的链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>      <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>               <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ol>
<li>链式队列的基本操作——<strong>带头结点</strong></li>
</ol>
<ul>
<li>初始化 &amp; 判空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)     <span class="comment">//也可用 Q.front -&gt; next == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//s作为最后一个结点，指针域指向NULL</span></span><br><span class="line">    Q.rear-&gt;next = s;   <span class="comment">//新结点插入到当前的rear之后</span></span><br><span class="line">    Q.rear = s;         <span class="comment">//表尾指针指向新的表尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>出队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                    <span class="comment">//空队</span></span><br><span class="line">    </span><br><span class="line">    LinkNode *p = Q.front-&gt;next;         <span class="comment">//p指针指向即将删除的结点 (头结点所指向的结点)</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;             <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)                      <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear = Q.front;                <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                             <span class="comment">//释放结点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<ul>
<li>队列满的条件</li>
</ul>
<p>顺序存储：预分配存储空间</p>
<p>链式存储：一般不会队满，除非内存不足</p>
<ul>
<li>计算链队长度 (遍历链队)</li>
</ul>
<p>设置一个<code>int length</code> 记录链式队列长度</p>
<ol>
<li>链式队列的基本操作——<strong>不带头结点</strong></li>
</ol>
<ul>
<li>初始化 &amp; 判空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)     <span class="comment">//也可以用 Q.rear == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素入队时需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front = <span class="literal">NULL</span>)&#123;            <span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;               <span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;           <span class="comment">//新结点插入到rear结点之后</span></span><br><span class="line">        Q.rear = s;                 <span class="comment">//修改rear指针指向新的表尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h3><ol>
<li>定义</li>
</ol>
<ul>
<li>双端队列允许从<strong>两端插入</strong>、<strong>两端删除</strong>的线性表；</li>
<li>如果只使用其中一端的插入、删除操作，则等同于栈；</li>
<li>输入受限的双端队列：允许<strong>一端插入</strong>，<strong>两端删除</strong>的线性表；</li>
<li>输出受限的双端队列：允许<strong>两端插入</strong>，<strong>一端删除</strong>的线性表；</li>
</ul>
<ol>
<li><strong>考点：</strong> 判断输出序列的合法化（视频07）</li>
</ol>
<p><strong>例</strong>: 数据元素输入序列为 <code>1,2,3,4</code>，判断 4!=24 个输出序列的合法性</p>
<p><em>PS: 栈中合法的序列，双端队列中一定也合法</em></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈</th>
<th>输入受限的双端队列</th>
<th>输出受限的双端队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>14个合法(卡特兰数)</td>
<td>验证在栈中不合法的序列</td>
<td>验证在栈中不合法的序列</td>
</tr>
<tr>
<td></td>
<td>只有 4213 和 4231 不合法</td>
<td>只有 4132 和 4231 不合法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-3-栈的应用"><a href="#3-3-栈的应用" class="headerlink" title="3.3 栈的应用"></a>3.3 栈的应用</h2><h3 id="3-3-1-栈在括号匹配中的应用"><a href="#3-3-1-栈在括号匹配中的应用" class="headerlink" title="3.3.1 栈在括号匹配中的应用"></a>3.3.1 栈在括号匹配中的应用</h3><p>用栈实现括号匹配</p>
<ul>
<li><code>((()))</code> 最后出现的左括号最先被匹配 (栈的特性—LIFO);</li>
<li>遇到左括号就入栈;</li>
<li>遇到右括号，就“消耗”一个左括号 (出栈);</li>
</ul>
<p>匹配失败情况：</p>
<ul>
<li>扫描到右括号且栈空，则该右括号单身;</li>
<li>扫描完所有括号后，栈非空，则该左括号单身;</li>
<li>左右括号不匹配;</li>
</ul>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UBr5m1ue-1622726764306)(括号匹配.png)]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">InitStack(SqStack &amp;S)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, <span class="type">char</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶元素出栈，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, <span class="type">char</span> &amp;x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack S;      <span class="comment">//声明</span></span><br><span class="line">    InitStack(S);   <span class="comment">//初始化栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            Push(S, str[i]);       <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))      <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//匹配失败</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> topElem;          <span class="comment">//存储栈顶元素</span></span><br><span class="line">            Pop(S, topElem);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StackEmpty(S);                <span class="comment">//栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-栈在表达式求值中的应用"><a href="#3-3-2-栈在表达式求值中的应用" class="headerlink" title="3.3.2 栈在表达式求值中的应用"></a>3.3.2 栈在表达式求值中的应用</h3><h3 id="1-中缀表达式-需要界限符"><a href="#1-中缀表达式-需要界限符" class="headerlink" title="1. 中缀表达式 (需要界限符)"></a><strong>1. 中缀表达式</strong> (需要界限符)</h3><p>运算符在两个操作数中间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① a + b</span><br><span class="line">② a + b - c</span><br><span class="line">③ a + b - c*d</span><br><span class="line">④ ((15 ÷ (7-(1+1)))×3)-(2+(1+1))</span><br><span class="line">⑤ A + B × (C - D) - E ÷ F</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<h3 id="2-后缀表达式-逆波兰表达式"><a href="#2-后缀表达式-逆波兰表达式" class="headerlink" title="2. 后缀表达式 (逆波兰表达式)"></a><strong>2. 后缀表达式</strong> (逆波兰表达式)</h3><p>运算符在两个操作数后面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① a b +</span><br><span class="line">② ab+ c - / a bc- +</span><br><span class="line">③ ab+ cd* -</span><br><span class="line">④ 15 7 1 1 + - ÷ 3 × 2 1 1 + + -</span><br><span class="line">⑤ A B C D - × + E F ÷ - (机算结果)</span><br><span class="line">  A B C D - × E F ÷ - + (不选择)</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>中缀表达式转后缀表达式-手算</strong></li>
</ul>
<p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p>
<p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[左操作数 右操作数 运算符]</code>的方式组合成一个新的操作数</p>
<p><strong>步骤3：</strong> 如果还有运算符没被处理，继续步骤2</p>
<p><strong>“左优先”原则:</strong> 只要左边的运算符能先计算，就优先算左边的 (保证运算顺序唯一)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中缀：A + B - C * D / E + F</span><br><span class="line">       ①   ④   ②   ③   ⑤     </span><br><span class="line">后缀：A B + C D * E / - F +</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<h3 id="重点：中缀表达式转后缀表达式-机算"><a href="#重点：中缀表达式转后缀表达式-机算" class="headerlink" title="重点：中缀表达式转后缀表达式-机算"></a><strong>重点：中缀表达式转后缀表达式-机算</strong></h3><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<strong>从左到右</strong>处理各个元素，直到末尾。可能遇到三种情况:</p>
<ul>
<li>遇到<strong>操作数</strong>: 直接加入后缀表达式。</li>
<li>遇到<strong>界限符</strong>: 遇到 <code>&#39;(&#39;</code> 直接入栈; 遇到 <code>&#39;)&#39;</code> 则依次弹出栈内运算符并加入后缀表达式，直到弹出 <code>&#39;(&#39;</code> 为止。注意: <code>&#39;(&#39;</code> 不加入后缀表达式。</li>
<li>遇到<strong>运算符</strong>: 依次弹出栈中优先级<strong>高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式，若碰到 <code>&#39;(&#39;</code> 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<ul>
<li><strong>后缀表达式的计算—手算:</strong></li>
</ul>
<p>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应的运算，合体为一个操作数；</p>
<p><strong>注意：</strong> 两个操作数的左右顺序</p>
<h3 id="重点：后缀表达式的计算—机算"><a href="#重点：后缀表达式的计算—机算" class="headerlink" title="重点：后缀表达式的计算—机算"></a><strong>重点：后缀表达式的计算—机算</strong></h3><p>用栈实现后缀表达式的计算（栈用来存放当前暂时不能确定运算次序的操作数）</p>
<p><strong>步骤1:</strong> 从左往后扫描下一个元素，直到处理完所有元素;</p>
<p><strong>步骤2:</strong> 若扫描到操作数，则压入栈，并回到<code>步骤1</code>;否则执行<code>步骤3</code>;</p>
<p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压回栈顶，回到<code>步骤1</code>;</p>
<p><strong>注意:</strong> 先出栈的是“右操作数”</p>
<h3 id="3-前缀表达式-波兰表达式"><a href="#3-前缀表达式-波兰表达式" class="headerlink" title="3.前缀表达式 (波兰表达式)"></a><strong>3.前缀表达式</strong> (波兰表达式)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运算符在两个操作数前面:</span><br><span class="line">① + a b</span><br><span class="line">② - +ab  c</span><br><span class="line">③ - +ab *cd</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>中缀表达式转前缀表达式—手算</strong></li>
</ul>
<p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p>
<p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[运算符 左操作数 右操作数]</code>的方式组合成一个新的操作数</p>
<p><strong>步骤3：</strong> 如果还有运算符没被处理，就继续执行<code>步骤2</code></p>
<p><strong>“右优先”原则:</strong> 只要右边的运算符能先计算，就优先算<strong>右边</strong>的;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中缀：A + B * (C - D) - E / F</span><br><span class="line">       ⑤   ③    ②    ④   ①</span><br><span class="line">前缀：+ A - * B - C D / E F</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>前缀表达式的计算—机算</strong></li>
</ul>
<p>用栈实现前缀表达式的计算</p>
<p><strong>步骤1:</strong> 从右往左扫描下一个元素，直到处理完所有元素；</p>
<p><strong>步骤2:</strong> 若扫描到操作数则压入栈，并回到<code>步骤1</code>，否则执行<code>步骤3</code></p>
<p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到<code>步骤1</code>；</p>
<p><strong>注意:</strong> 先出栈的是“左操作数”</p>
<h3 id="4-中缀表达式的计算-用栈实现"><a href="#4-中缀表达式的计算-用栈实现" class="headerlink" title="4.中缀表达式的计算(用栈实现)"></a><strong>4.中缀表达式的计算(用栈实现)</strong></h3><p>两个算法的结合： <a href="#重点中缀表达式转后缀表达式-机算">中缀转后缀</a> + <a href="#重点后缀表达式的计算机算">后缀表达式的求值</a></p>
<ul>
<li>初始化两个栈，<strong>操作数栈</strong> 和<strong>运算符栈</strong></li>
<li>若扫描到操作数，压人操作数栈</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈 (期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈项元素并执行相应运算，运算结果再压回操作数栈)</li>
</ul>
<h3 id="3-3-3-栈在递归中的应用"><a href="#3-3-3-栈在递归中的应用" class="headerlink" title="3.3.3 栈在递归中的应用"></a>3.3.3 栈在递归中的应用</h3><p>函数调用的特点：最后被调用的函数最先执行结束(LIFO)</p>
<p>函数调用时，需要用一个栈存储：</p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
<p>递归调用时，函数调用栈称为 “递归工作栈”:</p>
<ul>
<li>每进入一层递归，就将递归调用所需信息压入栈顶；</li>
<li>每退出一层递归，就从栈顶弹出相应信息；</li>
</ul>
<p><strong>缺点</strong>：太多层递归可能回导致栈溢出；</p>
<p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题；</p>
<h2 id="3-3-队列的应用"><a href="#3-3-队列的应用" class="headerlink" title="3.3 队列的应用"></a>3.3 队列的应用</h2><h3 id="3-3-1-树的层次遍历"><a href="#3-3-1-树的层次遍历" class="headerlink" title="3.3.1 树的层次遍历"></a>3.3.1 树的层次遍历</h3><p><em>（详见“树”章节）</em></p>
<h3 id="3-3-2-图的广度优先遍历"><a href="#3-3-2-图的广度优先遍历" class="headerlink" title="3.3.2 图的广度优先遍历"></a>3.3.2 图的广度优先遍历</h3><p><em>（详见“图”章节）</em></p>
<h3 id="3-3-3-队列在操作系统中的应用"><a href="#3-3-3-队列在操作系统中的应用" class="headerlink" title="3.3.3 队列在操作系统中的应用"></a>3.3.3 队列在操作系统中的应用</h3><p>多个进程争抢着使用优先的系统资源时，FCFS（先来先服务）是一种常用策略</p>
<p>Eg: CPU资源分配、打印数据缓冲区</p>
<h2 id="3-4-特殊矩阵的压缩存储"><a href="#3-4-特殊矩阵的压缩存储" class="headerlink" title="3.4 特殊矩阵的压缩存储"></a>3.4 特殊矩阵的压缩存储</h2><h3 id="3-4-1-数组的存储结构"><a href="#3-4-1-数组的存储结构" class="headerlink" title="3.4.1 数组的存储结构"></a>3.4.1 数组的存储结构</h3><ol>
<li>一维数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Elemtype a[10];</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>各数组元素大小相同，物理上连续存放；</p>
<p>起始地址：<code>LOC</code></p>
<p>数组下标：默认从0开始！</p>
<p>数组元素 <code>a[i]</code> 的存放地址 = <code>LOC + i × sizeof(ElemType)</code></p>
<ol>
<li>二维数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Elemtype b[2][4]; //2行4列的二维数组</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>行优先/列优先存储优点：实现随机存储</p>
<p>起始地址：<code>LOC</code></p>
<p>M行N列的二维数组 <code>b[M][N]</code> 中，<code>b[i][j]</code>的存储地址：</p>
<ul>
<li>行优先存储: <code>LOC + (i×N + j) × sizeof(ElemType)</code></li>
<li>列优先存储：<code>LOC + (j×M + i) × sizeof(ElemType)</code></li>
</ul>
<h3 id="3-4-2-普通矩阵的存储"><a href="#3-4-2-普通矩阵的存储" class="headerlink" title="3.4.2 普通矩阵的存储"></a>3.4.2 普通矩阵的存储</h3><p>二维数组存储</p>
<ul>
<li>描述矩阵元素时，行、列号通常从<code>1</code>开始；</li>
<li>描述数组时，通常下标从 <code>0</code> 开始；</li>
</ul>
<h3 id="3-4-3-特殊矩阵的存储"><a href="#3-4-3-特殊矩阵的存储" class="headerlink" title="3.4.3 特殊矩阵的存储"></a>3.4.3 特殊矩阵的存储</h3><p><em>特殊矩阵——压缩存储空间</em></p>
<ol>
<li>对称矩阵(方阵)</li>
<li>三角矩阵(方阵)</li>
<li>三对角矩阵(方阵)</li>
<li>稀疏矩阵</li>
</ol>
<ul>
<li>顺序存储——三元组</li>
<li>链式存储——十字链表法</li>
</ul>
<h1 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h1><h2 id="4-1-串的定义和实现"><a href="#4-1-串的定义和实现" class="headerlink" title="4.1 串的定义和实现"></a>4.1 串的定义和实现</h2><h3 id="4-1-1-串的定义"><a href="#4-1-1-串的定义" class="headerlink" title="4.1.1 串的定义"></a>4.1.1 串的定义</h3><ol>
<li>串: 零个或多个字符组成的有限序列，如 <code>S = &#39;iPhone 11 Pro Max?&#39;</code>；</li>
<li>串名：S是串名；</li>
<li>串的长度：串中字符的个数n；</li>
<li>空串：n=0时的串；</li>
<li>子串：串中任意多个连续的字符组成的子序列称为该串的子串；</li>
<li>主串：包含子串的串；</li>
<li>字符在主串中的位置：某个字符在串中的序号（从1开始）；</li>
<li>子串在主串中的位置：子串的第一个字符在主串中的位置；</li>
<li>空串 V.S 空格串：<ul>
<li><code>M = &#39;&#39;</code> 是空串；</li>
<li><code>N = &#39; &#39;</code> 是空格串；</li>
</ul>
</li>
<li>串 V.S 线性表：<ul>
<li>串是特殊的线性表，数据元素之间呈线性关系（逻辑结构相似）；</li>
<li>串的数据对象<strong>限定</strong>为字符集：中文字符、英文字符、数字字符、标点字符…</li>
<li>串的基本操作，如增删改除通常以<strong>子串</strong>为操作对象</li>
</ul>
</li>
</ol>
<h3 id="4-1-2-串的基本操作"><a href="#4-1-2-串的基本操作" class="headerlink" title="4.1.2 串的基本操作"></a>4.1.2 串的基本操作</h3><p>假设有串 <code>T = &#39;&#39;</code>, <code>S = &#39;iPhone 11 Pro Max?&#39;</code>, <code>W = &#39;Pro&#39;</code></p>
<ul>
<li><p><code>StrAssign(&amp;T, chars)</code>: 赋值操作，把串T赋值为chars；</p>
</li>
<li><p><code>StrCopy(&amp;T, S)</code>: 复制操作，把串S复制得到串T；</p>
</li>
<li><p><code>StrEmpty(S)</code>: 判空操作，若S为空串，则返回TRUE，否则返回False；</p>
</li>
<li><p>```<br>StrLength(S)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  : 求串长，返回串S的元素个数；</span><br><span class="line"></span><br><span class="line">  &gt; 返回`length`值</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  ClearString(&amp;S)</span><br></pre></td></tr></table></figure>
<p>: 清空操作，将S清为</p>
<p>空串</p>
<p>；</p>
<blockquote>
<p>将<code>length = 0</code>，逻辑上清空，但是内存中还有</p>
</blockquote>
</li>
<li><p><code>DestroyString(&amp;S)</code>: 销毁串，将串S销毁——<strong>回收存储空间</strong>；</p>
</li>
<li><p>```<br>Concat(&amp;T, S1, S2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  : 串联联接，用T返回由S1和S2联接而成的新串———可能会导致存储空间的扩展；</span><br><span class="line"></span><br><span class="line">  &gt; Concat(&amp;T, S, W)</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; T = ‘iPhone 11 Pro Max?Pro’</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  SubString(&amp;Sub, S, pos, len)</span><br></pre></td></tr></table></figure>
<p>: 求子串，用Sub返回串S的第pos个字符起长度为len的子串；</p>
<blockquote>
<p>SubString(&amp;T, S, 4, 6)</p>
<p>T = ‘one 11’</p>
</blockquote>
</li>
<li><p>```<br>Index(S, T)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  : 定位操作，若主串S中存在与串T值相同的子串，则返回它再主串S中第一次出现的位置，否则函数值为0；</span><br><span class="line"></span><br><span class="line">  &gt; Index(S, T)</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; &gt; 11</span><br><span class="line"></span><br><span class="line">- `StrCompare(S, T)`: 串的比较操作，参照英文词典排序方式；若S &gt; T,返回值&gt;0; S = T,返回值=0 **(需要两个串完全相同)** ; S &lt; T,返回值&lt;0;</span><br><span class="line"></span><br><span class="line">### 拓展：字符集编码</span><br><span class="line"></span><br><span class="line">1. 字符集:</span><br><span class="line">2. 编码方案</span><br><span class="line">3. 乱码问题</span><br><span class="line"></span><br><span class="line">### 4.1.3 串的存储结构</span><br><span class="line"></span><br><span class="line">1. 定长顺序存储表示</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#define MAXLEN 255   //预定义最大串长为255</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXLEN];   //静态数组实现（定长顺序存储）</span><br><span class="line">                       //每个分量存储一个字符</span><br><span class="line">                       //每个char字符占1B</span><br><span class="line">    int length;        //串的实际长度</span><br><span class="line">&#125;SString;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
</li>
<li><p>串长的两种表示法：</p>
<ul>
<li><p>方案一：用一个额外的变量<code>length</code>来存放串的长度（保留<code>ch[0]</code>）；</p>
</li>
<li><p>方案二：用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch[0]</span><br></pre></td></tr></table></figure>
<p>充当</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length</span><br></pre></td></tr></table></figure>
<p>；</p>
<ul>
<li>优点：字符的位序和数组下标相同；</li>
</ul>
</li>
<li><p>方案三：没有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length</span><br></pre></td></tr></table></figure>
<p>变量，以字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;\0&#x27;</span><br></pre></td></tr></table></figure>
<p>表示结尾（对应ASCII码的0）；</p>
<ul>
<li>缺点：需要从头到尾遍历；</li>
</ul>
</li>
<li><p><strong>方案四——最终使用方案：</strong><code>ch[0]</code>废弃不用，声明int型变量<code>length</code>来存放串的长度（方案一与方案二的结合）</p>
</li>
</ul>
</li>
<li><p>基本操作实现（基于方案四）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   </span><br><span class="line">    <span class="type">int</span> length;       </span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos+len<span class="number">-1</span> &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=pos; i&lt;pos+len; i++)</span><br><span class="line">        Sub.cn[i-pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">    </span><br><span class="line">    Sub.length = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 比较两个串的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i; i&lt;S.length &amp;&amp; i&lt;T.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定位操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    n = StrLength(S);</span><br><span class="line">    m = StrLength(T);</span><br><span class="line">    SString sub;        <span class="comment">//用于暂存子串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(Sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(Sub,T)!=<span class="number">0</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> i;    <span class="comment">// 返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;            <span class="comment">//S中不存在与T相等的子串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647</span></span><br></pre></td></tr></table></figure>
<p><em>ps:结合顺序表思考优缺点</em></p>
<ol>
<li>堆分配存储表示</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;           <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S；</span><br><span class="line">S.ch = (<span class="type">char</span> *) <span class="built_in">malloc</span>(MAXLINE * <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">//基地址指针指向连续空间的起始位置</span></span><br><span class="line">                                                <span class="comment">//malloc()需要手动free()</span></span><br><span class="line">S.length;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ol>
<li>串的链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;           <span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>问题：存储密度低，每个字符1B，每个指针4B；<br>解决方案：每一个链表的结点存储多个字符——每个结点称为块——块链结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];           <span class="comment">//每个结点存多个个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><em>ps:结合链表思考优缺点</em></p>
<ul>
<li>存储分配角度：链式存储的字符串无需占用连续空间，存储空间分配更灵活；</li>
<li>操作角度：若要在字符串中插入或删除某些字符，则顺序存储方式需要移动大量字符，而链式存储不用；</li>
<li>若要按位序查找字符，则顺序存储支持随机访问，而链式存储只支持顺序访问；</li>
</ul>
<h2 id="4-2-串的模式匹配"><a href="#4-2-串的模式匹配" class="headerlink" title="4.2 串的模式匹配"></a>4.2 串的模式匹配</h2><h3 id="4-2-1-朴素模式匹配算法"><a href="#4-2-1-朴素模式匹配算法" class="headerlink" title="4.2.1 朴素模式匹配算法"></a>4.2.1 朴素模式匹配算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;                <span class="comment">//扫描主串S</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;                <span class="comment">//扫描模式串T</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;             <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;             <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析：</strong></p>
<ul>
<li><p>主串长度为n，模式串长度为m</p>
</li>
<li><p>最多比较<code>n-m+1</code>个子串</p>
</li>
<li><p>最坏时间复杂度 =</p>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(nm)</span><br></pre></td></tr></table></figure>
<ul>
<li>每个子串都要对比m个字符(对比到最后一个字符才匹配不上)，共要对比n-m+1个子串，复杂度 = <code>O((n-m+1)m) = O(nm - m^2 + m) = O(nm)</code></li>
<li><em>PS:大多数时候，n&gt;&gt;m</em></li>
</ul>
<ul>
<li>最好时间复杂度 =</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(n)</span><br></pre></td></tr></table></figure>
<ul>
<li>每个子串的第一个字符就匹配失败，共要对比n-m+1个子串，复杂度 = <code>O(n-m+1) = O(n)</code></li>
</ul>
<h3 id="4-2-2-改进的模式匹配算法——KMP算法"><a href="#4-2-2-改进的模式匹配算法——KMP算法" class="headerlink" title="4.2.2 改进的模式匹配算法——KMP算法"></a>4.2.2 改进的模式匹配算法——KMP算法</h3><ul>
<li><p>不匹配的字符之前，一定是和模式串一致的；</p>
</li>
<li><p>根据模式串T，求出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next数组</span><br></pre></td></tr></table></figure>
<p>（只与模式串有关，与主串无关），利用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next数组</span><br></pre></td></tr></table></figure>
<p>进行匹配，</p>
<p>当匹配失败时，主串的指针 <code>i</code> 不再回溯！</p>
<blockquote>
<p>当第一个元素匹配失败时，匹配下一个相邻子串，令<code>j=0,i++,j++</code></p>
</blockquote>
</li>
</ul>
<ol>
<li>求<code>next数组</code>（会手算即可）</li>
</ol>
<ul>
<li>作用：当模式串的第<code>j</code>个字符失配时，从模式串的第<code>next[j]</code>继续往后匹配;</li>
<li>对于任何模式串，当第1个字符不匹配时，只能匹配下一个子串，因此，<code>next[1] = 0</code>——表示模式串应右移一位，主串当前指针后移一位，再和模式串的第一字符进行比较；</li>
<li>对于任何模式串，当第2个字符不匹配时，应尝试匹配模式串的第一个字符，因此，<code>next[2] = 0</code>;</li>
</ul>
<p>例：对于串 <code>T = &#39;abaabc&#39;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>next[0]</th>
<th>next[1]</th>
<th>next[2]</th>
<th>next[3]</th>
<th>next[4]</th>
<th>next[5]</th>
<th>next[6]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>利用<code>next数组</code>进行模式匹配</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;     <span class="comment">//主串</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;     <span class="comment">//模式串</span></span><br><span class="line">    <span class="keyword">while</span>（i&lt;S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j])&#123;      <span class="comment">//第一个元素匹配失败时</span></span><br><span class="line">            ++j;</span><br><span class="line">            ++i;         <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j]   <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length; <span class="comment">//匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 时间复杂度分析：</strong></p>
<ul>
<li>求next数组时间复杂度 = <code>O(m)</code></li>
<li>模式匹配过程最坏时间复杂度 = <code>O(n)</code></li>
<li>KMP算法的最坏时间复杂度 = <code>O(m+n)</code></li>
</ul>
<h3 id="4-2-3-KMP算法的进一步优化"><a href="#4-2-3-KMP算法的进一步优化" class="headerlink" title="4.2.3 KMP算法的进一步优化"></a>4.2.3 KMP算法的进一步优化</h3><h1 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h1><h2 id="5-1-树的基本概念"><a href="#5-1-树的基本概念" class="headerlink" title="5.1 树的基本概念"></a>5.1 树的基本概念</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><ul>
<li>空树</li>
<li>根结点、分支结点、叶子结点</li>
<li>非空树的特性</li>
<li>子树</li>
</ul>
<h3 id="5-1-2-基本术语"><a href="#5-1-2-基本术语" class="headerlink" title="5.1.2 基本术语"></a>5.1.2 基本术语</h3><ol>
<li>结点之间的关系描述<ul>
<li>祖先、子孙、双亲、兄弟…结点</li>
<li><strong>路径、路径长度</strong></li>
</ul>
</li>
<li>结点、树的属性描述<ul>
<li>结点的层次（深度）——从上往下</li>
<li>结点的高度——从下往上</li>
<li>树的高度——总共多少层</li>
<li><strong>结点的度</strong>——有几个孩子</li>
<li><strong>树的度</strong>——各结点的度的最大值</li>
</ul>
</li>
<li>有序树、无序树</li>
<li>森林</li>
</ol>
<h3 id="5-1-3-树的性质"><a href="#5-1-3-树的性质" class="headerlink" title="5.1.3 树的性质"></a>5.1.3 树的性质</h3><ol>
<li>结点数 = 总度数 + 1</li>
<li>度为<code>m</code>的数、<code>m</code>叉数的区别</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>度为 <code>m</code> 的树</th>
<th><code>m</code> 叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>树的度：<code>m</code>为各结点的度的最大值</td>
<td><code>m</code>叉树：每个结点最多只能有 <code>m</code> 个孩子的树</td>
</tr>
<tr>
<td>任意结点的度 ≦ m</td>
<td>任意结点的度 ≦ m</td>
</tr>
<tr>
<td>至少有一个结点度 = m</td>
<td>允许所有结点的度 &lt; m</td>
</tr>
<tr>
<td>一定是非空树，至少有m+1个结点</td>
<td>可以是空树</td>
</tr>
<tr>
<td>第i层至多有 <code>m^(i-1)</code>个结点</td>
<td>第i层至多有 <code>m^(i-1)</code>个结点</td>
</tr>
<tr>
<td>高度为<code>h</code>、度为 <code>m</code> 的树至少有<code>h+m-1</code>个结点</td>
<td>高度为<code>h</code>的<code>m</code>叉树至多有<code>(m^h-1)/(m-1)</code>个结点；至少有<code>h</code>个结点</td>
</tr>
<tr>
<td></td>
<td>具有<code>n</code>个结点的<code>m</code>叉树，最小高度为<code>⌈ logm(n(m-2)+1)⌉</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-2-二叉树的概念"><a href="#5-2-二叉树的概念" class="headerlink" title="5.2 二叉树的概念"></a>5.2 二叉树的概念</h2><h3 id="5-2-1-二叉树的定义与特性"><a href="#5-2-1-二叉树的定义与特性" class="headerlink" title="5.2.1 二叉树的定义与特性"></a>5.2.1 二叉树的定义与特性</h3><ol>
<li>二叉树有左右之分，次序不能颠倒</li>
</ol>
<h3 id="5-2-2几种特殊的二叉树"><a href="#5-2-2几种特殊的二叉树" class="headerlink" title="5.2.2几种特殊的二叉树"></a>5.2.2几种特殊的二叉树</h3><ol>
<li>满二叉树</li>
<li>完全二叉树</li>
<li>二叉排序树</li>
<li>平衡二叉树</li>
</ol>
<h3 id="5-2-3-二叉树的存储结构"><a href="#5-2-3-二叉树的存储结构" class="headerlink" title="5.2.3 二叉树的存储结构"></a>5.2.3 二叉树的存储结构</h3><ol>
<li>顺序存储</li>
</ol>
<p>二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>考点：</strong></p>
<ul>
<li><code>i</code>的左孩子：<code>2i</code></li>
<li><code>i</code>的右孩子：<code>2i + 1</code></li>
<li><code>i</code>的父节点：<code>⌊i/2⌋</code></li>
<li><code>i</code>所在的层次：<code>⌊log2n + 1⌋</code> or <code>⌈ log2n+1)⌉</code></li>
</ul>
<p><strong>若完全二叉树中共有n个结点</strong>（非完全二叉树不能用）</p>
<ul>
<li>判断<code>i</code>是否有左孩子：<code>2i ≦ n</code></li>
<li>判断<code>i</code>是否有右孩子：<code>2i+1 ≦ n</code></li>
<li>判断<code>i</code>是否时叶子/分支结点：<code>i &gt; ⌊n/2⌋</code></li>
</ul>
<p><strong>最坏情况：</strong> 高度为h且只有h个结点的单支树（所有结点只有右孩子），也至少需要2^h-1个存储单元；</p>
<p><strong>结论：</strong> 二叉树的顺序存储结构，只适合存储完全二叉树和满二叉树</p>
<ol>
<li>链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root -&gt; data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p -&gt; data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">p -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; lchild = p; <span class="comment">//作为根节点的左孩子</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>
<ul>
<li>找到指定结点p的左/右孩子；</li>
<li>找到指定节点p的父结点: 只能从根结点开始遍历，也可以使用<strong>三叉链表</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>          <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<ul>
<li>n个结点的二叉链表共有n+1个空链域</li>
</ul>
<h2 id="5-3-二叉树的遍历和线索二叉树"><a href="#5-3-二叉树的遍历和线索二叉树" class="headerlink" title="5.3 二叉树的遍历和线索二叉树"></a>5.3 二叉树的遍历和线索二叉树</h2><h3 id="5-3-1-二叉树的遍历"><a href="#5-3-1-二叉树的遍历" class="headerlink" title="5.3.1 二叉树的遍历"></a>5.3.1 二叉树的遍历</h3><ol>
<li>先序遍历（根左右）</li>
</ol>
<ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p><strong>空间复杂度：</strong> O(h)</p>
<ol>
<li>中序遍历（左根右）</li>
</ol>
<ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>先序遍历左子树</li>
<li>访问根节点</li>
<li>先序遍历右子树</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      InOrder(T-&gt;lchild);       <span class="comment">//递归遍历左子树</span></span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">      InOrder(T-&gt;rchild);       <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<ol>
<li>后续遍历（左右根）</li>
</ol>
<ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
<li>访问根节点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTnode</span>&#123;</span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild; </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">PostOrder</span>(T-&gt;lchild);       <span class="comment">//递归遍历左子树    </span></span><br><span class="line">      <span class="built_in">PostOrder</span>(T-&gt;rchild);       <span class="comment">//递归遍历右子树</span></span><br><span class="line">      <span class="built_in">visit</span>(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树的层次遍历</li>
</ol>
<p>算法思想：</p>
<ul>
<li>初始化一个辅助队列</li>
<li>根节点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，依次将其左、右孩子插入队尾（如果有的话）</li>
<li>重复以上操作直至队列为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">   BiTNode * data;</span><br><span class="line">   <span class="keyword">typedef</span> LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   LinkNode *front, *rear;  </span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue (Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<ol>
<li>由遍历序列构造二叉树</li>
</ol>
<ul>
<li>先序序列 + 中序序列</li>
<li>后序序列 + 中序序列</li>
<li>层序序列 + 中序序列</li>
</ul>
<p><strong>key:</strong> 找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点、</p>
<h3 id="5-3-2-线索二叉树"><a href="#5-3-2-线索二叉树" class="headerlink" title="5.3.2 线索二叉树"></a>5.3.2 线索二叉树</h3><ol>
<li>线索二叉树的概念与作用</li>
<li>线索二叉树的存储结构</li>
</ol>
<ul>
<li>中序线索二叉树——线索指向中序前驱、中序后继</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>tag == 0: 指针指向孩子</p>
<p>tag == 1: 指针是“线索”</p>
</blockquote>
<ul>
<li>先序线索二叉树——线索指向先序前驱、先序后继</li>
<li>后序线索二叉树——线索指向后序前驱、后序后继</li>
</ul>
<ol>
<li>二叉树的线索化</li>
</ol>
<ul>
<li>中序线索化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);    <span class="comment">//中序遍历左子树</span></span><br><span class="line">        visit(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        InThread(T-&gt;rchild);    <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      InThread(T);            <span class="comment">//中序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先序线索化</li>
</ul>
<p><em>注意【转圈】问题，当<code>ltag==0</code>时，才能对左子树先序线索化</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);</span><br><span class="line">      <span class="keyword">if</span>(T-&gt;ltag == <span class="number">0</span>)         <span class="comment">//lchild不是前驱线索</span></span><br><span class="line">         PreThread(T-&gt;lchild);</span><br><span class="line">      PreThread(T-&gt;rchild);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PreThread(T);            <span class="comment">//先序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>
<ul>
<li>后序线索化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      PostThread(T-&gt;lchild);</span><br><span class="line">      PostThread(T-&gt;rchild);</span><br><span class="line">      visit(T);                  <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PostThread(T);            <span class="comment">//后序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>
<ol>
<li>线索二叉树中找前驱、后继</li>
</ol>
<ul>
<li><p>中序线索二叉树找中序后继：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 则 next = p的右子树中最左下结点;</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最左下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//右子树最左下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p!=<span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度 = O(1)</p>
<ul>
<li><p>中序线索二叉树找中序前驱：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序前驱 <code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子, 则 next = p的左子树中最右下结点;</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最右下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;rchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//左子树最右下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//rtag==1，直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p!=<span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>先序线索二叉树找先序后继：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子（左孩子不知道）</p>
<blockquote>
<p>case1: 若p有左孩子 ——— 根 <strong>左</strong> 右 / 根 (<strong>根</strong> 左 右) 右</p>
<p>case2: 若p没有左孩子 ——— 根 <strong>右</strong> / 根 (<em>*根</em> *左 右)</p>
</blockquote>
</blockquote>
</li>
<li><p>先序线索二叉树找先序前驱：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序前驱<code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找p的先序前驱，（除非从头开始遍历/三叉链表</p>
<blockquote>
<p>case1: 如果能够找到p的父节点，且p是左孩子 —— p的父节点就是p的前驱；</p>
<p>case2: 如果能够找到p的父节点，且p是右孩子，且其左兄弟为空 —— p的父节点就是p的前驱；</p>
<p>case3: 如果能够找到p的父节点，且p是右孩子，且其左兄弟非空 —— p的前驱为左兄弟子树中最后一个被先序遍历到的结点（根节点出发，先往右，右没有往左，找到最下一层的结点）；</p>
<p>case4: p没有父节点，即p为根节点，则p没有先序前驱</p>
</blockquote>
</blockquote>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YjVVJjtQ-1623943811481)(先序线索二叉树找先序前驱.PNG)]</p>
</li>
<li><p>后序线索二叉树找后序前驱：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序前驱<code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子（不知道有没有右孩子）</p>
<blockquote>
<p>case1: 若p有右孩子 ——— 左 <strong>右</strong> 根 / 左 (左 右 <strong>根</strong>) 根</p>
<p>case2: 若p没有右孩子 ——— <strong>左</strong> 根 （左子树按后序遍历，最后一个结点，p的左孩子）</p>
</blockquote>
</blockquote>
</li>
<li><p>后序线索二叉树找后序后继：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序后继<code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非从头开始遍历/三叉链表</p>
<blockquote>
<p>case1: 如果能找到p的父节点，且p是右孩子 —— p的父节点即为其后继</p>
<p>case2: 如果能找到p的父节点，且p是左孩子，其右兄弟为空 —— p的父节点即为其后继</p>
<p>case3: 如果能找到p的父节点，且p是左孩子，其右兄弟非空 —— p的后继为其右兄弟子树中第一个被后序遍历的结点；</p>
<p>case4: p没有父节点，即p为根节点，则p没有后序后继；</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>中序线索二叉树</th>
<th>先序线索二叉树</th>
<th>后续线索二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>找前驱</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>找后继</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-4-树、森林"><a href="#5-4-树、森林" class="headerlink" title="5.4 树、森林"></a>5.4 树、森林</h2><h3 id="5-4-1-树的存储结构"><a href="#5-4-1-树的存储结构" class="headerlink" title="5.4.1 树的存储结构"></a>5.4.1 树的存储结构</h3><ol>
<li>双亲表示法(顺序存储)：每个结点中保存指向双亲的指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100  <span class="comment">//树中最多结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>      <span class="comment">//树的结点定义</span></span><br><span class="line">   ElemType data; </span><br><span class="line">   <span class="type">int</span> parent;      <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的类型定义</span></span><br><span class="line">   PTNode nodes[MAX_TREE_SIZE];   <span class="comment">//双亲表示</span></span><br><span class="line">   <span class="type">int</span> n;                         <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<ul>
<li>增：新增数据元素，无需按逻辑上的次序存储；（需要更改结点数<code>n</code>）</li>
<li>删（叶子结点）：① 将伪指针域设置为<code>-1</code>；②用后面的数据填补；（需要更改结点数<code>n</code>）</li>
<li>查询：①优点-查指定结点的双亲很方便；②缺点-查指定结点的孩子只能从头遍历，空数据导致遍历更慢；</li>
</ul>
<ol>
<li>孩子表示法(顺序+链式)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> child;    <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>    <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">   <span class="type">int</span> n, r;   <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<ol>
<li>孩子兄弟表示法（链式）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">   ElemType data;                               <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>     <span class="comment">//第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针</span></span><br><span class="line">&#125;CSNode. *CSTree;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-树、森林与二叉树的转换"><a href="#5-4-2-树、森林与二叉树的转换" class="headerlink" title="5.4.2 树、森林与二叉树的转换"></a>5.4.2 树、森林与二叉树的转换</h3><p>本质：森林中各个树的根节点之间视为兄弟关系</p>
<h3 id="5-4-3-树、森林的遍历"><a href="#5-4-3-树、森林的遍历" class="headerlink" title="5.4.3 树、森林的遍历"></a>5.4.3 树、森林的遍历</h3><ol>
<li>树的遍历</li>
</ol>
<ul>
<li>先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历；（与对应二叉树的先序遍历序列相同）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PreOrder(T);      <span class="comment">//先跟遍历下一个子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<ul>
<li>后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再返回根节点；（与对应二叉树的中序遍历序列相同）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PostOrder(T);      <span class="comment">//后跟遍历下一个子树</span></span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<ul>
<li>层序遍历（队列实现）：<ul>
<li>若树非空，则根结点入队；</li>
<li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；</li>
<li>重复以上操作直至队尾为空；</li>
</ul>
</li>
</ul>
<ol>
<li>森林的遍历</li>
</ol>
<ul>
<li>先序遍历：等同于依次对各个树进行<strong>先根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>先序遍历</strong>；</li>
<li>中序遍历：等同于依次对各个树进行<strong>后根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>中序遍历</strong>；</li>
</ul>
<h2 id="5-5-树与二叉树的应用"><a href="#5-5-树与二叉树的应用" class="headerlink" title="5.5 树与二叉树的应用"></a>5.5 树与二叉树的应用</h2><h3 id="5-5-1-二叉排序树（BST）"><a href="#5-5-1-二叉排序树（BST）" class="headerlink" title="5.5.1 二叉排序树（BST）"></a>5.5.1 二叉排序树（BST）</h3><ol>
<li>二叉排序树的定义</li>
</ol>
<p>左子树结点值&lt;跟结点值&lt;右子树结点值</p>
<ol>
<li>查找操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（非递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(1)</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;key)&#123;        <span class="comment">//若树空或等于跟结点值，则结束循环</span></span><br><span class="line">      <span class="keyword">if</span>(key&lt;T-&gt;key)       <span class="comment">//值小于根结点值，在左子树上查找</span></span><br><span class="line">         T = T-&gt;lchild;</span><br><span class="line">      <span class="keyword">else</span>                  <span class="comment">//值大于根结点值，在右子树上查找</span></span><br><span class="line">         T = T-&gt;rchild;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)</span></span><br><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(Kry == T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;lchild, key);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>
<ol>
<li>插入操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中插入关键字为k的新结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;           <span class="comment">//原树为空，新插入的结点为根结点</span></span><br><span class="line">      T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">      T-&gt;key = k;</span><br><span class="line">      T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">//插入成功</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(K == T-&gt;key)               <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)                 </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<ol>
<li>二叉排序树的构造</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Crear_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">   T = <span class="literal">NULL</span>;                     <span class="comment">//初始时T为空树</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">      BST_Insert(T,str[i]);     <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<ol>
<li>删除操作</li>
<li>查找效率分析</li>
</ol>
<ul>
<li>查找长度：查找运算中，需要对比关键字的次数，反映了查找操作时间复杂度；</li>
<li>查找成功的平均查找长度<code>ASL</code></li>
<li>查找失败的平均查找长度<code>ASL</code></li>
</ul>
<h3 id="5-5-2-平衡二叉树（AVL）"><a href="#5-5-2-平衡二叉树（AVL）" class="headerlink" title="5.5.2 平衡二叉树（AVL）"></a>5.5.2 平衡二叉树（AVL）</h3><ol>
<li>平衡二叉树的定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;         <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> balance;     <span class="comment">//平衡因子</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>;</span> *rchild; </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<ol>
<li>平衡二叉树的插入</li>
<li>插入新节点后如何调整“不平衡”问题</li>
</ol>
<p>调整最小不平衡子树</p>
<ul>
<li>LL:</li>
</ul>
<p>  在A结点的左孩子的左子树中插入导致不平衡</p>
<ul>
<li>调整： A的左孩子结点右上旋</li>
</ul>
<ul>
<li>RR:</li>
</ul>
<p>  在A结点的右孩子的右子树中插入导致不平衡</p>
<ul>
<li>调整： A的右孩子结点左上旋</li>
</ul>
<ul>
<li>LR:</li>
</ul>
<p>  在A结点的左孩子的右子树中插入导致不平衡</p>
<ul>
<li>调整： A的左孩子的右孩子，先左上旋再右上旋</li>
</ul>
<ul>
<li>RL:</li>
</ul>
<p>  在A结点的右孩子的左子树中插入导致不平衡</p>
<ul>
<li>调整： A的右孩子的左孩子，先右上旋再左上旋</li>
</ul>
<ol>
<li>平衡二叉树的查找与效率分析</li>
</ol>
<p>若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过<code>O(h)</code>;</p>
<h3 id="5-5-3-哈夫曼树"><a href="#5-5-3-哈夫曼树" class="headerlink" title="5.5.3 哈夫曼树"></a>5.5.3 哈夫曼树</h3><ol>
<li>带权路径长度</li>
<li>哈夫曼树的定义</li>
<li>哈夫曼树的构造（重点）</li>
<li>哈杜曼编码（重点）</li>
</ol>
<h1 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h1><h1 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h1><h1 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h1><h2 id="8-1-排序的基本概念"><a href="#8-1-排序的基本概念" class="headerlink" title="8.1 排序的基本概念"></a>8.1 排序的基本概念</h2><ol>
<li>排序：重新排列表中的元素，使表中元素满足按关键字有序的过程（关键字可以相同）</li>
<li>排序算法的评价指标：时间复杂度、空间复杂度；</li>
<li>排序算法的稳定性：关键字相同的元素在排序之后相对位置不变，称为稳定的；（选择题考查）<br><strong>Q：</strong> 稳定的排序算法一定比不稳定的好？<br><strong>A：</strong> 不一定，要看实际需求；</li>
<li>排序算法的分类：<br><strong>内部排序：</strong> 数据都在内存——关注如何使时间、空间复杂度更低；<br><strong>外部排序：</strong> 数据太多，无法全部放入内存——关注如何使时间、空间复杂度更低，如何使读/写磁盘次数更少；</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">美国旧金山大学-可视化学习网站</a></p>
<h2 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h2><h3 id="8-2-1-直接插入排序"><a href="#8-2-1-直接插入排序" class="headerlink" title="8.2.1 直接插入排序"></a>8.2.1 直接插入排序</h3><ol>
<li><strong>算法思想：</strong> 每次将一个待排序的记录按其关键字大小，插入（依次对比、移动）到前面已经排好序的子序列中，直到全部记录插入完成</li>
<li><strong>代码实现：</strong></li>
</ol>
<ul>
<li>不带“哨兵”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;    <span class="comment">//A中共n个数据元素</span></span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;    <span class="comment">//A[i]关键字小于前驱</span></span><br><span class="line">            temp = A[i];  </span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; --j)</span><br><span class="line">                A[j<span class="number">-1</span>] = A[j];     <span class="comment">//所有大于temp的元素都向后挪</span></span><br><span class="line">            A[j+<span class="number">1</span>] = temp;         <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ul>
<li>带“哨兵” ，优点：不用每轮循环都判断<code>j&gt;=0</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;    <span class="comment">//A中从1开始存储，0放哨兵</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;    </span><br><span class="line">            A[<span class="number">0</span>] = A[i];     <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)  <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];     <span class="comment">//向后挪动</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];          <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：主要来自于对比关键字、移动关键字，若有n个元素，则需要n-1躺处理<ul>
<li><strong>最好情况：</strong> 原本为有序，共n-1趟处理，每一趟都只需要对比1次关键字，不需要移动元素，共对比n-1次 —— <strong>O(n)</strong></li>
<li><strong>最差情况：</strong> 原本为逆序 —— O(n²)</li>
<li><strong>平均情况：</strong> O(n²)</li>
</ul>
</li>
<li>算法稳定性：稳定</li>
</ul>
<ol>
<li><strong>对链表进行插入排序</strong></li>
</ol>
<ul>
<li>移动元素的次数变少了，因为只需要修改指针，不需要依次右移；</li>
<li>但是关键字对比的次数依然是<strong>O(n²)\</strong>数量级，因此整体看来*<em>时间复杂度仍然是O(n²)*</em></li>
</ul>
<h3 id="8-2-2-折半插入排序"><a href="#8-2-2-折半插入排序" class="headerlink" title="8.2.2 折半插入排序"></a>8.2.2 折半插入排序</h3><ol>
<li><strong>思路：</strong> 先用折半查找找到应该插入的位置，再移动元素；</li>
<li>为了保证稳定性，当查找到和插入元素关键字一样的元素时，应该继续在这个元素的右半部分继续查找以确认位置; 即当 <code>A[mid] == A[0]</code> 时，应继续在mid所指位置右边寻找插入位置</li>
<li>当<code>low&gt;high</code>时，折半查找停止，应将[low,i-1]or[high+1,i-1]内的元素全部右移，并将A[0]复制到low所指的位置；</li>
<li><strong>代码实现</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123; </span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];                    <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;            <span class="comment">//折半查找的范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;               <span class="comment">//折半查找</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;       <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])             <span class="comment">//查找左半子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//查找右半子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;high+<span class="number">1</span>;--j)       <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        A[high+<span class="number">1</span>] = A[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>
<ol>
<li>与<code>直接插入排序</code>相比，比较关键字的次数减少了，但是移动元素的次数没有变，<strong>时间复杂度仍然是O(n²)</strong></li>
</ol>
<h3 id="8-2-3-希尔排序"><a href="#8-2-3-希尔排序" class="headerlink" title="8.2.3 希尔排序"></a>8.2.3 希尔排序</h3><ol>
<li><strong>思路：</strong> 先追求表中元素的部分有序，再逐渐逼近全局有序；</li>
<li>更适用于基本有序的排序表和数据量不大的排序表，<strong>仅适用于线性表为顺序存储的情况</strong></li>
<li><strong>代码实现：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//A[0]为暂存单元</span></span><br><span class="line">    <span class="keyword">for</span>(dk=n/<span class="number">2</span>; dk&gt;=<span class="number">1</span>; dk=dk/<span class="number">2</span>)   <span class="comment">//步长递减（看题目要求，一般是1/2</span></span><br><span class="line">        <span class="keyword">for</span>(i=dk+<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-dk])&#123;</span><br><span class="line">                A[<span class="number">0</span>]=A[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-dk; j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=dk)</span><br><span class="line">                    A[j+dk]=A[j];         <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+dk]=A[<span class="number">0</span>;]             <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间效率：空间复杂度=<strong>O(1)</strong></li>
<li>时间效率: 最坏情况下时间复杂度=<strong>O(n²)</strong></li>
<li>稳定性：希尔排序是一种<strong>不稳定</strong>的排序方法</li>
</ul>
<h2 id="8-3-交换排序"><a href="#8-3-交换排序" class="headerlink" title="8.3 交换排序"></a>8.3 交换排序</h2><p><strong>基于“交换”的排序：</strong>根据序列中两个元素关键字的比较结果来对换这两个记录再序列中的位置；</p>
<h3 id="8-3-1-冒泡排序"><a href="#8-3-1-冒泡排序" class="headerlink" title="8.3.1 冒泡排序"></a>8.3.1 冒泡排序</h3><ol>
<li>第一趟排序使关键字值最小的一个元素“冒”到最前面（其最终位置）—— <strong>每趟冒泡的结果是把序列中最小元素放到序列的最终位置，这样最多做<code>n-1</code>趟冒泡就能把所有元素排好序</strong>；</li>
<li>为保证稳定性，关键字相同的元素不交换；</li>
<li><strong>代码实现</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;   <span class="comment">//从0开始存放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i; j--) <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;      <span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);  <span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;       <span class="comment">//本趟遍历后没有发生交换，说明表已经有序，可以结束算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间复杂度：<strong>O(1)</strong></li>
<li>时间复杂度<ul>
<li>最好情况 (有序) ：只需要一趟排序，比较次数=n-1，交换次数=0，最好时间复杂度=O(n)</li>
<li>最坏情况 (逆序) ：比较次数 = <code>(n-1)+(n-2)+...+1 = n(n-1)/2</code> = 交换次数，最坏时间复杂度 = O(n²)，平均时间复杂度 = O(n²)</li>
</ul>
</li>
</ul>
<ol>
<li>冒泡排序可以用于链表、顺序表</li>
</ol>
<h3 id="8-3-2-快速排序"><a href="#8-3-2-快速排序" class="headerlink" title="8.3.2 快速排序"></a>8.3.2 快速排序</h3><ol>
<li>每一趟排序都可使一个<strong>中间元素确定其最终位置</strong></li>
<li>用一个元素（不一定是第一个）把待排序序列“划分”为两个部分，左边更小，右边更大，该元素的最终位置已确认</li>
<li>算法实现（重点）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分为左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];          <span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high; <span class="comment">//high所指元素大于枢轴，high左移</span></span><br><span class="line">        A[low] = A[high];   <span class="comment">//high所指元素小于枢轴，移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot)  ++low; <span class="comment">//low所指元素小于枢轴，low右移</span></span><br><span class="line">        A[high] = A[low];   <span class="comment">//low所指元素大于枢轴，移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot   <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low；     <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> QuickSort(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)   <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos = Partition(A, low, high);   <span class="comment">//划分</span></span><br><span class="line">        QuickSort（A, low, pivotpos - <span class="number">1</span>);    <span class="comment">//划分左子表</span></span><br><span class="line">        QuickSort（A, pivotpos + <span class="number">1</span>, high);   <span class="comment">//划分右子表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>每一层的<code>QuickSort</code>只需要处理剩余的待排序元素，时间复杂度不超过O(n);</li>
<li></li>
<li>把n个元素组织成二叉树，二叉树的层数就是递归调用的层数，n个结点的二叉树<strong>最小高度</strong> = <code>⌊log₂n⌋ + 1</code>, <strong>最大高度</strong> = <code>n</code></li>
<li><strong>时间复杂度 = O(n×递归层数)</strong> （递归层数最大为n）<ul>
<li>最好 = <code>O(nlog₂n)</code> : 每次选的枢轴元素都能将序列划分成均匀的两部分；</li>
<li>最坏 = <code>O(n²)</code> ：序列本就有序或逆序，此时时间、空间复杂度最高；</li>
<li>平均时间复杂度 = <code>O(nlog₂n)</code> （接近最好而不是最坏）</li>
</ul>
</li>
<li><strong>空间复杂度 = O(递归层数)</strong>（递归层数最小为log₂n）<ul>
<li>最好 = <code>O(log₂n)</code></li>
<li>最坏 = <code>O(n)</code></li>
</ul>
</li>
<li>若每一次选中的“枢轴”可以将待排序序列划分为<strong>均匀</strong>的两个部分，则递归深度最小，算法效率最高；</li>
<li>若初始序列本就<strong>有序或者逆序</strong>,则快速排序的性能最差；</li>
<li><strong>快速排序算法优化思路：</strong> 尽量选择可以把数据中分的枢轴元素<ul>
<li>选头、中、尾三个位置的元素，取中间值作为枢轴元素；</li>
<li>随机选一个元素作为枢轴元素；</li>
</ul>
</li>
<li>快速排序使所有内部排序算法中平均<strong>性能最优</strong>的排序算法；</li>
<li><strong>稳定性：</strong> 不稳定；</li>
</ul>
<h2 id="8-4-选择排序"><a href="#8-4-选择排序" class="headerlink" title="8.4 选择排序"></a>8.4 选择排序</h2><p><strong>选择排序思想：</strong> 每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列；</p>
<h3 id="8-4-1-简单选择排序"><a href="#8-4-1-简单选择排序" class="headerlink" title="8.4.1 简单选择排序"></a>8.4.1 简单选择排序</h3><ol>
<li><code>n</code>个元素的简单选择排序需要<code>n-1</code>趟处理；</li>
<li>代码实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;       <span class="comment">//A从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;          <span class="comment">//一共进行n-1趟，i指向待排序序列中第一个元素</span></span><br><span class="line">        <span class="type">int</span> min = i;                   <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)       <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min]) min = j;   <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i)                     </span><br><span class="line">            swao(A[i],A[min]);         <span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li><strong>空间复杂度</strong> = <code>O(1)</code></li>
<li>无论有序、逆序、乱序，都需要n-1的处理，总共需要<strong>对比关键字</strong> <code>(n-1)+(n-2)+...+1 = n(n-2)/2</code> 次，元素<strong>交换次数</strong> &lt; <code>n-1</code>; <strong>时间复杂度</strong> = <code>O(n²)</code></li>
<li><strong>稳定性：</strong> 不稳定</li>
<li><strong>适用性：</strong> 既可以用于顺序表，也可以用于链表；</li>
</ul>
<h3 id="8-4-2-堆排序"><a href="#8-4-2-堆排序" class="headerlink" title="8.4.2 堆排序"></a>8.4.2 堆排序</h3><ol>
<li><strong>什么是“堆（Heap）”？</strong></li>
</ol>
<p>可理解为顺序存储的二叉树，注意</p>
<blockquote>
<p>可以将堆视为一棵 <strong>完全二叉树</strong> (✔)</p>
<p>可以将堆视为一棵 <strong>二叉排序树</strong> (✖)</p>
</blockquote>
<ul>
<li>大根堆：完全二叉树中，根 ≥ 左、右</li>
<li>小根堆：完全二叉树中，根 ≤ 左、右</li>
</ul>
<ol>
<li><strong>如何基于“堆”进行排序</strong></li>
</ol>
<p>基本思路：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列，<strong>堆顶元素的关键字最大或最小</strong> （以下以大根堆为例）</p>
<p>① 将给定初始序列(n个元素)，<strong>建立初始大根堆</strong>：把所有<strong>非终端结点</strong> <strong>从后往前</strong>都检查一遍，是否满足大根堆的要求——<code>根 ≥ 左、右</code>，若不满足，则将当前结点与更大的孩子互换</p>
<ul>
<li>在顺序存储的完全二叉树中:<ul>
<li>非终端结点的编号 <code>i≤⌊n/2⌋</code></li>
<li><code>i</code> 的左孩子 <code>2i</code></li>
<li><code>i</code> 的右孩子 <code>2i+1</code></li>
<li><code>i</code> 的父节点<code>⌊i/2⌋</code></li>
</ul>
</li>
<li>更小的元素“下坠”后，可能导致下一层的子树不符合大根堆的要求，则采用相同的方法继续往下调整 —— <strong>小元素不断“下坠”</strong></li>
</ul>
<p>② <strong>基于大根堆进行排序</strong>：每一趟将堆顶元素加入有序子序列中，堆顶元素与待排序序列中最后一个元素交换后，即最大元素换到末尾，之后该位置就不用改变，即移出完全二叉树(<code>len=len-1</code>)，把剩下的待排序元素序列再调整为大根堆；————<strong>“一趟处理”</strong></p>
<p>③ 剩下最后一个元素则不需要再调整；</p>
<ol>
<li><strong>代码实现</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对初始序列建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)   <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="comment">从最底层的分支结点开始调整*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                      <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">                                      <span class="comment">// i为当前所选根结点的左孩子</span></span><br><span class="line">                                      <span class="comment">//i*=2是为了判断调整后再下一层是否满足大根堆</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])      <span class="comment">//判断：当前所选根结点的左、右结点哪个更大</span></span><br><span class="line">            i++;                      <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) </span><br><span class="line">            <span class="keyword">break</span>;                    <span class="comment">//筛选结束：i指向更大的子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];              <span class="comment">//将A[i]调整至双亲结点上</span></span><br><span class="line">            k=i;                      <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]                       <span class="comment">//被筛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> swap(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于大根堆进行排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);          <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;      <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);          <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);       <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>
<h2 id="8-5-归并排序和基数排序"><a href="#8-5-归并排序和基数排序" class="headerlink" title="8.5 归并排序和基数排序"></a>8.5 归并排序和基数排序</h2><h3 id="8-5-1-归并排序"><a href="#8-5-1-归并排序" class="headerlink" title="8.5.1 归并排序"></a>8.5.1 归并排序</h3><ul>
<li><strong>归并（Merge）</strong>：把两个或多个已经有序的序列合并成一个；</li>
<li><strong>k路归并：\</strong>每选出一个元素，需对比关键字*<em>k-1*</em>次；</li>
<li>外部排序通常采用归并排序，内部排序一般采用2路归并；</li>
<li><strong>代码实现</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建辅助数组B</span></span><br><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low,...,mid],A[mid+1,...,high] 各自有序，将这两个部分归并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low; k&lt;=high; k++)</span><br><span class="line">        B[k] = A[k];           <span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;= high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])          <span class="comment">//为保证稳定性两个元素相等时，优先使用靠前的那个</span></span><br><span class="line">            A[k]=B[i++];        <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//没有归并完的部分复制到尾部，while只会执行一个 </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)  A[k++]=B[i++];     <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];     <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;    <span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A, low, mid);    <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A, mid+<span class="number">1</span>, high); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);     <span class="comment">//归并</span></span><br><span class="line">    &#125;<span class="keyword">if</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>
<ul>
<li>算法效率分析<ul>
<li>归并排序的比较次数与序列的初始状态无关；</li>
<li>2路归并的“归并树”——倒立的二叉树，树高<code>h</code>，归并排序趟数<code>m = h-1</code>，第<code>h</code>层最多<code>2^(h-1)</code>个结点，则满足<code>n ≤ 2^(h-1)</code>，即<code>h-1 = ⌈log₂n⌉</code>; <strong>结论: n个元素进行2路归并排序，归并趟数 m = ⌈log₂n⌉</strong></li>
<li>每趟归并时间复杂度为<code>O(n)</code>, 算法<strong>总时间复杂度</strong>为<code>O(nlog₂n)</code>;</li>
<li><strong>空间复杂度</strong>为<code>O(n)</code>; (归并排序算法可视为本章占用辅助空间最多的排序算法)</li>
<li>稳定性：归并排序是<strong>稳定</strong>的</li>
<li>对于<code>N</code>个元素进行<code>k</code>路归并排序，排序的趟数<code>m</code>满足 <code>k^m = N, m = ⌈logkN⌉</code></li>
</ul>
</li>
</ul>
<h3 id="8-5-2-基数排序"><a href="#8-5-2-基数排序" class="headerlink" title="8.5.2 基数排序"></a>8.5.2 基数排序</h3><ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间效率：<code>O(r)</code>, 其中r为基数，需要的辅助空间(队列)为r；</li>
<li>时间效率：一共进行<code>d</code>趟分配收集，一趟分配需要<code>O(n)</code>, 一趟收集需要<code>O(r)</code>, 时间复杂度为 <strong><code>O[d(n+r)]</code></strong>，且<strong>与序列的初始状态无关</strong></li>
<li>稳定性：稳定！</li>
</ul>
<ol>
<li>基数排序擅长解决的问题</li>
</ol>
<p>①数据元素的关键字可以方便地拆分为d组，且d较小；<br>②每组关键字的取值范围不大，即r较小；<br>③数据元素个数n较大；</p>
<h3 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h3><h3 id="1-稳定性"><a href="#1-稳定性" class="headerlink" title="1. 稳定性"></a>1. <strong>稳定性</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>稳定</th>
<th>不稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>简单选择排序</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>希尔排序</td>
</tr>
<tr>
<td>归并排序</td>
<td>快速排序</td>
</tr>
<tr>
<td>基数排序</td>
<td>堆排序</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2. 时间复杂度"></a>2. <strong>时间复杂度</strong></h3><ul>
<li>平均情况下：<strong>快速排序、希尔排序、归并排序、堆排序</strong> 均为 O(nlog2n)； <strong>基数排序</strong>为O(d(n+r))； <strong>其余</strong>全是O(n²);</li>
<li>最坏情况下：<strong>快速排序、希尔排序</strong> 为O(n²)，其余与平均情况一样；</li>
<li>最好情况下：<strong>直接插入排序、冒泡排序、希尔排序</strong> 为 O(n)，其余与平均情况一样；</li>
</ul>
<h3 id="3-空间复杂度"><a href="#3-空间复杂度" class="headerlink" title="3. 空间复杂度"></a>3. <strong>空间复杂度</strong></h3><ul>
<li><strong>快速排序</strong> ：平均 —— O(log2n)；最坏 —— O(n);</li>
<li><strong>2路归并排序</strong>：O(n)；</li>
<li><strong>基数排序</strong>：O®;</li>
<li>其余都是 O(1);</li>
<li>就辅助空间而言：堆排序&lt;快速排序&lt;归并排序</li>
</ul>
<h3 id="4-过程特征"><a href="#4-过程特征" class="headerlink" title="4. 过程特征"></a>4. <strong>过程特征</strong></h3><ul>
<li>经过一趟排序，能够保证一个元素到达最终位置： 交换类——<strong>冒泡、快速</strong>；选择类———<strong>简单选择、堆</strong>；</li>
<li>排序方法的<strong>元素比较次数</strong>与原始序列<strong>无关</strong>：<strong>简单选择、折半插入</strong></li>
<li>排序方法的<strong>排序趟数</strong>与原始序列<strong>有关</strong>：<strong>交换类——冒泡、快速</strong></li>
<li>排序方法中，<strong>元素的移动次数</strong>与原始序列<strong>无关</strong>：<strong>基数排序</strong></li>
<li>初始序列有序时，冒泡排序比较<code>n-1</code>次，不需要移动元素；</li>
<li><strong>希尔排序</strong>和<strong>堆排序</strong>利用顺序存储的随机访问特征，注意链式存储不支持这种性质；</li>
</ul>
<h3 id="5-排序算法的选择"><a href="#5-排序算法的选择" class="headerlink" title="5. 排序算法的选择"></a>5. <strong>排序算法的选择</strong></h3><ul>
<li>若<strong>n较小</strong>，可采用时间复杂度为<strong>O(n²)</strong>的排序方法：<strong>直接插入排序、简单选择排序</strong>，该情况下，若记录本身信息量较大，用简单选择排序；</li>
<li>若<strong>n较大</strong>，应采用时间复杂度为<strong>O(nlog2n)</strong>的排序方法：<strong>快速排序、归并排序、堆排序</strong></li>
<li><strong>快速排序</strong>——目前基于比较的内部排序方法中<strong>最好</strong>的方法，当关键字随机分布时，平均实际最短；</li>
<li>若<strong>n很大</strong>，记录的关键字位数较少且可分解，选择<strong>基数排序</strong></li>
<li>若记录本上信息量较大，可用链表作为存储结构；</li>
<li>若要求排序稳定且时间复杂度为O(nlog2n)，则选择<strong>归并排序</strong>，通常和直接插入排序结合使用：先利用直接插入排序求得较长的有序子文件，再两两归并，仍是稳定；</li>
<li>基数排序不能对<code>float</code>和<code>double</code>类型的实数进行排序；</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wjl-a.github.io/blot.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wjl-a.github.io/blot.github.io/2022/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB/">https://wjl-a.github.io/blot.github.io/2022/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wjl-a.github.io/blot.github.io" target="_blank">醉卿枫 の 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blot.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blot.github.io/2022/07/01/%E4%B8%89%E3%80%81%E6%A0%91/" title="3.树与二叉树"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">3.树与二叉树</div></div></a></div><div><a href="/blot.github.io/2022/06/04/%E4%B8%80%EF%BC%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="1.线性表"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-04</div><div class="title">1.线性表</div></div></a></div><div><a href="/blot.github.io/2022/06/04/%E4%BA%8C%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" title="2.栈与队列"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-04</div><div class="title">2.栈与队列</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjU3Ni8zMzAzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206041656239.jpg" onerror="this.onerror=null;this.src='/blot.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/blot.github.io/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/blot.github.io/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/blot.github.io/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47311204?type=blog"><i class="fab fa-csdn"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206081208248.jpg" target="_blank" title="Wexin"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">王道考研数据结构笔记</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">第二章 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">2.1 线性表的定义和基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number"></span> <span class="toc-text">2.2 线性表的顺序表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number"></span> <span class="toc-text">2.2.1 顺序表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number"></span> <span class="toc-text">2.2.2 顺序表上基本操作的实现 (插入和删除)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number"></span> <span class="toc-text">2.3 线性表的链式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number"></span> <span class="toc-text">2.3.1 单链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">2.3.2 单链表上基本操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%86%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">重要应用：链表的逆置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">2.3.3 双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">2.3.4 循环链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8-amp-%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">单链表 &amp; 循环单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8-amp-%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">双链表 &amp; 循环双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">2.3.5 静态链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number"></span> <span class="toc-text">2.3.6 顺序表和链表的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">第三章 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A0%88-stack"><span class="toc-number"></span> <span class="toc-text">3.1 栈 (stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">3.1.1 栈的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E5%88%9B-amp-%E9%94%80%E2%80%9D"><span class="toc-number"></span> <span class="toc-text">“创&amp;销”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E5%A2%9E-amp-%E5%88%A0%E2%80%9D"><span class="toc-number"></span> <span class="toc-text">“增&amp;删”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E6%9F%A5-amp-%E5%85%B6%E4%BB%96%E2%80%9D"><span class="toc-number"></span> <span class="toc-text">“查&amp;其他”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">3.1.2 栈的顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">3.1.3 栈的链式存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%98%9F%E5%88%97-Queue"><span class="toc-number"></span> <span class="toc-text">3.2 队列(Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">3.2.1 队列的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E5%88%9B-amp-%E9%94%80%E2%80%9D-1"><span class="toc-number"></span> <span class="toc-text">“创&amp;销”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E5%A2%9E-amp-%E5%88%A0%E2%80%9D-1"><span class="toc-number"></span> <span class="toc-text">“增&amp;删”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E6%9F%A5-amp-%E5%85%B6%E4%BB%96%E2%80%9D-1"><span class="toc-number"></span> <span class="toc-text">“查&amp;其他”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">3.2.2 队列的顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E5%88%A4%E6%BB%A1"><span class="toc-number"></span> <span class="toc-text">循环队列如何判满</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80-%E7%89%BA%E7%89%B2%E4%B8%80%E4%B8%AA%E5%8D%95%E5%85%83%E6%9D%A5%E5%8C%BA%E5%88%86%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1"><span class="toc-number"></span> <span class="toc-text">方案一: 牺牲一个单元来区分队空和队满</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C-%E4%B8%8D%E7%89%BA%E7%89%B2%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%AE%BE%E7%BD%AEsize"><span class="toc-number"></span> <span class="toc-text">方案二: 不牺牲存储空间，设置size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89-%E4%B8%8D%E7%89%BA%E7%89%B2%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%AE%BE%E7%BD%AEtag"><span class="toc-number"></span> <span class="toc-text">方案三: 不牺牲存储空间，设置tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BA%E9%A2%98%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%B0%BE%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">其他出题方法——队尾指针指向队尾元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">3.2.3 队列的链式存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">3.2.4 双端队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3.3 栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3.3.1 栈在括号匹配中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3.3.2 栈在表达式求值中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%9C%80%E8%A6%81%E7%95%8C%E9%99%90%E7%AC%A6"><span class="toc-number"></span> <span class="toc-text">1. 中缀表达式 (需要界限符)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">2. 后缀表达式 (逆波兰表达式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%9C%BA%E7%AE%97"><span class="toc-number"></span> <span class="toc-text">重点：中缀表达式转后缀表达式-机算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E2%80%94%E6%9C%BA%E7%AE%97"><span class="toc-number"></span> <span class="toc-text">重点：后缀表达式的计算—机算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">3.前缀表达式 (波兰表达式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">4.中缀表达式的计算(用栈实现)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3.3.3 栈在递归中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3.3 队列的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">3.3.1 树的层次遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">3.3.2 图的广度优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E9%98%9F%E5%88%97%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3.3.3 队列在操作系统中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">3.4 特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">3.4.1 数组的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%99%AE%E9%80%9A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">3.4.2 普通矩阵的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">3.4.3 特殊矩阵的存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">第四章 串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">4.1 串的定义和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number"></span> <span class="toc-text">4.1.1 串的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">4.1.2 串的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number"></span> <span class="toc-text">4.2 串的模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">4.2.1 朴素模式匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">4.2.2 改进的模式匹配算法——KMP算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-KMP%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">4.2.3 KMP算法的进一步优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">第五章 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">5.1 树的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number"></span> <span class="toc-text">5.1.1 树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number"></span> <span class="toc-text">5.1.2 基本术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number"></span> <span class="toc-text">5.1.3 树的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">5.2 二叉树的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">5.2.1 二叉树的定义与特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">5.2.2几种特殊的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">5.2.3 二叉树的存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">5.3 二叉树的遍历和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">5.3.1 二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">5.3.2 线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="toc-number"></span> <span class="toc-text">5.4 树、森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">5.4.1 树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number"></span> <span class="toc-text">5.4.2 树、森林与二叉树的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">5.4.3 树、森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">5.5 树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">5.5.1 二叉排序树（BST）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">5.5.2 平衡二叉树（AVL）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">5.5.3 哈夫曼树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE"><span class="toc-number"></span> <span class="toc-text">第六章 图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="toc-number"></span> <span class="toc-text">第七章 查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">第八章 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">8.1 排序的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.2 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.2.1 直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.2.2 折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.2.3 希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.3 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.3.1 冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.3.2 快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.4 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.4.1 简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.4.2 堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.5 归并排序和基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.5.1 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-2-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">8.5.2 基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">8.6 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">1. 稳定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">2. 时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">3. 空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%87%E7%A8%8B%E7%89%B9%E5%BE%81"><span class="toc-number"></span> <span class="toc-text">4. 过程特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number"></span> <span class="toc-text">5. 排序算法的选择</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blot.github.io/2022/07/01/%E4%B8%89%E3%80%81%E6%A0%91/" title="3.树与二叉树"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/blot.github.io/img/404.jpg'" alt="3.树与二叉树"/></a><div class="content"><a class="title" href="/blot.github.io/2022/07/01/%E4%B8%89%E3%80%81%E6%A0%91/" title="3.树与二叉树">3.树与二叉树</a><time datetime="2022-07-01T00:00:00.000Z" title="发表于 2022-07-01 08:00:00">2022-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blot.github.io/2022/06/04/%E4%BA%8C%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" title="2.栈与队列"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/blot.github.io/img/404.jpg'" alt="2.栈与队列"/></a><div class="content"><a class="title" href="/blot.github.io/2022/06/04/%E4%BA%8C%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" title="2.栈与队列">2.栈与队列</a><time datetime="2022-06-04T00:00:00.000Z" title="发表于 2022-06-04 08:00:00">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blot.github.io/2022/06/04/%E4%B8%80%EF%BC%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="1.线性表"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/blot.github.io/img/404.jpg'" alt="1.线性表"/></a><div class="content"><a class="title" href="/blot.github.io/2022/06/04/%E4%B8%80%EF%BC%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="1.线性表">1.线性表</a><time datetime="2022-06-03T23:00:00.000Z" title="发表于 2022-06-04 07:00:00">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blot.github.io/2022/06/03/acwing%E7%AE%97%E6%B3%95/" title="1.acwing基础算法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/blot.github.io/img/404.jpg'" alt="1.acwing基础算法"/></a><div class="content"><a class="title" href="/blot.github.io/2022/06/03/acwing%E7%AE%97%E6%B3%95/" title="1.acwing基础算法">1.acwing基础算法</a><time datetime="2022-06-03T13:14:00.000Z" title="发表于 2022-06-03 21:14:00">2022-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blot.github.io/2022/06/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="2.搜索与图论"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/blot.github.io/img/404.jpg'" alt="2.搜索与图论"/></a><div class="content"><a class="title" href="/blot.github.io/2022/06/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="2.搜索与图论">2.搜索与图论</a><time datetime="2022-06-03T13:14:00.000Z" title="发表于 2022-06-03 21:14:00">2022-06-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/blot.github.io/js/utils.js"></script><script src="/blot.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/blot.github.io/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/MetingJS/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>