<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见程序计算——C语言</title>
    <url>/blot.github.io/2022/03/03/101%E5%B8%B8%E8%A7%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="常见程序计算"><a href="#常见程序计算" class="headerlink" title="常见程序计算"></a>常见程序计算</h1><h2 id="输出逆序数"><a href="#输出逆序数" class="headerlink" title="输出逆序数"></a>输出逆序数</h2><p><strong>题目内容：</strong></p>
<p>从键盘任意输入一个<strong>3位整数</strong>，编程计算并输出它的<strong>逆序数</strong>（<strong>忽略</strong>整数前的<strong>正负号</strong>）。例如，输入-123，则忽略负号，由123分离出其百位1、十位2、个位3，然后计算3<em>100+2</em>10+1 = 321，并输出321。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,a,y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	a = <span class="built_in">fabs</span>(x);</span><br><span class="line">	y = a%<span class="number">10</span>*<span class="number">100</span>+a/<span class="number">10</span>%<span class="number">10</span>*<span class="number">10</span>+a/<span class="number">100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大写英文字母转换成小写英文字母"><a href="#大写英文字母转换成小写英文字母" class="headerlink" title="大写英文字母转换成小写英文字母"></a>大写英文字母转换成小写英文字母</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入字符\n&quot;</span>);</span><br><span class="line">	ch = getchar();</span><br><span class="line">	ch = ch+<span class="number">32</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(ch);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//执行结果是将光标执行到下一行的起始位置处</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;作为判断\n&quot;</span>);<span class="comment">//可删去上一行代码作为判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拆分英文名"><a href="#拆分英文名" class="headerlink" title="拆分英文名"></a>拆分英文名</h2><p>从键盘输入某同学的英文名（<strong>小写</strong>输入，假设学生的英文名只包含<strong>3个</strong>字母。如: tom），编写程序在屏幕上输出该同学的英文名，且<strong>首字母大写</strong>（如: Tom）。同时输出组成该英文名的所有英文字符<strong>在26个英文字母中的序号</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name1,name2,name3;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input your English name:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c%c%c&quot;</span>,&amp;name1,&amp;name2,&amp;name3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c%c%c\n&quot;</span>,(name1<span class="number">-32</span>),name2,name3 );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c:%d\n&quot;</span>,name1,name1<span class="number">-96</span> );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c:%d\n&quot;</span>,name2,name2<span class="number">-96</span> );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c:%d\n&quot;</span>,name3,name3<span class="number">-96</span> );<span class="comment">//根据ASCII码值判断序号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch应用成绩等级"><a href="#switch应用成绩等级" class="headerlink" title="switch应用成绩等级"></a>switch应用成绩等级</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score,mark;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please input score:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;score);</span><br><span class="line">	mark = score&gt;=<span class="number">0</span>&amp;&amp;score&lt;=<span class="number">100</span> ? score/<span class="number">10</span> : <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">switch</span>(mark)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;grade:E\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;grade:D\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;grade:C\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;gradeB\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;grade:A\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Iput error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检测用户输入错误"><a href="#检测用户输入错误" class="headerlink" title="检测用户输入错误"></a>检测用户输入错误</h2><p>根据scanf()的返回值判断scanf()是否成功读入了指定的数据项数，使程序在用户输入123a时，能输出如下运行结果：</p>
<p>123a↙</p>
<p>Input error!</p>
<p>如果成功读入指定的数据项数，输出格式为：”a = %d, b = %d\n” （注意：等号的两边各有一个空格）</p>
<p>输入非法数据，输出格式为：”Input error!”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	c = <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<span class="comment">//scanf的返回值是参数被成功赋值的个数</span></span><br><span class="line">	<span class="keyword">if</span>(c == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>,a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Input error!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闰年判断"><a href="#闰年判断" class="headerlink" title="闰年判断"></a>闰年判断</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> year,c;</span><br><span class="line">	c = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;year);<span class="comment">//输入格式正确，返回数值1;遇到非法数字则是返回0</span></span><br><span class="line">	<span class="keyword">if</span>(c==<span class="number">0</span> || year&lt;<span class="number">0</span>)<span class="comment">//判断year小于0和非法数值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Input error!&quot;</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		(year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp;  year%<span class="number">100</span>!=<span class="number">0</span>) || year%<span class="number">400</span>==<span class="number">0</span> ? <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符类型判断"><a href="#字符类型判断" class="headerlink" title="字符类型判断"></a>字符类型判断</h2><p>从键盘键入任意一个字符，判断该字符是英文字母（不区分大、小写）、数字字符还是其它字符。</p>
<p>若键入字母，则屏幕显示 It is an English character.；若键入数字则屏幕显示It is a digit character. ；若输入其它字符，则屏幕显示：It is other character. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input simple:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;<span class="number">47</span> &amp;&amp; a&lt;<span class="number">58</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;It is a digit character.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((a&gt;<span class="number">64</span> &amp;&amp; a&lt;<span class="number">91</span>) ||  (a&gt;<span class="number">97</span> &amp;&amp; a&lt;<span class="number">123</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;It is an English character.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;It is other character.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不管是字符、数字、还是非法数值都有对应的ASCII码值，可以通过ASCII码值来判断是哪种类型</p>
<h2 id="快递费运算"><a href="#快递费运算" class="headerlink" title="快递费运算"></a>快递费运算</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> area;</span><br><span class="line">  <span class="type">float</span> wei,fir,sec;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%f&quot;</span>,&amp;area,&amp;wei);</span><br><span class="line">  sec=(<span class="type">int</span>)<span class="built_in">ceil</span>(wei)<span class="number">-1</span>;<span class="comment">//ceil为向上取整函数</span></span><br><span class="line">  <span class="keyword">if</span>(area&gt;<span class="number">4</span> || area&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error in Area\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(area==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Price: %5.2f\n&quot;</span>,<span class="number">10</span>+<span class="number">3</span>*sec);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(area==<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Price: %5.2f\n&quot;</span>,<span class="number">10</span>+<span class="number">4</span>*sec);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(area==<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Price: %5.2f\n&quot;</span>,<span class="number">15</span>+<span class="number">5</span>*sec);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(area==<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Price: %5.2f\n&quot;</span>,<span class="number">15</span>+<span class="number">6.5</span>*sec);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(area==<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Price: %5.2f\n&quot;</span>,<span class="number">15</span>+<span class="number">10</span>*sec);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="猜数游戏（直到猜对为止）"><a href="#猜数游戏（直到猜对为止）" class="headerlink" title="猜数游戏（直到猜对为止）"></a>猜数游戏（直到猜对为止）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> guess;</span><br><span class="line">	<span class="type">int</span> magic,counter;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	magic = rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please guess a magic number:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;guess);</span><br><span class="line">		counter++;</span><br><span class="line">		<span class="keyword">if</span>(guess&gt;magic)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Wrong!,Too big\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(guess&lt;magic)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Wrong!,Too small\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;right\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(guess != magic);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;counter = %d\n&quot;</span>,counter );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="直到输入为整数"><a href="#直到输入为整数" class="headerlink" title="直到输入为整数"></a>直到输入为整数</h2><p><strong>题目内容：</strong></p>
<p>从键盘任意输入两个符号各异的整数，直到输入的两个整数满足要求为止，然后打印这两个数。请通过测试找出下面这个程序存在的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x1, x2, k;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag &amp;&amp; getchar() != <span class="string">&#x27;\n&#x27;</span>);<span class="comment">//flag表示开始为0，后面为1，通过是否读到回车符，表示循环读入字符，直到读到回车符结束循环</span></span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input x1, x2:\n&quot;</span>);</span><br><span class="line">        k = <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;x1, &amp;x2);   </span><br><span class="line">    &#125; <span class="keyword">while</span> (k!=<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x1=%d,x2=%d\n&quot;</span>, x1, x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个程序接收用户输入的两个整数并打印</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> ch; <span class="comment">// 定义一个整型变量接收非法输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个正整数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != EOF &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>); <span class="comment">//空循环，读取输入流内的剩余内容，若输出12a,3可以消除a;EOF是个宏，在stdil.h中定义，值为 -1，也称结束标志;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//while（getchar（）！=&#x27;/n&#x27;）表示循环读入字符，直到读到回车符结束循环</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ch;			<span class="comment">/*字符型就是小整型数，用int定义防止将输入字符意外定义成EOF（整型），还保证了ch空间足够大*/</span> </span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) != EOF &amp;&amp; ch !=<span class="string">&#x27;\n&#x27;</span>)	;		<span class="comment">/*读取字符为空或换行符时结束循环*/</span></span><br></pre></td></tr></table></figure>
<h2 id="6位密码输入检测"><a href="#6位密码输入检测" class="headerlink" title="6位密码输入检测"></a>6位密码输入检测</h2><p><strong>题目内容：</strong></p>
<p>从键盘输入<strong>6位**</strong>仅<strong>由</strong>数字0~9**组成的密码。用户每输入一个密码并按回车键后，程序给出判断：如果是数字，则原样输出该数字，并提示用户目前已经输入了几位密码，同时继续输入下一位密码；否则，程序提示”error”，并让用户继续输入下一位密码。直到用户输入的密码全部是数字为止。</p>
<p>Input your password:</p>
<p>1↙</p>
<p>1, you have enter 1-bits number</p>
<p>6↙</p>
<p>6, you have enter 2-bits number</p>
<p>d↙</p>
<p>error</p>
<p>4↙</p>
<p>4, you have enter 3-bits number</p>
<p>6↙</p>
<p>6, you have enter 4-bits number</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c: ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Input your password:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;ch);</span><br><span class="line">		<span class="keyword">if</span>(ch&gt;<span class="number">47</span> &amp;&amp; ch&lt;<span class="number">58</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c, you have enter %d-bits number\n&quot;</span>,ch,i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测输入数据中奇数和偶数的个数"><a href="#测输入数据中奇数和偶数的个数" class="headerlink" title="测输入数据中奇数和偶数的个数"></a>测输入数据中奇数和偶数的个数</h2><p><strong>题目内容：</strong></p>
<p>从键盘输入一系列<strong>正整数</strong>，输入<strong>-1</strong>表示输入结束（-1本身不是输入的数据）。编写程序判断输入数据中<strong>奇数</strong>和<strong>偶数</strong>的<strong>个数</strong>。如果用户输入的第一个数据就是-1，则程序输出”over!”。否则。用户每输入一个数据，输出该数据是奇数还是偶数，直到用户输入-1为止，分别统计用户输入数据中奇数和偶数的个数。</p>
<p>用户输入的第一个数据就是-1，输出格式：”over!\n”</p>
<p>奇数的输出格式：”%d:odd\n”</p>
<p>偶数的输出格式：”%d:even\n”</p>
<p>输入数据中奇数的个数统计：”The total number of odd is %d\n”</p>
<p>输入数据中偶数的个数统计：”The total number of even is %d\n”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> num,i,j;</span><br><span class="line">	i=<span class="number">0</span>;<span class="comment">//偶数计数</span></span><br><span class="line">	j=<span class="number">0</span>;<span class="comment">//奇数计数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter the number:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">		<span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d:even\n&quot;</span>,num);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;over!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> END;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d:odd\n&quot;</span>,num);</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	END:;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The total number of odd is %d\n&quot;</span>, j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The total number of even is %d\n&quot;</span>,i );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算组合数"><a href="#计算组合数" class="headerlink" title="计算组合数"></a>计算组合数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">Comb</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> k)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m,k;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Iput m,k(m&gt;=k&gt;0):\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">	&#125;<span class="keyword">while</span>(m&lt;k || m&lt;<span class="number">0</span> || k&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,Comb(m,k) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">Comb</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> k)</span><span class="comment">//计算组合数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Fact(m)/(Fact(k)*Fact(m-k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//计算阶乘</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		result *= i; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算三位最大公约数"><a href="#计算三位最大公约数" class="headerlink" title="计算三位最大公约数"></a>计算三位最大公约数</h2><p>从键盘任意输入一个数n（1000&lt;=n&lt;=1000000），编程计算并输出n的所有约数中最大的三位数（即最大的三位约数）。如果n小于1000或者大于1000000，则输出“Input error!”。</p>
<p>函数原型：int Func(int n)；</p>
<p>函数功能：计算n的所有约数中最大的三位数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Func</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input n:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">1000</span> &amp;&amp; n&lt;=<span class="number">1000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Func(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Input error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Func</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//计算最大公约数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	i = <span class="number">999</span>;</span><br><span class="line">	<span class="keyword">while</span>(n%i != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	result = i;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分数化为最简"><a href="#分数化为最简" class="headerlink" title="分数化为最简"></a>分数化为最简</h2><p>分数化简要化简到最简形式，比如12/20可以化简成6/10和3/5，但3/5是最简形式；100/8可以化简成 50 /4和 25 /2 , 而25/2 为最简形式。为了降低难度，不要求将假分数（如7/2）化简成带分数（3 ）形式。请编程帮助孔融将任意一个分数化简成最简形式。先从键盘输入两个整数m和n(1&lt;=m,n&lt;=10000) ，其中m表示分子，n表示分母。然后输出分数化简后的最简形式。</p>
<p>函数原型：int Gcd(int a, int b);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">God</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m,n;<span class="comment">//m为分子，n为分母</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input m,n:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&gt;<span class="number">10000</span> || n&lt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Input error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>,m/God(m,n),n/God(m,n) );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">God</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//计算2个数的公共部分</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> (b!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a%b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;<span class="comment">//换数，始终a&gt;b&gt;c，直到c为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算阶乘"><a href="#计算阶乘" class="headerlink" title="计算阶乘"></a>计算阶乘</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">unsigned long Fact(unsigned <span class="built_in">int</span> n);</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned <span class="built_in">int</span> n;</span><br><span class="line">	printf(<span class="string">&quot;输入n\n&quot;</span>);</span><br><span class="line">	scanf(<span class="string">&quot;%u&quot;</span>,&amp;n);</span><br><span class="line">	printf(<span class="string">&quot;%u的阶乘为%u&quot;</span>,n,Fact(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned long Fact(unsigned <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n*Fact(n-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算Fibonacci数列第n项"><a href="#计算Fibonacci数列第n项" class="headerlink" title="计算Fibonacci数列第n项"></a>计算Fibonacci数列第n项</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;第%d项的Fibonacci为%ld&quot;</span>,n,Fib(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> f;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">		f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		f=Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入月分拥有天数"><a href="#输入月分拥有天数" class="headerlink" title="输入月分拥有天数"></a>输入月分拥有天数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> days[<span class="number">2</span>][MONTHS] = &#123;&#123;<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;,</span><br><span class="line">						   &#123;<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line">	<span class="type">int</span> year,month;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Input year,month\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;year,&amp;month);</span><br><span class="line">	&#125;<span class="keyword">while</span>(month&lt;<span class="number">1</span> || month&gt;<span class="number">12</span>);<span class="comment">//处理非法输入</span></span><br><span class="line">	<span class="keyword">if</span>(((year%<span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year%<span class="number">100</span> != <span class="number">0</span>)) || (year%<span class="number">400</span> == <span class="number">0</span>))<span class="comment">//判断闰年</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The number of days is %d\n&quot;</span>,days[<span class="number">1</span>][month<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The number of days is %d\n&quot;</span>,days[<span class="number">0</span>][month<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="计算n位同学的平均分"><a href="#计算n位同学的平均分" class="headerlink" title="计算n位同学的平均分"></a>计算n位同学的平均分</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadScore</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score[N],aver,n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input n:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	ReadScore(score,n);</span><br><span class="line">	aver = Average(score,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Average score is %d\n&quot;</span>,aver);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadScore</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//输入n位学生成绩</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input score:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;score[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//计算平均分</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += score[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="n层嵌套平方根的计算"><a href="#n层嵌套平方根的计算" class="headerlink" title="n层嵌套平方根的计算"></a>n层嵌套平方根的计算</h2><p><img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20210831224407427.png" alt="image-20210831224407427"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">Y</span><span class="params">(<span class="type">double</span> x,<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">double</span> x,Z;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please input x and n:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf,%d&quot;</span>,&amp;x,&amp;n);</span><br><span class="line">	Z=Y(x,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Result=%.2f\n&quot;</span>,Z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Y</span><span class="params">(<span class="type">double</span> x,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">sqrt</span>(x+Y(x,n<span class="number">-1</span>)));<span class="comment">//通过递归n-1来直接递归</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摘苹果"><a href="#摘苹果" class="headerlink" title="摘苹果"></a>摘苹果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="built_in">int</span> GetApple(<span class="built_in">int</span> a[], <span class="built_in">int</span> height, <span class="built_in">int</span> n);</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> a[<span class="number">100</span>],height,n,b;</span><br><span class="line">	n=<span class="number">0</span>;</span><br><span class="line">	printf(<span class="string">&quot;请输入已知十个苹果高度：\n&quot;</span> );</span><br><span class="line">	<span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;<span class="number">10</span>;b++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(<span class="string">&quot;%d&quot;</span>,&amp;a[b]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot;涛涛伸手最大高度：&quot;</span>);</span><br><span class="line">	scanf(<span class="string">&quot;%d&quot;</span>,&amp;height);</span><br><span class="line">	printf(<span class="string">&quot;涛涛能抓到的苹果树：%d&quot;</span>,GetApple(a,height,n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> GetApple(<span class="built_in">int</span> a[], <span class="built_in">int</span> height, <span class="built_in">int</span> n)//返回能抓到多少个苹果</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> b;</span><br><span class="line">	<span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;<span class="number">10</span>;b++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(height+<span class="number">30</span> &gt;= a[b])//与苹果高度的判断</span><br><span class="line">		&#123;</span><br><span class="line">			n++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛选法求100以内的所有素数"><a href="#筛选法求100以内的所有素数" class="headerlink" title="筛选法求100以内的所有素数"></a>筛选法求100以内的所有素数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintPrime</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SiftPrime</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[N+<span class="number">1</span>];</span><br><span class="line">    SiftPrime(a,N);</span><br><span class="line">    PrintPrime(a,N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintPrime</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span><span class="comment">//输出素数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SiftPrime</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span><span class="comment">//筛选出数的倍数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=N;i++)<span class="comment">//赋值给数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(N);i++)<span class="comment">//快速判断是否有素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=<span class="number">0</span> &amp;&amp; a[j]!=<span class="number">0</span> &amp;&amp; a[j]%a[i]==<span class="number">0</span>)<span class="comment">//若a[j]是a[i]的倍数，筛掉a[j]</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形数组"><a href="#矩形数组" class="headerlink" title="矩形数组"></a>矩形数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,m,n,len,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入行，列：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//按行赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//按列赋值</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j]=sum;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="函数求值"><a href="#函数求值" class="headerlink" title="函数求值"></a>函数求值</h2><p><img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20210906182458639.png" alt="image-20210906182458639"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">G</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,a;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">100</span>];</span><br><span class="line">    <span class="type">long</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入测试次数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        num[i]=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;a;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, F(n,num[j]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">G</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//求出最大的奇因数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = n;</span><br><span class="line">    <span class="keyword">while</span>(n%i != <span class="number">0</span> || i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b)</span><span class="comment">//F(n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum+G(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>1.python基础1</title>
    <url>/blot.github.io/2022/04/03/1%20%E3%80%81python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一-、python基础"><a href="#一-、python基础" class="headerlink" title="一 、python基础"></a>一 、python基础</h1><h1 id="输入print-函数"><a href="#输入print-函数" class="headerlink" title="输入print()函数"></a>输入print()函数</h1><h2 id="输出几种形式"><a href="#输出几种形式" class="headerlink" title="输出几种形式"></a>输出几种形式</h2><h3 id="不带引号"><a href="#不带引号" class="headerlink" title="不带引号"></a>不带引号</h3><ul>
<li>让计算机读懂括号⾥的内容，打印最终的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><ul>
<li>计算机⽆须理解，原样复述引号中的内容 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;秋水共长天一色&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><ul>
<li>作⽤和单引号⼀样；当打印内容中有单引号时，可以使⽤双引号</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Let&#x27;s go&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Let\&#x27;s go&#x27;</span>) <span class="comment">#也可以使用转义字符+单引号(\&#x27;)来实现单引号</span></span><br></pre></td></tr></table></figure>
<h3 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h3><ul>
<li>带三引号，实现换⾏</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;python小课</span></span><br><span class="line"><span class="string">最好的python课程&#x27;&#x27;&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python小课\n最好的python课程&quot;</span>)<span class="comment">#采用转义字符&quot;\n&quot;也可以换行</span></span><br></pre></td></tr></table></figure>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格，将当前位置前移一项</td>
</tr>
<tr>
<td>\f</td>
<td>换页，将当前位置移到下页开头</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车，将当前位danyihao置移到本行开头</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表</td>
</tr>
<tr>
<td>\\\</td>
<td>代表一个斜线字符“\”</td>
</tr>
<tr>
<td>\0</td>
<td>空字符</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制所代表的任意字符</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
</tr>
</tbody>
</table>
</div>
<h2 id="print-不换行"><a href="#print-不换行" class="headerlink" title="print()不换行"></a>print()不换行</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>,end=<span class="string">&#x27;!&#x27;</span>)<span class="comment">#end实现不换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="print-完整参数"><a href="#print-完整参数" class="headerlink" title="print()完整参数"></a>print()完整参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(*objects, sep = <span class="string">&#x27; &#x27;</span>, end = <span class="string">&#x27;\n&#x27;</span>, file = sys.stdout, flush = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;金枪鱼&#x27;</span>, <span class="string">&#x27;三文鱼&#x27;</span>, <span class="string">&#x27;鲷鱼&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;金枪鱼&#x27;</span>, <span class="string">&#x27;三文鱼&#x27;</span>, <span class="string">&#x27;鲷鱼&#x27;</span>, sep = <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"><span class="comment"># sep控制多个值之间的分隔符，默认是空格</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;金枪鱼&#x27;</span>, <span class="string">&#x27;三文鱼&#x27;</span>, <span class="string">&#x27;鲷鱼&#x27;</span>, sep = <span class="string">&#x27;+&#x27;</span>, end = <span class="string">&#x27;=?&#x27;</span>)</span><br><span class="line"><span class="comment"># end控制打印结果的结尾，默认是换行)</span></span><br></pre></td></tr></table></figure>
<h1 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">变量名=<span class="string">&#x27;内容&#x27;</span></span><br><span class="line">name=<span class="string">&#x27;小千&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li>只能是一个词</li>
<li>只能包含数字、数字、下划线</li>
<li>不能以数字开头</li>
</ol>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248307.png" alt="image-20210808213821074"></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>常见：字符串，整数型，浮点数，列表，字典，布尔值，元组</li>
</ul>
<ol>
<li>字符串str:⽤括号括起来的⽂本（如：’python’、’123’、’⻛变编程’）</li>
<li>整数int：不带⼩数点的数字（如：-1、1、0、520、1314） </li>
<li>浮点数float：带⼩数点的数字，运算结果存在误差（如：-0.15、3.1415、1.0) </li>
<li>列表list:标识是中括号[]</li>
<li><p>元组tuple:与列表类似，不能修改，标识（）</p>
<ul>
<li>元组和列表一样，可以通过索引来提取当中的某个元素</li>
</ul>
</li>
<li><p>字典dict:标识大括号{}</p>
</li>
<li>布尔值bool：表示真假的数据类型，只有True和False</li>
</ol>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248095.png" alt="image-20210808214239056"></p>
<h2 id="数据的拼接"><a href="#数据的拼接" class="headerlink" title="数据的拼接"></a>数据的拼接</h2><h3 id="用“-”号将数据进行拼接"><a href="#用“-”号将数据进行拼接" class="headerlink" title="用“+”号将数据进行拼接"></a>用“+”号将数据进行拼接</h3><ul>
<li>目的：数据整合</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hero = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">organization = <span class="string">&#x27;风变编程&#x27;</span></span><br><span class="line">identity = <span class="string">&#x27;学员&#x27;</span></span><br><span class="line">action = <span class="string">&#x27;是&#x27;</span></span><br><span class="line">ID = <span class="string">&#x27;007&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(hero+action+organization+identity+ID)</span><br></pre></td></tr></table></figure>
<h3 id="格式符"><a href="#格式符" class="headerlink" title="格式符%"></a>格式符%</h3><div class="table-container">
<table>
<thead>
<tr>
<th>格式符+类型码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%s</td>
<td>字符串显示</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数显示</td>
</tr>
<tr>
<td>%d</td>
<td>整数显示</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lucky = <span class="number">8</span></span><br><span class="line">n=<span class="string">&#x27;我的&#x27;</span></span><br><span class="line">year=<span class="number">21</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的幸运数字是%d&#x27;</span> % <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的幸运数字是%s&#x27;</span> % <span class="string">&#x27;小龙女的生日816&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s年龄是%s&#x27;</span> % (n,year))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s年龄是%d&#x27;</span> % (n,year))</span><br></pre></td></tr></table></figure>
<p>%<code>后面的类型码用什么，取决于你希望这个</code>%<code>占住的这个位置的数据以什么类型展示出来，如果你希望它以字符串形式展示，那就写</code>%s<code>，如果你希望它以整数形式展示，那就写</code>%d</p>
<h3 id="format函数"><a href="#format函数" class="headerlink" title="format函数"></a>format函数</h3><p>format()函数用来占位的是大括号{}，不用区分类型码（%+类型码）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">player_life=<span class="number">742</span></span><br><span class="line">player_attack=<span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;【玩家】\n血量：&#123;&#125;\n攻击：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(player_life,player_attack))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am learning %s&#x27;</span>% name1)  <span class="comment"># 注：当只跟一个数据时，%后可不加括号，format()一定要有。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># format()格式化函数：str.format()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;数字：&#x27;</span>,<span class="number">0</span>))  <span class="comment"># 优势1：不用担心用错类型码。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;，&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0</span>,<span class="number">1</span>))  <span class="comment"># 不设置指定位置时，默认按顺序对应。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;1&#125;，&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0</span>,<span class="number">1</span>))  <span class="comment"># 优势2：当设置指定位置时，按指定的对应。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;，&#123;1&#125;，&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0</span>,<span class="number">1</span>))  <span class="comment"># 优势3：可多次调用format后的数据。</span></span><br><span class="line"></span><br><span class="line">name2 =  <span class="string">&#x27;Python基础语法&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我正在学&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name2))  <span class="comment"># format()函数也接受通过参数传入数据。</span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型查询type-函数"><a href="#数据类型查询type-函数" class="headerlink" title="数据类型查询type()函数"></a>数据类型查询type()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">who = <span class="string">&#x27;我的&#x27;</span></span><br><span class="line">print(type(who))</span><br></pre></td></tr></table></figure>
<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><ol>
<li>str():将其他类型转换成字符串</li>
<li>int():将其他数据类型转换成整数</li>
<li>float():将其他数据类型转换成浮点数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic = <span class="string">&#x27;水仙花数&#x27;</span></span><br><span class="line">action = <span class="string">&#x27;是&#x27;</span></span><br><span class="line">unit = <span class="string">&#x27;个&#x27;</span></span><br><span class="line">expression = <span class="string">&#x27;＝1x1x1+5x5x5+3x3x3&#x27;</span></span><br><span class="line">number = <span class="number">153</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(number)+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(expression)+action+unit+magic)</span><br></pre></td></tr></table></figure>
<ul>
<li>文字类和小数类字符串无法转换成整数</li>
<li>文字类字符串无法转换成浮点数</li>
</ul>
<h3 id="解决字符串数字排序问题"><a href="#解决字符串数字排序问题" class="headerlink" title="解决字符串数字排序问题"></a><strong>解决字符串数字排序问题</strong></h3><ul>
<li>使用匿名函数，第一个参数用来排序字符串，第二个参数用来排序数字。数字排序必须转成int或者其他数字格式，不然字符串10还是排在2前面。</li>
<li>参数1和参数2根据实际判断，若是对数字排序则需要int强制转换</li>
<li>参数是对数组中字符串的长度进行截取排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#arrRes.sort(key=lambda arr: (arr[:2], int(arr[2:])))</span></span><br><span class="line">arrRes = [<span class="string">&#x27;学生2&#x27;</span>, <span class="string">&#x27;学生1&#x27;</span>, <span class="string">&#x27;学生10&#x27;</span>, <span class="string">&#x27;学生4&#x27;</span>, <span class="string">&#x27;学生3&#x27;</span>]</span><br><span class="line">arrRes.sort(key=<span class="keyword">lambda</span> arr: (arr[:<span class="number">2</span>], <span class="built_in">int</span>(arr[<span class="number">2</span>:])))</span><br><span class="line"><span class="built_in">print</span>(arrRes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path=<span class="string">&#x27;./data/jm/&#x27;</span>  <span class="comment">#返回当前进程的工作目录</span></span><br><span class="line">path_list=os.listdir(path)</span><br><span class="line">path_list.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x[:-<span class="number">4</span>])) <span class="comment">#将‘.jpg’左边的字符转换成整数型进行排序</span></span><br><span class="line"><span class="built_in">print</span>(path_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h2 id="单行判断if"><a href="#单行判断if" class="headerlink" title="单行判断if"></a>单行判断if</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:<span class="comment">#if后面要加冒号，同时执行语句要缩进四个空格</span></span><br><span class="line">	执行语句</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stonenumber=<span class="number">6</span></span><br><span class="line"><span class="keyword">if</span> stonenumber&gt;=<span class="number">6</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;你拥有了毁灭宇宙的力量&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="双向判断if-else"><a href="#双向判断if-else" class="headerlink" title="双向判断if-else"></a>双向判断if-else</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">	执行语句<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	执行语句<span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weight=<span class="number">60</span></span><br><span class="line"><span class="keyword">if</span> weight&gt;=<span class="number">100</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;不吃了&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;放心吃吧&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="多向判断if—elif—else"><a href="#多向判断if—elif—else" class="headerlink" title="多向判断if—elif—else"></a>多向判断if—elif—else</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">	执行语句<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">	执行语句<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	执行语句<span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stonenumber=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> stonenumber&gt;=<span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你拥有了毁灭宇宙的力量&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">0</span>&lt;stonenumber&lt;=<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;绯红女巫需要亲手毁掉幻视额头上的心灵宝石&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;需要惊奇队长逆转未来&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="if嵌套"><a href="#if嵌套" class="headerlink" title="if嵌套"></a>if嵌套</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">historyscore=<span class="number">26</span></span><br><span class="line"><span class="keyword">if</span> historyscore&gt;=<span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你已经及格&#x27;</span>)  </span><br><span class="line">    <span class="keyword">if</span> historyscore&gt;=<span class="number">80</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你很优秀&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你只是一般般&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;程序结束&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="输入input-函数"><a href="#输入input-函数" class="headerlink" title="输入input()函数"></a>输入input()函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请在以下四个选项【格兰芬多；斯莱特林；拉文克劳；赫奇帕奇】中，输入你想去的学院名字: &#x27;</span>)<span class="comment">#name为字符串型</span></span><br><span class="line"><span class="built_in">print</span>(name +<span class="string">&#x27;学院欢迎你，小萌新!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>input函数的结果必须赋值</li>
<li>input()的数据类型是字符串，其他类型转成字符串</li>
</ul>
<p>强制转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">choice = <span class="type">int</span>(input(<span class="string">&#x27;请输入您的选择：&#x27;</span>))<span class="meta">#choice强制转换成整型</span></span><br><span class="line"><span class="keyword">if</span> choice == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">&#x27;霍格沃茨欢迎您的到来&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;您可是被梅林选中的孩子，我们不接受这个选项&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>Tab键和空格键不能同时混用。</li>
</ul>
]]></content>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常见函数——C语言</title>
    <url>/blot.github.io/2022/03/03/102%E5%B8%B8%E8%A7%81%E8%BF%90%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><h2 id="向上取整ceil-x"><a href="#向上取整ceil-x" class="headerlink" title="向上取整ceil(x)"></a>向上取整ceil(x)</h2><ul>
<li>ceil(x)返回不小于x的最小整数值（然后转换为double型）。</li>
<li>b=ceil(x);</li>
<li>程序开头要加#include<math.h></li>
</ul>
<h2 id="向下取整floor-x"><a href="#向下取整floor-x" class="headerlink" title="向下取整floor(x)"></a>向下取整floor(x)</h2><ul>
<li><p>floor(x)返回不大于x的最大整数值。</p>
</li>
<li><p>程序开头要加#include<math.h></p>
</li>
</ul>
<h2 id="四舍五入round-x"><a href="#四舍五入round-x" class="headerlink" title="四舍五入round(x)"></a>四舍五入round(x)</h2><ul>
<li><p>round(x)返回x的四舍五入整数值。</p>
</li>
<li><p>程序开头要加#include<math.h></p>
</li>
</ul>
<h2 id="随机函数rand（）"><a href="#随机函数rand（）" class="headerlink" title="随机函数rand（）"></a>随机函数rand（）</h2><ul>
<li>随机产生0到32767中一个数</li>
<li>magic = rand();</li>
<li>程序开头要加#include<stdlib.h></li>
</ul>
<p><strong>因为在程序数值一样产生数值一样，解决如下</strong></p>
<p>2.改用时间作为随机数种子更好<strong>（常用）</strong></p>
<ul>
<li>用函数time()获得系统时间</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">//用NULL作为函数参数，使其仅能从返回值取得系统时间</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rand() );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.因为在程序数值一样，要为rang()设置随机数种子，使产生的随机数“随机化”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> seed;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter seed:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>,&amp;seed);</span><br><span class="line">	srand(seed);<span class="comment">//设置随机数种子</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rand()%<span class="number">100</span>+<span class="number">1</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数srand"><a href="#函数srand" class="headerlink" title="函数srand()"></a>函数srand()</h4><p>用来设置rand()产生随机数时的随机数种子，参数seed必须是整数，通常可以用time(0)的返回值作为seed.如果每次seed都设置相同的值，rand()产生的随机数值每次都一样。</p>
<h1 id="见数学计算"><a href="#见数学计算" class="headerlink" title="见数学计算"></a>见数学计算</h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041244242.png" alt="image-20210805223345470"></p>
<p>程序开头要加#include<math.h></p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="退出循环语句函数"><a href="#退出循环语句函数" class="headerlink" title="退出循环语句函数"></a>退出循环语句函数</h2><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><ol>
<li>无条件转向语句</li>
<li>跳出多重循环</li>
<li>跳出共同的出口位置</li>
<li>不要使用过多的gotu语句标标号</li>
<li>题目：韩信点兵求至少多少兵</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(x=<span class="number">1</span>;;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">1</span> &amp;&amp; x%<span class="number">6</span>==<span class="number">5</span> &amp;&amp; x%<span class="number">7</span>==<span class="number">4</span> &amp;&amp; x%<span class="number">11</span>==<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x );</span><br><span class="line">			<span class="keyword">goto</span> END;<span class="comment">//无条件转向语句</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	END: ;<span class="comment">//标识（标识符）后面必须有语句，哪怕是空语句</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><ul>
<li>可用于跳出循环语句</li>
<li>跳出到紧接循环语句后的第一条语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(x=<span class="number">1</span>;;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">1</span> &amp;&amp; x%<span class="number">6</span>==<span class="number">5</span> &amp;&amp; x%<span class="number">7</span>==<span class="number">4</span> &amp;&amp; x%<span class="number">11</span>==<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exit（）函数"><a href="#exit（）函数" class="headerlink" title="exit（）函数"></a>exit（）函数</h3><ul>
<li><p>开头加入#include<stdlib.h></p>
</li>
<li><p>终止整个程序运行，参数为0时，表程序正常退出；非0时表示非正常退出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(x=<span class="number">1</span>;;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">1</span> &amp;&amp; x%<span class="number">6</span>==<span class="number">5</span> &amp;&amp; x%<span class="number">7</span>==<span class="number">4</span> &amp;&amp; x%<span class="number">11</span>==<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x );</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><ul>
<li>继续循环这个语句</li>
<li>但是他要跳过continue后面的语句才执行循环，直到循环截止</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please enter n:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;<span class="comment">//满足条件继续循环，换成break可对比</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>,n );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Program is over!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bullosort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>]=&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Bullosort(b,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Bullosort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                temp=a[i];</span><br><span class="line">                a[i]=a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>1.数据类型——C语言</title>
    <url>/blot.github.io/2022/03/03/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="变量定义（菜鸟教程）"><a href="#变量定义（菜鸟教程）" class="headerlink" title="变量定义（菜鸟教程）"></a>变量定义（<a href="https://www.runoob.com/cprogramming/c-tutorial.html">菜鸟教程</a>）</h2><h3 id="基本组成要素"><a href="#基本组成要素" class="headerlink" title="基本组成要素"></a>基本组成要素</h3><div class="table-container">
<table>
<thead>
<tr>
<th>自然语言</th>
<th>程序设计语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>字</td>
<td>字母，数字、标识符</td>
</tr>
<tr>
<td>词或词组</td>
<td>关键字、标识符、常量</td>
</tr>
<tr>
<td>句子或段落</td>
<td>语句</td>
</tr>
<tr>
<td>篇章</td>
<td>程序</td>
</tr>
</tbody>
</table>
</div>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>也称保留字，是C语言预先定义的、具有特殊意义的单词;例如if、long、for等</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>大小写字母，数字和下划线构成的一个字符序列</li>
<li>系统预定义标识符</li>
<li>用户自定义标识符：用来标识变量名、符号常量名、数组名、函数名等</li>
</ul>
<h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul>
<li>首字符必须是字母或下划线</li>
<li>见名知意，不要使用汉语拼音</li>
<li>不能与关键字及系统预定义的标识符相同</li>
</ul>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><ul>
<li>类型关键字      变量名；————int  a;</li>
<li>类型关键字      变量名1，变量名2….;————int  a,b…..;</li>
</ul>
<h4 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h4><ul>
<li>变量名</li>
<li>变量的值</li>
<li>变量的地址</li>
<li>变量的类型</li>
</ul>
<h2 id="变量决定什么"><a href="#变量决定什么" class="headerlink" title="变量决定什么"></a>变量决定什么</h2><h3 id="变量决定"><a href="#变量决定" class="headerlink" title="变量决定"></a>变量决定</h3><ul>
<li><p>占用内存空间的大小</p>
</li>
<li><p>数据的存储形式</p>
</li>
<li><p>合法的表数范围</p>
</li>
<li><p>可参与的运算种类</p>
</li>
</ul>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>计算变量或类型占内存的大小</p>
<p>语法形式</p>
<ul>
<li>sizeof(类型)</li>
<li>sizeof(变量或表达式)</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><ul>
<li><h4 id="define-标识符-字符串"><a href="#define-标识符-字符串" class="headerlink" title="#define 标识符  字符串"></a>#define 标识符  字符串</h4></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R   4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;area=%f\n&quot;</span>,PI*R*R );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串后不要有分号</li>
</ul>
<h3 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h3><ul>
<li>const double  标识符   =    数值；</li>
<li>const常量具有数据类型——double类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> R = <span class="number">4</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;area=%f\n&quot;</span>,PI*R*R );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1 字节</td>
<td>-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>-32,768 到 32,767</td>
</tr>
<tr>
<td>int</td>
<td>4 字节</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>long</td>
<td>4 字节</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>long long</td>
<td>8字节</td>
<td>-9223372036854775807到9223372036854775807</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>8字节</td>
<td>0到1844674407370955161</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 字节</td>
<td>0 到 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 字节</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 字节</td>
<td>0 到 65,535</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 字节</td>
<td>0 到 4,294,967,295</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>unsigned无符号</li>
<li><p>字节（Byte ）：是计算机用于计量存储容量的一种计量单位，一个字节通常8位长；一字节=8位</p>
</li>
<li><p>32位机和64位机，int类型都是占用4个字节。</p>
</li>
<li><p>16位机int类型占2个字节</p>
</li>
</ul>
<h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储大小</th>
<th style="text-align:left">值范围</th>
<th style="text-align:left">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">1.2E-38 到 3.4E+38</td>
<td style="text-align:left">6 位有效位（6-7）</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">2.3E-308 到 1.7E+308</td>
<td style="text-align:left">15 位有效位</td>
</tr>
<tr>
<td style="text-align:left">long double</td>
<td style="text-align:left">16 字节</td>
<td style="text-align:left">3.4E-4932 到 1.1E+4932</td>
<td style="text-align:left">19 位有效位</td>
</tr>
</tbody>
</table>
</div>
<h1 id="数据范围时间复杂度和空间复杂度"><a href="#数据范围时间复杂度和空间复杂度" class="headerlink" title="数据范围时间复杂度和空间复杂度"></a>数据范围时间复杂度和空间复杂度</h1><div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>数据范围</th>
<th>数量级</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned int</td>
<td>0～42 9496 7295</td>
<td>42亿 10位</td>
</tr>
<tr>
<td><code>int</code></td>
<td>-21 4748 3648～21 4748 3647</td>
<td>2*10^9^</td>
</tr>
<tr>
<td>unsigned long</td>
<td>0～42 9496 7295</td>
<td>42亿 10位</td>
</tr>
<tr>
<td>long (32位系统)</td>
<td>-21 4748 3648～21 4748 3647</td>
<td>21亿</td>
</tr>
<tr>
<td>long long的最小值</td>
<td>-922 3372 0368 5477 5808</td>
<td>19位</td>
</tr>
<tr>
<td><code>long long</code>的最大值</td>
<td>922 3372 0368 5477 5807</td>
<td>9∗10^18^</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>0～1844 6744 0737 0955 1615</td>
<td>20位</td>
</tr>
<tr>
<td>float（浮点型）</td>
<td>3.402823E^-38^~3.402823E^+38^</td>
<td>38位</td>
</tr>
<tr>
<td>double（浮点型）</td>
<td>1.79769313486232E-308 ~1.79769313486232E+308</td>
<td>308位</td>
</tr>
</tbody>
</table>
</div>
<p>计算机存储浮点数的方式：<a href="https://img-blog.csdnimg.cn/982711c7878c4aeba70777adec5b1cec.png">1</a>, <a href="https://img-blog.csdnimg.cn/0df71418c8fe4da497f7bddad84ea5d9.png">2</a></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071254887.jpg" alt=""></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071255814.jpg" alt=""></p>
<p>long long内的最大阶乘20 !<br>int内的最大阶乘12 !</p>
<p><strong>long和int的大小跟系统位数有关</strong></p>
<ul>
<li>16位系统：long是4字节，int是2字节</li>
<li>32位系统：long是4字节，int是4字节</li>
<li>64位系统：long是8字节，int是4字节</li>
</ul>
<p><strong>时间复杂度 &gt; 空间复杂度</strong></p>
<ul>
<li>申请25万大小的vector型数组大约需要1MB内存</li>
<li>具有4GB内存的电脑可以开10^9^的int型数组</li>
<li>C++ 1秒内一般能算10^7^到10^8^（比较紧）<br><a href="https://so.csdn.net/so/search?q=时间复杂度&amp;spm=1001.2101.3001.7020">时间复杂度</a>一般是10^7比较稳，有的时候能到10^8^次，但时间就会比较紧，题目如果放宽到2ms，可能可以将好能AC <a href="https://www.acwing.com/video/109/">[1] 11:44</a> <a href="https://www.acwing.com/problem/content/submission/93/">[2]</a></li>
<li>一般情况下时间复杂度比<a href="https://so.csdn.net/so/search?q=空间复杂度&amp;spm=1001.2101.3001.7020">空间复杂度</a>更加重要</li>
</ul>
<h2 id="memset常用赋值"><a href="#memset常用赋值" class="headerlink" title="memset常用赋值"></a>memset常用赋值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">头文件 &lt;cstring&gt;`</span><br><span class="line">`memset(f, 0, sizeof(f));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>0</p>
</li>
<li><p>-1</p>
</li>
<li><p>0x3f（正无穷 1,061,109,567）</p>
</li>
<li><p>-0x3f（负无穷 -1,044,266,559）但不等于 -0x3f3f3f3f（坑点）</p>
</li>
</ul>
<h1 id="其他小常识"><a href="#其他小常识" class="headerlink" title="其他小常识"></a>其他小常识</h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071302821.png" alt="image-20220507130220424"></p>
<h1 id="∇-nabla∇-互联网笔试题通常的限制"><a href="#∇-nabla∇-互联网笔试题通常的限制" class="headerlink" title="∇ \nabla∇ 互联网笔试题通常的限制"></a>∇ \nabla∇ 互联网笔试题通常的限制</h1><p><img src="https://img-blog.csdnimg.cn/20191011190557639.png" alt="img"></p>
<ul>
<li><strong>时间限制1秒</strong>：说明时间复杂度一个在1 0 7 10^7107左右</li>
<li><strong>空间限制32768K = 32 MB</strong>：说明可以申请800万左右的vector型数组<br>注意：上面说的是vector型数组，如果是普通数组int array[N]，基本上可以开到很大很大，因为vector是动态开数组，<code>STL容器一般都是比较花时间的，所以能用数组模拟尽量用数组</code></li>
</ul>
]]></content>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2.python基础进阶</title>
    <url>/blot.github.io/2022/04/03/2%E3%80%81%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="2、基础进阶"><a href="#2、基础进阶" class="headerlink" title="2、基础进阶"></a>2、基础进阶</h1><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表名=[数据<span class="number">1</span>，数据<span class="number">2</span>,..,数据n]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;小明&#x27;</span>,<span class="number">18</span>,<span class="number">1.70</span>]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="求元素下标"><a href="#求元素下标" class="headerlink" title="求元素下标"></a>求元素下标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1.index(&#x27;小明&#x27;)#求元素下标</span><br></pre></td></tr></table></figure>
<h2 id="列表提取单个元素"><a href="#列表提取单个元素" class="headerlink" title="列表提取单个元素"></a>列表提取单个元素</h2><ul>
<li>偏移量：对列表元素的位置编号。 </li>
<li>列表的偏移量从0开始计算（从左到右）</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h4 id="列表名-索引"><a href="#列表名-索引" class="headerlink" title="列表名[索引]"></a>列表名[索引]</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>]<span class="comment">#小明，小红，小刚的偏移量分别是0，1，2</span></span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">2</span>])  </span><br></pre></td></tr></table></figure>
<h2 id="提取多个元素"><a href="#提取多个元素" class="headerlink" title="提取多个元素"></a>提取多个元素</h2><h3 id="用冒号切片"><a href="#用冒号切片" class="headerlink" title="用冒号切片"></a>用冒号切片</h3><p>冒号：左右空，取到头；<strong>左取右不取</strong></p>
<h4 id="列表名-a-b"><a href="#列表名-a-b" class="headerlink" title="列表名[a:b]"></a>列表名[a:b]</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(list2[:])<span class="comment"># 打印出[5,6,7,8,9]</span></span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">2</span>:])<span class="comment"># 打印出[7,8,9]</span></span><br><span class="line"><span class="built_in">print</span>(list2[:<span class="number">2</span>])<span class="comment"># 打印出[5,6]</span></span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">1</span>:<span class="number">3</span>])<span class="comment">#打印出[6,7]</span></span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">2</span>:<span class="number">4</span>])<span class="comment">#打印出[7,8]</span></span><br></pre></td></tr></table></figure>
<h2 id="给列表添加或删除元素"><a href="#给列表添加或删除元素" class="headerlink" title="给列表添加或删除元素"></a>给列表添加或删除元素</h2><h3 id="添加格式"><a href="#添加格式" class="headerlink" title="添加格式"></a>添加格式</h3><h4 id="列表名-append-内容"><a href="#列表名-append-内容" class="headerlink" title="列表名.append(内容 )"></a>列表名.append(内容 )</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>]</span><br><span class="line">students.append(<span class="string">&#x27;小美&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(students)<span class="comment">#[&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;小刚&#x27;, &#x27;小美&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="删除格式"><a href="#删除格式" class="headerlink" title="删除格式"></a>删除格式</h3><h4 id="del-列表名-元素的索引"><a href="#del-列表名-元素的索引" class="headerlink" title="del 列表名[元素的索引]"></a>del 列表名[元素的索引]</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> students[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(students)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对中间段删除</span></span><br><span class="line">a=<span class="string">&#x27;1234567890&#x27;</span></span><br><span class="line">b=<span class="built_in">list</span>(a)<span class="comment">#转为list</span></span><br><span class="line"><span class="keyword">del</span> b[<span class="number">3</span>:<span class="number">5</span>]<span class="comment">#删除3,4,5  左取右不取</span></span><br></pre></td></tr></table></figure>
<h4 id="pop（）函数"><a href="#pop（）函数" class="headerlink" title="pop（）函数"></a>pop（）函数</h4><ul>
<li>list1.pop():默认删除最后一个元素，并返回该元素的值。</li>
<li>list1.pop(0):也可指定删除某个元素，并返回该元素的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n移除（pop）又取又删：&#x27;</span>)</span><br><span class="line">list1 = [<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(list1.pop())  <span class="comment"># 默认删除最后一个元素，并返回该元素的值。</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(list1.pop(<span class="number">0</span>))  <span class="comment"># 也可指定删除某个元素，并返回该元素的值。</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>
<h2 id="列表指定插入"><a href="#列表指定插入" class="headerlink" title="列表指定插入"></a><strong>列表指定插入</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aList = [123, &#x27;xyz&#x27;, &#x27;zara&#x27;, &#x27;abc&#x27;]</span><br><span class="line"> </span><br><span class="line">aList.insert( 3, 2009)#下标为3的位置插入2009</span><br><span class="line">print(aList)</span><br></pre></td></tr></table></figure>
<h2 id="列表的修改"><a href="#列表的修改" class="headerlink" title="列表的修改"></a>列表的修改</h2><p>赋值语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>]</span><br><span class="line">students[<span class="number">1</span>]=<span class="string">&#x27;小&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(students)</span><br></pre></td></tr></table></figure>
<h2 id="列表的增加"><a href="#列表的增加" class="headerlink" title="列表的增加"></a>列表的增加</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;松&#x27;</span>] </span><br><span class="line">list2 = [<span class="string">&#x27;竹&#x27;</span>] </span><br><span class="line">list3 = [<span class="string">&#x27;梅&#x27;</span>] </span><br><span class="line"><span class="built_in">list</span> = list1 + list2 +list3<span class="comment">#符号&#x27;+&#x27;只能⽤在列表之间，不能⽤在列表和元素之间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典名=&#123;键:值,...,键n:值n&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;小蓝&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;小红&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;小明&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(scores)</span><br></pre></td></tr></table></figure>
<h2 id="提取元素"><a href="#提取元素" class="headerlink" title="提取元素"></a>提取元素</h2><p><strong>字典名[字典的键]</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(scores[<span class="string">&#x27;小红&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="删除字典键值对"><a href="#删除字典键值对" class="headerlink" title="删除字典键值对"></a>删除字典键值对</h2><p><strong>del 字典名[键]</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">album = &#123;<span class="string">&#x27;周杰伦&#x27;</span>:<span class="string">&#x27;七里香&#x27;</span>,<span class="string">&#x27;王力宏&#x27;</span>:<span class="string">&#x27;心中的日月&#x27;</span>&#125;</span><br><span class="line">del album[<span class="string">&#x27;周杰伦&#x27;</span>]</span><br><span class="line">print(album)</span><br></pre></td></tr></table></figure>
<h2 id="新增键值对"><a href="#新增键值对" class="headerlink" title="新增键值对"></a>新增键值对</h2><p><strong>字典名[键] = 值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">90</span>&#125;</span><br><span class="line"><span class="keyword">del</span> scores[<span class="string">&#x27;小刚&#x27;</span>]</span><br><span class="line">scores[<span class="string">&#x27;小刚&#x27;</span>]=<span class="number">92</span></span><br><span class="line">scores[<span class="string">&#x27;小美&#x27;</span>]=<span class="number">85</span></span><br><span class="line"><span class="built_in">print</span>(scores)</span><br></pre></td></tr></table></figure>
<ul>
<li>列表有序，要用偏移量定位；字典无序，便通过唯一的键来取值。</li>
</ul>
<h3 id="提取字典所有的键"><a href="#提取字典所有的键" class="headerlink" title="提取字典所有的键"></a>提取字典所有的键</h3><p><strong>dict.key()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">group = &#123;<span class="string">&#x27;师父&#x27;</span>:<span class="string">&#x27;唐三藏&#x27;</span>, <span class="string">&#x27;大师兄&#x27;</span>:<span class="string">&#x27;孙行者&#x27;</span>, <span class="string">&#x27;二师兄&#x27;</span>:<span class="string">&#x27;猪八戒&#x27;</span>, <span class="string">&#x27;沙师弟&#x27;</span>:<span class="string">&#x27;沙和尚&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(group.keys())<span class="comment">#打印出dict_keys([&#x27;师父&#x27;, &#x27;大师兄&#x27;, &#x27;二师兄&#x27;, &#x27;沙师弟&#x27;])；元组形式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(group.keys()))<span class="comment">#打印出[&#x27;师父&#x27;, &#x27;大师兄&#x27;, &#x27;二师兄&#x27;, &#x27;沙师弟&#x27;]；通过list()函数将元组转化为列表的形式</span></span><br></pre></td></tr></table></figure>
<h3 id="提取字典中所有的值"><a href="#提取字典中所有的值" class="headerlink" title="提取字典中所有的值"></a>提取字典中所有的值</h3><p><strong>dict.values()</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">group = &#123;<span class="string">&#x27;师父&#x27;</span>:<span class="string">&#x27;唐三藏&#x27;</span>, <span class="string">&#x27;大师兄&#x27;</span>:<span class="string">&#x27;孙行者&#x27;</span>, <span class="string">&#x27;二师兄&#x27;</span>:<span class="string">&#x27;猪八戒&#x27;</span>, <span class="string">&#x27;沙师弟&#x27;</span>:<span class="string">&#x27;沙和尚&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(group.values())<span class="comment">#打印出dict_values([&#x27;唐三藏&#x27;, &#x27;孙行者&#x27;, &#x27;猪八戒&#x27;, &#x27;沙和尚&#x27;])</span></span><br></pre></td></tr></table></figure>
<h3 id="提取字典中所有的键值对"><a href="#提取字典中所有的键值对" class="headerlink" title="提取字典中所有的键值对"></a>提取字典中所有的键值对</h3><p><strong>dict.items()</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">group = &#123;<span class="string">&#x27;师父&#x27;</span>:<span class="string">&#x27;唐三藏&#x27;</span>, <span class="string">&#x27;大师兄&#x27;</span>:<span class="string">&#x27;孙行者&#x27;</span>, <span class="string">&#x27;二师兄&#x27;</span>:<span class="string">&#x27;猪八戒&#x27;</span>, <span class="string">&#x27;沙师弟&#x27;</span>:<span class="string">&#x27;沙和尚&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(group.items())<span class="comment">#打印出dict_items([(&#x27;师父&#x27;, &#x27;唐三藏&#x27;), (&#x27;大师兄&#x27;, &#x27;孙行者&#x27;), (&#x27;二师兄&#x27;, &#x27;猪八戒&#x27;), (&#x27;沙师弟&#x27;, &#x27;沙和尚&#x27;)])</span></span><br></pre></td></tr></table></figure>
<h2 id="存储为字典"><a href="#存储为字典" class="headerlink" title="存储为字典"></a>存储为字典</h2><ul>
<li>语法：dict[键]=值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;班长&#x27;</span>]=&#123;<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小明&#x27;</span>:<span class="number">96</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<h1 id="字典列表嵌套"><a href="#字典列表嵌套" class="headerlink" title="字典列表嵌套"></a>字典列表嵌套</h1><h2 id="列表嵌套列表"><a href="#列表嵌套列表" class="headerlink" title="列表嵌套列表"></a>列表嵌套列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [[<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>],[<span class="string">&#x27;小强&#x27;</span>,<span class="string">&#x27;小兰&#x27;</span>,<span class="string">&#x27;小伟&#x27;</span>,<span class="string">&#x27;小芳&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">1</span>][<span class="number">3</span>])<span class="comment">#提取小芳</span></span><br></pre></td></tr></table></figure>
<h2 id="字典嵌套字典"><a href="#字典嵌套字典" class="headerlink" title="字典嵌套字典"></a>字典嵌套字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;</span><br><span class="line">    <span class="string">&#x27;第一组&#x27;</span>:&#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;小美&#x27;</span>:<span class="number">85</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;第二组&#x27;</span>:&#123;<span class="string">&#x27;小强&#x27;</span>:<span class="number">99</span>,<span class="string">&#x27;小兰&#x27;</span>:<span class="number">89</span>,<span class="string">&#x27;小伟&#x27;</span>:<span class="number">93</span>,<span class="string">&#x27;小芳&#x27;</span>:<span class="number">88</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">print</span>(scores[<span class="string">&#x27;第一组&#x27;</span>][<span class="string">&#x27;小刚&#x27;</span>])<span class="comment">#提取小刚的成绩</span></span><br></pre></td></tr></table></figure>
<h2 id="字典列表相互嵌套"><a href="#字典列表相互嵌套" class="headerlink" title="字典列表相互嵌套"></a>字典列表相互嵌套</h2><p>提取键或者偏移量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最外层是大括号，所以是字典嵌套列表，先找到字典的键对应的列表，再判断列表中要取出元素的偏移量</span></span><br><span class="line">students = &#123;</span><br><span class="line">    <span class="string">&#x27;第一组&#x27;</span>:[<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;第二组&#x27;</span>:[<span class="string">&#x27;小强&#x27;</span>,<span class="string">&#x27;小兰&#x27;</span>,<span class="string">&#x27;小伟&#x27;</span>,<span class="string">&#x27;小芳&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">print</span>(students[<span class="string">&#x27;第一组&#x27;</span>][<span class="number">3</span>])</span><br><span class="line"><span class="comment">#取出&#x27;第一组&#x27;对应列表偏移量为3的元素，即&#x27;小美&#x27;</span></span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line"><span class="comment"># 最外层是中括号，所以是列表嵌套字典，先判断字典是列表的第几个元素，再找出要取出的值相对应的键</span></span><br><span class="line">scores = [</span><br><span class="line">    &#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;小美&#x27;</span>:<span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;小强&#x27;</span>:<span class="number">99</span>,<span class="string">&#x27;小兰&#x27;</span>:<span class="number">89</span>,<span class="string">&#x27;小伟&#x27;</span>:<span class="number">93</span>,<span class="string">&#x27;小芳&#x27;</span>:<span class="number">88</span>&#125;</span><br><span class="line">    ]</span><br><span class="line"><span class="built_in">print</span>(scores[<span class="number">1</span>][<span class="string">&#x27;小强&#x27;</span>])</span><br><span class="line"><span class="comment">#先定位到列表偏移量为1的元素，即第二个字典，再取出字典里键为&#x27;小强&#x27;对应的值，即99。</span></span><br></pre></td></tr></table></figure>
<h5 id="例子遍历"><a href="#例子遍历" class="headerlink" title="例子遍历"></a>例子遍历</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">movies = &#123;</span><br><span class="line"><span class="string">&#x27;妖猫传&#x27;</span>:[<span class="string">&#x27;黄轩&#x27;</span>,<span class="string">&#x27;染谷将太&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;无问西东&#x27;</span>:[<span class="string">&#x27;章子怡&#x27;</span>,<span class="string">&#x27;王力宏&#x27;</span>,<span class="string">&#x27;祖峰&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;超时空同居&#x27;</span>:[<span class="string">&#x27;雷佳音&#x27;</span>,<span class="string">&#x27;佟丽娅&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actor = <span class="built_in">input</span>(<span class="string">&#x27;你想查询哪个演员？&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>  movie <span class="keyword">in</span> movies:  <span class="comment"># 用 for 遍历字典</span></span><br><span class="line">    actors = movies[movie]  <span class="comment"># 读取各个字典的主演表</span></span><br><span class="line">    <span class="keyword">if</span> actor <span class="keyword">in</span> actors:</span><br><span class="line">        <span class="built_in">print</span>(actor + <span class="string">&#x27;出演了电影&#x27;</span> + movie)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>for遍历字典读取键</strong></li>
</ul>
<h1 id="for…in…循环"><a href="#for…in…循环" class="headerlink" title="for…in…循环"></a>for…in…循环</h1><h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]:<span class="comment">#i就是遍历列表的元素; i是“空房间”</span></span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;日本&#x27;</span>:<span class="string">&#x27;东京&#x27;</span>,<span class="string">&#x27;英国&#x27;</span>:<span class="string">&#x27;伦敦&#x27;</span>,<span class="string">&#x27;法国&#x27;</span>:<span class="string">&#x27;巴黎&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">dict</span>:<span class="comment">#发现i会逐个接待字典中的每一个【键】</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;吴承恩&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<ul>
<li>for循环遍历字典时，<strong>接待字典中的每一个【键】</strong></li>
<li>for循环遍历列表时，<strong>接待列表的元素</strong></li>
<li>for循环遍历字符串时，接待的是<strong>字符串的每个组成</strong></li>
<li>循环次数明确</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248817.png" alt="image-20210810144914136"></p>
<h2 id="range-x-函数"><a href="#range-x-函数" class="headerlink" title="range(x)函数"></a><code>range(x)</code>函数</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol>
<li><code>range(a,b)</code> 函数，你可以生成了一个【取头不取尾】的整数序列</li>
<li>循环输出n句话</li>
<li><code>range(a,b,n)</code>的意思是：从a数到b（取头不取尾），步长为n</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>,<span class="number">17</span>):<span class="comment">#表示从13到16的整数列表</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):<span class="comment">#i从0到10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;书恒走的第&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;天，想他&#x27;</span>)<span class="comment">#循环11次</span></span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>):从<span class="number">0</span>数到<span class="number">9</span>（取头不取尾），步长为<span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>循环次数可不明确</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    内容</span><br><span class="line"><span class="comment">##########################################分割线 </span></span><br><span class="line">    </span><br><span class="line">a = <span class="number">0</span>                <span class="comment">#先定义变量a，并赋值</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">5</span>:         <span class="comment">#设定一个放行条件：a要小于5，才能办事</span></span><br><span class="line">    a = a + <span class="number">1</span>  <span class="comment"># 满足条件时，就办事：将a+1</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment"># 继续办事：将a+1的结果打印出来 </span></span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line">password = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 变量password用来保存输入的密码</span></span><br><span class="line"><span class="keyword">while</span> password != <span class="string">&#x27;816&#x27;</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;请尝试输入密码:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;欢迎回家&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><ul>
<li>计算机的逻辑判断，只有两种结果，就是<code>True</code>（英文意思是“真”）和<code>False</code>（英文意思是“假”），没有灰色地带。这个计算真假的过程，叫做【布尔运算】。</li>
<li>决定if语句和循环语句怎么运行</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>两个值作比较</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248347.png" alt="image-20210810165656378"></p>
<ul>
<li>数值作比较</li>
</ul>
<p>bool（）函数</p>
<ul>
<li><code>bool()</code>函数来查看一个数据会被判断为真还是假。这个函数的用法与<code>type()</code>函数相似（还有印象吧~），在<code>bool()</code>函数括号中放入我们想要判断真假的数据，然后print出来即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请阅读代码后再直接运行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以下数据判断结果都是【假】：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以下数据判断结果都是【真】：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="布尔值之间的运算"><a href="#布尔值之间的运算" class="headerlink" title="布尔值之间的运算"></a>布尔值之间的运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>释义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>属于</td>
<td>如果值在指定序列⾥，条件为真</td>
</tr>
<tr>
<td>not    in</td>
<td>不属于</td>
<td>如果值不在指定序列⾥，条件为真</td>
</tr>
<tr>
<td>and</td>
<td>且</td>
<td>连接两个布尔值，如果两个都为真，该条件才为真</td>
</tr>
<tr>
<td>or</td>
<td>或</td>
<td>连接两个布尔值，如果有⼀个为真，该条件即为真</td>
</tr>
<tr>
<td>not</td>
<td>非</td>
<td>反逻辑状态，a为True，not a则为False，反之亦然</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">in</span> a)<span class="comment">#判断为假</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> a)<span class="comment">#判断为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> a)<span class="comment">#判断为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> a)<span class="comment">#判断为假</span></span><br><span class="line">b=<span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> b)<span class="comment">#判断为假</span></span><br></pre></td></tr></table></figure>
<h1 id="4种语句"><a href="#4种语句" class="headerlink" title="4种语句"></a>4种语句</h1><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>break的意思是“打破”，是用来结束循环的，一般写作<code>if...break</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># break语句搭配for循环</span></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>...:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># break语句搭配while循环</span></span><br><span class="line"><span class="keyword">while</span>...(条件):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的密码:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="string">&#x27;小龙女&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过啦&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>continue的意思是“继续”。这个子句也是在循环内部使用的。当某个条件被满足的时候，触发continue语句，将跳过之后的代码，直接回到循环的开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># continue语句搭配for循环</span></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>...:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># continue语句搭配while循环</span></span><br><span class="line"><span class="keyword">while</span>...(条件):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    q1 = <span class="built_in">input</span>(<span class="string">&#x27;第一问：你一生之中，在什么地方最是快乐逍遥？&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> q1 != <span class="string">&#x27;黑暗的冰窖&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;答对了，下面是第二问：&#x27;</span>)</span><br><span class="line">    q2 = <span class="built_in">input</span>(<span class="string">&#x27;你生平最爱之人，叫什么名字？&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> q2 != <span class="string">&#x27;梦姑&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;答对了，下面是第三问：&#x27;</span>)</span><br><span class="line">    q3 = <span class="built_in">input</span>(<span class="string">&#x27;你最爱的这个人相貌如何？&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> q3 == <span class="string">&#x27;不知道&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;都答对了，你是虚竹。&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h2><p>跳过,什么都不做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请体验一下报错，然后把pass语句加上</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数:&#x27;</span>))<span class="comment">#a&gt;=100的时候，跳过，什么都不做</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你输入了一个小于100的数字&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="else语句"><a href="#else语句" class="headerlink" title="else语句"></a>else语句</h2><ul>
<li>不仅可以和if语句搭配，也可以和for语句，while语句搭配</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入0来结束循环，你有5次机会:&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你触发了break语句，循环结束，导致else语句不会生效。&#x27;</span>)    </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;5次循环你都错过了，else语句生效了。&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>3.python进阶2</title>
    <url>/blot.github.io/2022/04/03/3%E3%80%81%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B62/</url>
    <content><![CDATA[<h1 id="3、基础进阶2"><a href="#3、基础进阶2" class="headerlink" title="3、基础进阶2"></a>3、基础进阶2</h1><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="time模块——时间"><a href="#time模块——时间" class="headerlink" title="time模块——时间"></a>time模块——时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time   <span class="comment">#调用time模块</span></span><br><span class="line">time.sleep(secs)   </span><br><span class="line"><span class="comment">#使用time模块下面的sleep()函数，括号里填的是间隔的秒数（seconds，简称secs）</span></span><br><span class="line"><span class="comment">#time.sleep(1.5)就表示停留1.5秒再运行后续代码</span></span><br></pre></td></tr></table></figure>
<h2 id="random模块——随机生成数字"><a href="#random模块——随机生成数字" class="headerlink" title="random模块——随机生成数字"></a>random模块——随机生成数字</h2><h3 id="random-randint-a-b"><a href="#random-randint-a-b" class="headerlink" title="random.randint(a,b)"></a>random.randint(a,b)</h3><ul>
<li><strong>生成一个指定范围[a,b]内的整数</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random  <span class="comment"># 调用random模块</span></span><br><span class="line"></span><br><span class="line">a = random.random()  <span class="comment"># 随机从0-1之间（包括0不包括1）抽取一个小数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = random.randint(<span class="number">0</span>,<span class="number">100</span>)  <span class="comment"># 随机从0-100（包括0和100）之间抽取一个数字</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = random.choice(<span class="string">&#x27;abcdefg&#x27;</span>)  <span class="comment"># 随机从字符串，列表等对象中抽取一个元素（可能会重复）</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = random.sample(<span class="string">&#x27;abcdefg&#x27;</span>, <span class="number">3</span>) <span class="comment"># 随机从字符串，列表等对象中抽取多个不重复的元素,不同位置</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  <span class="comment"># “随机洗牌”，比如打乱列表</span></span><br><span class="line">random.shuffle(items)</span><br><span class="line"><span class="built_in">print</span>(items)</span><br></pre></td></tr></table></figure>
<h3 id="random-choice-函数"><a href="#random-choice-函数" class="headerlink" title="random.choice()函数"></a><strong>random.choice()</strong>函数</h3><ul>
<li>random.choice(sequence)：从序列中获取一个随机元素</li>
</ul>
<h3 id="random-random"><a href="#random-random" class="headerlink" title="random.random()"></a>random.random()</h3><ul>
<li>生成一个0到1的随机浮点数</li>
</ul>
<p>random.uniform(a,b)</p>
<ul>
<li>生成一个指定范围(a,b)内的随机浮点数</li>
</ul>
<p>random.randrange(start, stop, step)</p>
<ul>
<li>从指定范围内，按指定基数递增的集合中 获取一个随机数</li>
</ul>
<p>random.shuffle(AB)</p>
<ul>
<li>用于将一个列表中的元素打乱</li>
</ul>
<p>random.sample(sequence, k)</p>
<ul>
<li>从指定序列中随机获取指定长度的片断</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数</span>):</span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> 语句</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数名：1. 名字最好能体现函数的功能，一般用小写字母和单下划线、数字等组合</span></span><br><span class="line"><span class="comment">#      2. 不可与内置函数重名（内置函数不需要定义即可直接使用）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">math</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment"># 参数：根据函数功能，括号里可以有多个参数，也可以不带参数，命名规则与函数名相同</span></span><br><span class="line"><span class="comment"># 规范：括号是英文括号，后面的冒号不能丢</span></span><br><span class="line">    y = <span class="number">3</span>*x + <span class="number">5</span></span><br><span class="line"><span class="comment"># 函数体：函数的执行过程，体现函数功能的语句，要缩进，一般是四个空格</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"><span class="comment"># return语句：后面可以接多种数据类型，如果函数不需要返回值的话，可以省略</span></span><br></pre></td></tr></table></figure>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">math</span>(<span class="params">x</span>):</span><br><span class="line">    y = x ** <span class="number">2</span> + x</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">a = math(<span class="number">20</span>)<span class="comment">#调用函数</span></span><br><span class="line">b = math(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span>  <span class="title function_">menu</span>(<span class="params">appetizer, course, dessert = <span class="string">&#x27;绿豆沙&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;一份开胃菜：&#x27;</span> + appetizer)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;一份主食：&#x27;</span> + course)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;一份甜品：&#x27;</span> + dessert)</span><br><span class="line"></span><br><span class="line">menu(<span class="string">&#x27;话梅花生&#x27;</span>,<span class="string">&#x27;牛肉拉面&#x27;</span>)</span><br><span class="line"><span class="comment">#因为已经默认将&#x27;绿豆沙&#x27;传递给dessert，调用时无须再传递。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------&#x27;</span>)</span><br><span class="line"><span class="comment">#如果采用下面这种形式传递，就不需要理会参数位置</span></span><br><span class="line">menu(course = <span class="string">&#x27;牛肉拉面&#x27;</span>, appetizer = <span class="string">&#x27;话梅花生&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------&#x27;</span>)</span><br><span class="line">menu(<span class="string">&#x27;话梅花生&#x27;</span>,<span class="string">&#x27;牛肉拉面&#x27;</span>,<span class="string">&#x27;银耳羹&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------&#x27;</span>)</span><br><span class="line">menu(<span class="string">&#x27;话梅花生&#x27;</span>,<span class="string">&#x27;牛肉拉面&#x27;</span>,<span class="string">&#x27;银耳羹&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><ul>
<li>格式：def  函数名（*参数）</li>
<li>参数返回值是<strong>元组类型</strong></li>
<li>不定长参数可以接收任意数量的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">*barbeque</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> barbeque:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;一份烤串：&#x27;</span> + i)</span><br><span class="line"></span><br><span class="line">menu(<span class="string">&#x27;烤香肠&#x27;</span>, <span class="string">&#x27;烤肉丸&#x27;</span>) <span class="comment">#括号里的这几个值都会传递给参数barbeque       </span></span><br><span class="line">menu(<span class="string">&#x27;烤鸡翅&#x27;</span>, <span class="string">&#x27;烤茄子&#x27;</span>, <span class="string">&#x27;烤玉米&#x27;</span>)</span><br><span class="line"><span class="comment"># 不定长参数可以接收任意数量的值</span></span><br></pre></td></tr></table></figure>
<h1 id="try…except-语句"><a href="#try…except-语句" class="headerlink" title="try…except..语句"></a>try…except..语句</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="comment">#尝试执行下列代码</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">except</span> ***:</span><br><span class="line">	<span class="comment">#除非发生报错，***是报错类型，移到报错执行下列代码</span></span><br><span class="line">	...</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;要输入整数噢&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="python异常标准"><a href="#python异常标准" class="headerlink" title="python异常标准"></a>python异常标准</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">异常名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BaseException</td>
<td style="text-align:left">所有异常的基类</td>
</tr>
<tr>
<td style="text-align:left">SystemExit</td>
<td style="text-align:left">解释器请求退出</td>
</tr>
<tr>
<td style="text-align:left">KeyboardInterrupt</td>
<td style="text-align:left">用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td style="text-align:left">Exception</td>
<td style="text-align:left">常规错误的基类</td>
</tr>
<tr>
<td style="text-align:left">StopIteration</td>
<td style="text-align:left">迭代器没有更多的值</td>
</tr>
<tr>
<td style="text-align:left">GeneratorExit</td>
<td style="text-align:left">生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td style="text-align:left">StandardError</td>
<td style="text-align:left">所有的内建标准异常的基类</td>
</tr>
<tr>
<td style="text-align:left">ArithmeticError</td>
<td style="text-align:left">所有数值计算错误的基类</td>
</tr>
<tr>
<td style="text-align:left">FloatingPointError</td>
<td style="text-align:left">浮点计算错误</td>
</tr>
<tr>
<td style="text-align:left">OverflowError</td>
<td style="text-align:left">数值运算超出最大限制</td>
</tr>
<tr>
<td style="text-align:left">ZeroDivisionError</td>
<td style="text-align:left">除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td style="text-align:left">AssertionError</td>
<td style="text-align:left">断言语句失败</td>
</tr>
<tr>
<td style="text-align:left">AttributeError</td>
<td style="text-align:left">对象没有这个属性</td>
</tr>
<tr>
<td style="text-align:left">EOFError</td>
<td style="text-align:left">没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td style="text-align:left">EnvironmentError</td>
<td style="text-align:left">操作系统错误的基类</td>
</tr>
<tr>
<td style="text-align:left">IOError</td>
<td style="text-align:left">输入/输出操作失败</td>
</tr>
<tr>
<td style="text-align:left">OSError</td>
<td style="text-align:left">操作系统错误</td>
</tr>
<tr>
<td style="text-align:left">WindowsError</td>
<td style="text-align:left">系统调用失败</td>
</tr>
<tr>
<td style="text-align:left">ImportError</td>
<td style="text-align:left">导入模块/对象失败</td>
</tr>
<tr>
<td style="text-align:left">LookupError</td>
<td style="text-align:left">无效数据查询的基类</td>
</tr>
<tr>
<td style="text-align:left">IndexError</td>
<td style="text-align:left">序列中没有此索引(index)</td>
</tr>
<tr>
<td style="text-align:left">KeyError</td>
<td style="text-align:left">映射中没有这个键</td>
</tr>
<tr>
<td style="text-align:left">MemoryError</td>
<td style="text-align:left">内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td style="text-align:left">NameError</td>
<td style="text-align:left">未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td style="text-align:left">UnboundLocalError</td>
<td style="text-align:left">访问未初始化的本地变量</td>
</tr>
<tr>
<td style="text-align:left">ReferenceError</td>
<td style="text-align:left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td style="text-align:left">RuntimeError</td>
<td style="text-align:left">一般的运行时错误</td>
</tr>
<tr>
<td style="text-align:left">NotImplementedError</td>
<td style="text-align:left">尚未实现的方法</td>
</tr>
<tr>
<td style="text-align:left">SyntaxError</td>
<td style="text-align:left">Python 语法错误</td>
</tr>
<tr>
<td style="text-align:left">IndentationError</td>
<td style="text-align:left">缩进错误</td>
</tr>
<tr>
<td style="text-align:left">TabError</td>
<td style="text-align:left">Tab 和空格混用</td>
</tr>
<tr>
<td style="text-align:left">SystemError</td>
<td style="text-align:left">一般的解释器系统错误</td>
</tr>
<tr>
<td style="text-align:left">TypeError</td>
<td style="text-align:left">对类型无效的操作</td>
</tr>
<tr>
<td style="text-align:left">ValueError</td>
<td style="text-align:left">传入无效的参数</td>
</tr>
<tr>
<td style="text-align:left">UnicodeError</td>
<td style="text-align:left">Unicode 相关的错误</td>
</tr>
<tr>
<td style="text-align:left">UnicodeDecodeError</td>
<td style="text-align:left">Unicode 解码时的错误</td>
</tr>
<tr>
<td style="text-align:left">UnicodeEncodeError</td>
<td style="text-align:left">Unicode 编码时错误</td>
</tr>
<tr>
<td style="text-align:left">UnicodeTranslateError</td>
<td style="text-align:left">Unicode 转换时错误</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">警告的基类</td>
</tr>
<tr>
<td style="text-align:left">DeprecationWarning</td>
<td style="text-align:left">关于被弃用的特征的警告</td>
</tr>
<tr>
<td style="text-align:left">FutureWarning</td>
<td style="text-align:left">关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td style="text-align:left">OverflowWarning</td>
<td style="text-align:left">旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td style="text-align:left">PendingDeprecationWarning</td>
<td style="text-align:left">关于特性将会被废弃的警告</td>
</tr>
<tr>
<td style="text-align:left">RuntimeWarning</td>
<td style="text-align:left">可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td style="text-align:left">SyntaxWarning</td>
<td style="text-align:left">可疑的语法的警告</td>
</tr>
<tr>
<td style="text-align:left">UserWarning</td>
<td style="text-align:left">用户代码生成的警告</td>
</tr>
</tbody>
</table>
</div>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ul>
<li><strong>类</strong>:比如整数、字符串、浮点数等，不同的数据类型就属于不同的类</li>
<li>类有自己的属性和方法</li>
<li>类名要大写</li>
<li><strong>实例</strong>:类的个例就叫做<strong>实例</strong></li>
<li>对象:对象等于类和实例的集合：即类可以看作是对象，实例也可以看作是对象，比如列表list是个类对象，<code>[1,2]</code>是个实例对象，它们都是对象。</li>
</ul>
<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">	赋值语句<span class="comment">#类的属性创建</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self</span>):<span class="comment">#类中定义的函数叫方法</span></span><br><span class="line">		执行过程</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:<span class="comment">#</span></span><br><span class="line">	screen = <span class="literal">True</span><span class="comment">## 用赋值语句，创建类的属性</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;电脑正在开机中...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="类的调用"><a href="#类的调用" class="headerlink" title="类的调用"></a>类的调用</h2><h3 id="调用语法"><a href="#调用语法" class="headerlink" title="调用语法"></a>调用语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">实例名.属性</span><br><span class="line">实例名.方法（）</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">    screen = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;电脑正在开机中……&#x27;</span>)</span><br><span class="line">my_computer = Computer()<span class="comment">#类的实例化</span></span><br><span class="line"><span class="built_in">print</span>(my_computer.screen)<span class="comment">#调用属性属性</span></span><br><span class="line">my_computer.start()<span class="comment">#调用类中的方法（传参不用管self）</span></span><br></pre></td></tr></table></figure>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><ul>
<li><p>self会接收实例化过程中传入的数据，当实例对象创建后，实例便会代替 self，在代码中运行。</p>
</li>
<li><p><code>self</code>的作用相当于先给实例占了个位置，等到实例创建好就“功成身退，退位让贤”。</p>
</li>
</ul>
<h4 id="在方法内调用类的属性"><a href="#在方法内调用类的属性" class="headerlink" title="在方法内调用类的属性"></a>在方法内调用类的属性</h4><p><strong>self.属性名</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过self.属性名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&#x27;吴枫&#x27;</span>  <span class="comment"># 类属性name</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):     </span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;是中国人&#x27;</span>)<span class="comment">#调用类中的属性</span></span><br><span class="line"></span><br><span class="line">person = Chinese()   <span class="comment"># 创建Chinese的实例person</span></span><br><span class="line">person.say()         <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="comment">#实例person会像参数一样传给self，替换掉self，第六行的self.name等价于person.name</span></span><br></pre></td></tr></table></figure>
<h4 id="在类方法调用其他方法"><a href="#在类方法调用其他方法" class="headerlink" title="在类方法调用其他方法"></a>在类方法调用其他方法</h4><p><strong>self.方法名（）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#self.方法名（）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;很高兴遇见你&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        self.greeting() </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我来自中国&#x27;</span>)</span><br><span class="line">person = Chinese()</span><br><span class="line"><span class="comment"># 创建实例person</span></span><br><span class="line">person.say()</span><br><span class="line"><span class="comment"># 调用say()方法</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式__init__(self)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当每个实例<strong>对象创建</strong>时，该方法内的代码<strong>无须调用就会自动运行</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 阅读代码后直接运行    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;很高兴遇见你，我是初始化方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person = Chinese()</span><br></pre></td></tr></table></figure>
<ul>
<li>利用这个特性，在编写习惯上，我们会在初始化方法内部完成类属性的创建，为类属性设置初始值，这样类中的其他方法就能直接、随时调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, birth, region</span>):</span><br><span class="line">        self.name = name   <span class="comment"># self.name = &#x27;吴枫&#x27; </span></span><br><span class="line">        self.birth = birth  <span class="comment"># self.birth = &#x27;广东&#x27;</span></span><br><span class="line">        self.region = region  <span class="comment"># self.region = &#x27;深圳&#x27;</span></span><br><span class="line">        <span class="comment">#self.不能丢</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">born</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;出生在&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name,self.birth))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">live</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;居住在&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name,self.region) )    </span><br><span class="line"></span><br><span class="line">person = Chinese(<span class="string">&#x27;吴枫&#x27;</span>,<span class="string">&#x27;广东&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>) <span class="comment"># 传入初始化方法的参数</span></span><br><span class="line">person.born()</span><br><span class="line">person.live()</span><br><span class="line"><span class="built_in">print</span>(person.birth)<span class="comment">#输出方法内的参数</span></span><br></pre></td></tr></table></figure>
<p>面向对象编程：类的创建和调用</p>
<p>面向过程编程：函数的创建和调用</p>
<h1 id="类的继承和定制"><a href="#类的继承和定制" class="headerlink" title="类的继承和定制"></a>类的继承和定制</h1><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ul>
<li>让子类拥有了父类拥有的所有属性和方法</li>
<li>A类为B的子类，B为A的父类</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><strong>class 子类名（父类名）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    eye = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;吃饭，选择用筷子。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):  </span><br><span class="line"><span class="comment"># 通过继承，Chinese类有的，Cantonese类也有</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 验证子类可以继承父类的属性和方法，进而传递给子类创建的实例</span></span><br><span class="line">yewen = Cantonese()  </span><br><span class="line"><span class="comment"># 子类创建的实例，从子类那间接得到了父类的所有属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(yewen.eye)  </span><br><span class="line"><span class="comment"># 子类创建的实例，可调用父类的属性</span></span><br><span class="line">yewen.eat()  </span><br><span class="line"><span class="comment"># 子类创建的实例，可调用父类的方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>class Chinese:</code>在运行时相当于<code>class Chinese(object):</code>。而object，是所有类的父类</li>
</ul>
<h4 id="验证类"><a href="#验证类" class="headerlink" title="验证类"></a>验证类</h4><ul>
<li><strong>函数<code>isinstance(实例，类名)</code></strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 阅读完代码再运行。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">gonger = Chinese()</span><br><span class="line"><span class="comment"># 宫二，电影《一代宗师》女主，生于东北</span></span><br><span class="line">yewen = Cantonese()</span><br><span class="line"><span class="comment"># 叶问，电影《一代宗师》男主，生于广东</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n验证1：子类创建的实例同时也属于父类&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(gonger,Chinese))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(yewen,Chinese))  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n验证2：父类创建的实例不属于子类。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(gonger,Cantonese))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n验证3：类创建的实例都属于根类。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(gonger,<span class="built_in">object</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(yewen,<span class="built_in">object</span>))</span><br></pre></td></tr></table></figure>
<h3 id="类的多层继承"><a href="#类的多层继承" class="headerlink" title="类的多层继承"></a>类的多层继承</h3><ul>
<li>继承不仅可以发生在两个层级之间（即父类-子类），还可以有父类的父类、父类的父类的父类……</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">B</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>)</span><br></pre></td></tr></table></figure>
<h3 id="类的多重继承"><a href="#类的多重继承" class="headerlink" title="类的多重继承"></a>类的多重继承</h3><ul>
<li><strong>语法为class A(B,C,D)</strong></li>
<li>一个类，可以同时继承多个类，语法为<code>class A(B,C,D):</code>。假设我们将“出生在江苏，定居在广东的人”设为一个类Yuesu，那么，它的创建语句则为<code>class Yuesu(Yue,Su)</code></li>
<li><strong>就近原则</strong>：越靠近子类（即越靠左）的父类，越亲近，越优先考虑。子类调用属性和方法时，会<strong>先在靠左的父类里找</strong>，找不到才往右找。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Su</span>:</span><br><span class="line">    born_city = <span class="string">&#x27;Jiangsu&#x27;</span></span><br><span class="line">    wearing = <span class="string">&#x27;thick&#x27;</span>  <span class="comment"># 穿得较厚</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们爱吃甜。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yue</span>:</span><br><span class="line">    settle_city = <span class="string">&#x27;Guangdong&#x27;</span></span><br><span class="line">    wearing = <span class="string">&#x27;thin&#x27;</span>  <span class="comment"># 穿得较薄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们吃得清淡。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yuesu</span>(Yue,Su):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">xiaoming = Yuesu()</span><br><span class="line"><span class="built_in">print</span>(xiaoming.wearing)</span><br><span class="line"><span class="built_in">print</span>(xiaoming.born_city)</span><br><span class="line">xiaoming.diet()</span><br></pre></td></tr></table></figure>
<h2 id="类的定制"><a href="#类的定制" class="headerlink" title="类的定制"></a>类的定制</h2><p>类的定制，不仅可以让子类拥有新的功能，还能让它有权修改继承到的代码</p>
<ul>
<li>新增代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    eye = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;吃饭，选择用筷子。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):  <span class="comment"># 类的继承</span></span><br><span class="line">    native_place = <span class="string">&#x27;guangdong&#x27;</span>  <span class="comment"># 类的定制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dialect</span>(<span class="params">self</span>):  <span class="comment"># 类的定制</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们会讲广东话。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yewen = Cantonese()</span><br><span class="line"><span class="built_in">print</span>(yewen.eye)</span><br><span class="line"><span class="comment"># 父类的属性能用</span></span><br><span class="line"><span class="built_in">print</span>(yewen.native_place)</span><br><span class="line"><span class="comment"># 子类的定制属性也能用</span></span><br><span class="line">yewen.eat()</span><br><span class="line"><span class="comment"># 父类的方法能用</span></span><br><span class="line">yewen.dialect()</span><br><span class="line"><span class="comment"># 子类的定制方法也能用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>重写代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">land_area</span>(<span class="params">self,area</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们居住的地方，陆地面积是%d万平方公里左右。&#x27;</span>% area)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):</span><br><span class="line">    <span class="comment"># 间接对方法进行重写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">land_area</span>(<span class="params">self, area, rate = <span class="number">0.0188</span></span>):</span><br><span class="line">        Chinese.land_area(self, area * rate)</span><br><span class="line">        <span class="comment"># 直接继承父类方法，再调整参数。</span></span><br><span class="line"></span><br><span class="line">gonger = Chinese()</span><br><span class="line">yewen = Cantonese()</span><br><span class="line">gonger.land_area(<span class="number">960</span>)</span><br><span class="line">yewen.land_area(<span class="number">960</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2.数字间关系——C语言</title>
    <url>/blot.github.io/2022/03/03/2%E3%80%81%E6%95%B0%E5%AD%97%E9%97%B4%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="二、数字间关系"><a href="#二、数字间关系" class="headerlink" title="二、数字间关系"></a>二、数字间关系</h1><h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><h3 id="算数优先级"><a href="#算数优先级" class="headerlink" title="算数优先级"></a>算数优先级</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041241962.png" alt="image-20210801231244413"></p>
<h3 id="求余运算"><a href="#求余运算" class="headerlink" title="求余运算"></a>求余运算</h3><ul>
<li>判断某数是否被整除</li>
<li>操作数是整数</li>
</ul>
<h3 id="常见数学运算"><a href="#常见数学运算" class="headerlink" title="常见数学运算"></a>常见数学运算</h3><ol>
<li>注：要在开头加#include<math.h></li>
<li>随机函数rand()</li>
</ol>
<ul>
<li>生成一个在0~32767之间的随机数</li>
<li>问题:如何生成一个指定范围（如1~100)内的随机数?* magic = rand() % 100 ;    //0~99</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041241530.png" alt="image-20210801231948222"></p>
<h2 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h2><ul>
<li>变量=表达式；</li>
<li>变量1=变量2=表达式；</li>
<li>变量1运算符op=表达式；</li>
<li>类型   变量=表达式</li>
</ul>
<h2 id="增1和减1运算符（-，—）"><a href="#增1和减1运算符（-，—）" class="headerlink" title="增1和减1运算符（++，—）"></a>增1和减1运算符（++，—）</h2><h3 id="前缀与后缀区别"><a href="#前缀与后缀区别" class="headerlink" title="前缀与后缀区别"></a>前缀与后缀区别</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">m=n++；<span class="comment">//先赋值再加1——等价m=n;n=n+1;</span></span><br><span class="line"></span><br><span class="line">m=++n;<span class="comment">//先加1在赋值——等价n=n+1;m=n;</span></span><br></pre></td></tr></table></figure>
<h2 id="自动转换类型"><a href="#自动转换类型" class="headerlink" title="自动转换类型"></a>自动转换类型</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041241643.png" alt="image-20210802161900920"></p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul>
<li>类型（表达式）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> total,number;</span><br><span class="line">	<span class="type">float</span> aver1,aver2;</span><br><span class="line">	total = <span class="number">15</span>;</span><br><span class="line">	number = <span class="number">2</span>;</span><br><span class="line">	aver1 = total/number;<span class="comment">//无强制性转换</span></span><br><span class="line">	aver2 = (<span class="type">float</span>)total/number;<span class="comment">//强制性转化</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;aver1=%f\n&quot;</span>,aver1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;aver2=%f\n&quot;</span>,aver2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>3.输入与输出——C语言</title>
    <url>/blot.github.io/2022/03/03/3%E3%80%81%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><h2 id="屏幕输出printf（）"><a href="#屏幕输出printf（）" class="headerlink" title="屏幕输出printf（）"></a>屏幕输出printf（）</h2><h3 id="输出字符"><a href="#输出字符" class="headerlink" title="输出字符"></a>输出字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>%d</th>
<th>输出十进制有符号int型</th>
</tr>
</thead>
<tbody>
<tr>
<td>%u</td>
<td>输出十进制无符号int型</td>
</tr>
<tr>
<td>%f</td>
<td>以小数形式(6位小数)输出float , double型以标准指数形式输出float , double型</td>
</tr>
<tr>
<td>%e</td>
<td>以标准指数形式输出float , double型</td>
</tr>
<tr>
<td>%c</td>
<td>以字符形式输出单个字符</td>
</tr>
<tr>
<td>l</td>
<td>加d、u前输出long型</td>
</tr>
<tr>
<td>h</td>
<td>加d、u前输出short型</td>
</tr>
</tbody>
</table>
</div>
<h5 id="long-long-的输入和输出"><a href="#long-long-的输入和输出" class="headerlink" title="long long 的输入和输出"></a>long long 的输入和输出</h5><ul>
<li><p>输入：scanf(“%Ild”,&amp;a)；</p>
</li>
<li><p>输出：printf(“%Ild”,a)；</p>
</li>
</ul>
<p>或者还有一版本</p>
<ul>
<li>输入：scanf(“%I64d”,&amp;a)；</li>
<li>输出：printf(“%I64d”,a)；</li>
<li><strong>注意I为大写的i</strong></li>
</ul>
<h3 id="printf-的格式修饰符"><a href="#printf-的格式修饰符" class="headerlink" title="printf()的格式修饰符"></a>printf()的格式修饰符</h3><h4 id="m-输出数据最小域宽"><a href="#m-输出数据最小域宽" class="headerlink" title="m:输出数据最小域宽"></a>m:输出数据最小域宽</h4><ul>
<li>数据位宽大于m时，按实际位宽输出</li>
<li>小于m时，右对齐，左补空格</li>
<li>-m:左对齐，右补空格</li>
</ul>
<h4 id="显示精度-n"><a href="#显示精度-n" class="headerlink" title="显示精度.n:"></a>显示精度.n:</h4><ul>
<li>对浮点数表示输出n位小数</li>
<li>格式：%.nf</li>
</ul>
<p>其他</p>
<ul>
<li><p>一般格式：%m.nf</p>
</li>
<li><p>屏幕输出%</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">	a=<span class="number">7.4848</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%10.2f\n&quot;</span>,a );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d%%\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="键盘输入scanf"><a href="#键盘输入scanf" class="headerlink" title="键盘输入scanf()"></a>键盘输入scanf()</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li>scanf(“%d%f”,&amp;a,&amp;b);</li>
</ul>
<p>分隔多个输入数据</p>
<ol>
<li>空格、Tab或回车</li>
<li>达到输入位宽</li>
<li>遇到非法字符</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);<span class="comment">//输入格式正确，返回数值1;遇到非法数字则是返回0</span></span><br><span class="line">c = <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,b);<span class="comment">//scanf的返回值是参数被成功赋值的个数；也可作为输入非法数值判断</span></span><br></pre></td></tr></table></figure>
<h3 id="scanf-的格式字符"><a href="#scanf-的格式字符" class="headerlink" title="scanf()的格式字符"></a>scanf()的格式字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>%d</th>
<th>输入十进制int型</th>
</tr>
</thead>
<tbody>
<tr>
<td>%f,%e</td>
<td>输入float型（不能指定输入数据精度）</td>
</tr>
<tr>
<td>%c</td>
<td>输入一个字符（包括空白字符）</td>
</tr>
<tr>
<td>m</td>
<td>输入数据位宽</td>
</tr>
<tr>
<td>l</td>
<td>加d,u前输入long型；加f,e前输入double型</td>
</tr>
<tr>
<td>L</td>
<td>加f,e前输入long double型</td>
</tr>
<tr>
<td>h</td>
<td>加d前输入short型</td>
</tr>
</tbody>
</table>
</div>
<h2 id="单个字符输入输出"><a href="#单个字符输入输出" class="headerlink" title="单个字符输入输出"></a>单个字符输入输出</h2><p>字符常量</p>
<ul>
<li>用单引号括起来的一个字符：  ‘98’</li>
</ul>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242590.png" alt="image-20210803185142670"></p>
<h4 id="ACSII码值"><a href="#ACSII码值" class="headerlink" title="ACSII码值"></a><a href="http://c.biancheng.net/c/ascii/">ACSII码值</a></h4><ul>
<li><p>字符在内存存储：对应的ASCII码的二进制值</p>
</li>
<li><p>不管是字符、数字、还是非法数值都有对应的ASCII码值，可以通过ASCII码值来判断是哪种类型</p>
</li>
</ul>
<h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><ol>
<li>定义：char ch = ‘B’</li>
<li>字符型变量的值</li>
</ol>
<ul>
<li>ASCII码值可做算数运算<ol>
<li>字母小写的ASCII码值总比大写ASCII大32</li>
</ol>
</li>
</ul>
<h3 id="单个字符输入输出-1"><a href="#单个字符输入输出-1" class="headerlink" title="单个字符输入输出"></a>单个字符输入输出</h3><h4 id="输出函数putchar"><a href="#输出函数putchar" class="headerlink" title="输出函数putchar()"></a>输出函数putchar()</h4><ul>
<li>putchar(ch)</li>
<li>向屏幕输出一个字符—（类似printf）</li>
</ul>
<h4 id="输入函数getchar（）"><a href="#输入函数getchar（）" class="headerlink" title="输入函数getchar（）"></a>输入函数getchar（）</h4><ul>
<li>ch = getchar()</li>
<li>键盘输入字符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入字符\n&quot;</span>);</span><br><span class="line">	ch = getchar();</span><br><span class="line">	ch = ch+<span class="number">32</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(ch);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//执行结果是将光标执行到下一行的起始位置处</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;作为判断\n&quot;</span>);<span class="comment">//可删去上一行代码作为判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以用printf()输出 </li>
<li>字符型变量可以%c和%d两种格式输出</li>
</ul>
<h2 id="getchar-存在的问题"><a href="#getchar-存在的问题" class="headerlink" title="getchar()存在的问题"></a>getchar()存在的问题</h2><ul>
<li>输入字符时，将所有的用户输入，包括回车符号，都放在输入缓冲区中</li>
<li>当一行输入结束后，getchar才开始从输入缓冲队列中读取字符，而在函数没有读走的数据，留在缓冲区被下个getchar()函数读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch1,ch2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入字符\n&quot;</span>);</span><br><span class="line">	ch1 = getchar();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ch1=%c\n&quot;</span>,ch1 );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请再次输入字符\n&quot;</span>);</span><br><span class="line">	ch2 = getchar();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ch2=%d\n&quot;</span>,ch2 );<span class="comment">//%d输出的是10，对应的换行符的ASCII码值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用-c格式输入存在的问题"><a href="#用-c格式输入存在的问题" class="headerlink" title="用%c格式输入存在的问题"></a>用%c格式输入存在的问题</h3><ul>
<li>用%c格式读入字符时，空格和回车等空白字符都会被当作有效字符读入</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>第一种:用gerchar调用语句将用户输入的回车字符读走</li>
<li>第二种：在%c前加一个空格忽略缓冲区的空白字符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入整数\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数是%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符\n&quot;</span>);</span><br><span class="line">    getchar();<span class="comment">//用gerchar调用语句将用户输入的回车字符读走</span></span><br><span class="line">    <span class="comment">//scanf(&quot; %c&quot;,&amp;b);//在%c前加一个空格忽略缓冲区的空白字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//上一行代码运行时记得注销</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符是%c\n&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入小数\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;小数是%f\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>4.python模块</title>
    <url>/blot.github.io/2022/04/03/4/</url>
    <content><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><ul>
<li>用来存放一位0或1，就是计算机里最小的存储单位，叫做【位】，也叫【比特】（bit）。我们规定8个比特构成一个【字节】（byte），这是计算机里最常用的单位。</li>
<li>bit位：存放一位二进制数，0或1，最小得存储单位</li>
<li>byte字节：8个二进制为1字节，最常用单位</li>
</ul>
<h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h2><ul>
<li><strong>Unicode</strong>是内存编码的规范，而<strong>UTF-8</strong>是如何保存和传输Unicode的手段。</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249105.png" alt="image-20210811224812268"></p>
<h2 id="encode-和decode"><a href="#encode-和decode" class="headerlink" title="encode()和decode()"></a>encode()和decode()</h2><ul>
<li>编码，即将人类语言转换为计算机语言，就是【编码】<strong>encode()</strong>；反之，就是【解码】<strong>decode()</strong></li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#x27;编码内容&#x27;.encode(&#x27;使用得编码表&#x27;)</span></span><br><span class="line"><span class="comment">#&#x27;解码内容&#x27;.decode(&#x27;使用得编码表&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;吴枫&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;吴枫&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;\xe5\x90\xb4\xe6\x9e\xab&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;\xce\xe2\xb7\xe3&#x27;</span>.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="开-open（）"><a href="#开-open（）" class="headerlink" title="开-open（）"></a>开-open（）</h2><ul>
<li>绝对路径：<strong>绝对路径</strong>就是最完整的路径；将文件拖入VScode终端可以获得绝对路径</li>
<li>或者右键复制路劲</li>
<li>相对路径：指的就是【相对于当前文件夹】的路径</li>
<li>windows系统中\\来表示绝对路径，/表示相对路径</li>
<li><strong>格式：文件名=(‘路径’，’模式’，encoding=’utf-8’)</strong></li>
<li>sumlime text3要绝对路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\Ted\\Desktop\\test\\abc.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#将&#x27;\&#x27;替换成&#x27;\\&#x27;</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>)    <span class="comment">#相对路径</span></span><br><span class="line"><span class="comment">#相对路径也可以写成open(&#x27;./abc.txt&#x27;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>‘r’:表示以读得模式打开文件</li>
</ul>
<h3 id="模式汇总"><a href="#模式汇总" class="headerlink" title="模式汇总"></a>模式汇总</h3><div class="table-container">
<table>
<thead>
<tr>
<th>r(read，读)</th>
<th>r只读，指针在开头文件不存在则报错</th>
<th>rb二进制只读，其余同左</th>
<th>r+读写，其余同左</th>
<th>rb+二进制读写，其余同左</th>
</tr>
</thead>
<tbody>
<tr>
<td>w(write,写)</td>
<td>w只写，文件不存在则新建，存在则覆盖</td>
<td>wb二进制只写，其余同左</td>
<td>w+读写，其余同左</td>
<td>wb+二进制读写，其余同左</td>
</tr>
<tr>
<td>a(append,追加)</td>
<td>a追加,文件存在指针放在末尾,文件不存在则新建</td>
<td>ab二进制追加，其余同左</td>
<td>a+追加且可读,其余同左</td>
<td>ab+二进制追加，且可读，其余同左</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>‘wb’</strong>的模式，它的意思是以二进制的方式打开一个文件用于写入。因为图片和音频是以二进制的形式保存的，所以使用wb模式就好了</li>
</ul>
<h2 id="读-read（）"><a href="#读-read（）" class="headerlink" title="读-read（）"></a>读-read（）</h2><h3 id="直接读取"><a href="#直接读取" class="headerlink" title="直接读取"></a>直接读取</h3><p><strong>变量名=文件名.read()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#变量名=文件名.read()</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;/Users/Ted/Desktop/test/abc.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">filecontent = file1.read()      </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ile1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure>
<h3 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h3><ul>
<li>格式：<strong>变量名=文件名.readlines()</strong></li>
<li><strong>readlines()</strong> 会从txt文件取得一个列表，列表中的每个字符串就是文件中的每一行。而且每个字符串后面还有换行的<strong>\n</strong>符号。</li>
<li><strong>for循环</strong>来遍历这个列表</li>
</ul>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a><strong>字符串替换</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="string">&quot;aaacde&quot;</span></span><br><span class="line">a=i.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<h2 id="写-write"><a href="#写-write" class="headerlink" title="写-write()"></a>写-write()</h2><h3 id="‘w’模式"><a href="#‘w’模式" class="headerlink" title="‘w’模式"></a>‘w’模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)</span><br><span class="line">file1.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>‘w：表示写入文件’</li>
<li>参数为字符串</li>
<li>格式：<strong>文件名.write(‘内容’)</strong></li>
<li><strong>‘w’</strong>写入模式会给你暴力清空掉文件</li>
<li><strong>write()</strong>函数写入文本文件的也是字符串类型。</li>
<li>在<strong>‘w’</strong>和<strong>‘a’</strong>模式下，如果你打开的文件不存在，那么<strong>open()</strong>函数会自动帮你创建一个</li>
</ul>
<h3 id="‘a’模式"><a href="#‘a’模式" class="headerlink" title="‘a’模式"></a>‘a’模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line"><span class="comment">#以追加的方式打开文件abc.txt</span></span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;张无忌&#x27;写入文件file1</span></span><br><span class="line">file1.write(<span class="string">&#x27;宋青书\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;宋青书&#x27;写入文件file1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>追加模式：增加内容而不是覆盖原来的内容</li>
</ul>
<h2 id="关-close"><a href="#关-close" class="headerlink" title="关-close()"></a>关-close()</h2><ul>
<li>关闭文件</li>
<li>计算机能够打开的文件数量是有限制的，open()过多而不close()的话，就不能再打开文件了。</li>
<li>能保证写入的内容已经在文件里被保存好了。</li>
<li><strong>文件名.close</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure>
<h2 id="关键字with"><a href="#关键字with" class="headerlink" title="关键字with"></a>关键字with</h2><ul>
<li>为了避免打开文件后忘记关闭，占用资源或当不能确定关闭文件的恰当时机的时候，我们可以用到关键字with</li>
<li>格式：with open(‘文件地址’,’读写模式’) as 变量名:</li>
<li>后面编码：encoding=’utf-8’：如果要文件包括中文要加</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通写法</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用with关键字的写法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file1:</span><br><span class="line"><span class="comment">#with open(&#x27;文件地址&#x27;,&#x27;读写模式&#x27;,encoding=&#x27;utf-8&#x27;) as 变量名:</span></span><br><span class="line">    <span class="comment">#格式：冒号不能丢</span></span><br><span class="line">    file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">    <span class="comment">#格式：对文件的操作要缩进</span></span><br><span class="line">    <span class="comment">#格式：无需用close()关闭</span></span><br></pre></td></tr></table></figure>
<h2 id="split-分开字符串"><a href="#split-分开字符串" class="headerlink" title="split():分开字符串"></a>split():分开字符串</h2><ul>
<li>它会按空格把字符串里面的内容分开</li>
<li>最终组合成一个列表</li>
<li>格式：<strong>变量1=变量2.split()</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;score.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file_lines = file1.readlines()</span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_lines:   <span class="comment">#用for...in...把每一行的数据遍历  </span></span><br><span class="line">    data =i.split()    <span class="comment">#把字符串切分成更细的一个个的字符串</span></span><br><span class="line">    <span class="built_in">print</span>(data)        <span class="comment">#打印出来看看</span></span><br></pre></td></tr></table></figure>
<h2 id="join-合并字符串"><a href="#join-合并字符串" class="headerlink" title="join():合并字符串"></a>join():合并字符串</h2><ul>
<li>格式：<strong>a.join(b)</strong></li>
<li>a：用什么连接</li>
<li>b：要组合字符串的列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span>]</span><br><span class="line">b=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b.join(a))</span><br><span class="line">c=<span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(c.join(a))</span><br></pre></td></tr></table></figure>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><h3 id="调用模块"><a href="#调用模块" class="headerlink" title="调用模块"></a>调用模块</h3><p>1、导入模块</p>
<ul>
<li>导入多个模块时：比如<strong>import a,b,c</strong>可以同时导入“a.py，b.py，c.py”三个文件</li>
</ul>
<p>2、调用模块时：</p>
<ul>
<li>使用“模块.函数()”调用模块中的函数</li>
<li>使用“模块.变量”调用模块中的变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是主程序main.py</span></span><br><span class="line"><span class="comment"># 请阅读代码注释</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test  <span class="comment"># 导入test模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test.a)  <span class="comment"># 使用“模块.变量”调用模块中的变量</span></span><br><span class="line"></span><br><span class="line">test.hi()  <span class="comment"># 使用“模块.函数()”调用模块中的函数</span></span><br><span class="line"></span><br><span class="line">A = test.Go2()  <span class="comment"># 使用“变量 = 模块.类()”实例化模块中的类</span></span><br><span class="line"><span class="built_in">print</span>(A.a)  <span class="comment"># 实例化后，不再需要“模块.”</span></span><br><span class="line">A.do2()  <span class="comment"># 实例化后，不再需要“模块.”</span></span><br></pre></td></tr></table></figure>
<h3 id="import…as"><a href="#import…as" class="headerlink" title="import…as.."></a>import…as..</h3><ul>
<li><strong>import story as s</strong>语句，意思是为“story”取个别名为“s”</li>
</ul>
<h2 id="from-…-import-…-语句"><a href="#from-…-import-…-语句" class="headerlink" title="from … import … 语句"></a>from … import … 语句</h2><ul>
<li>从模块中导入一个指定的部分到当前模块</li>
<li>格式：<strong>from (模块名) import(指定模块中的变量名/函数名/类名)</strong></li>
<li>效果：导入指定部分可以<strong>直接使用</strong>，不需要加入‘模块.’前缀</li>
<li>同模块多个指定内容：<strong>from xx模块 import a,b,c</strong></li>
<li>模块中指定所用内容分直接使用：<strong>from xx模块 import * </strong>;*代表“模块中所有的变量、函数、类</li>
</ul>
<h2 id="if-name-‘main‘"><a href="#if-name-‘main‘" class="headerlink" title="if name == ‘main‘"></a>if <strong>name</strong> == ‘<strong>main</strong>‘</h2><ul>
<li>Python 模拟的程序入口</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#xx.py文件</span></span><br><span class="line">代码块<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">if</span> _name_ == <span class="string">&#x27;_main_&#x27;</span>:</span><br><span class="line">    代码块<span class="number">2.</span>..</span><br><span class="line"><span class="comment">#1、当xx.py文件被直接运行时，代码模块2将被运行</span></span><br><span class="line"><span class="comment">#2、当xx.py文件作为模块是被其他程序导入时，代码模块2不被执行</span></span><br></pre></td></tr></table></figure>
<h1 id="scv模块"><a href="#scv模块" class="headerlink" title="scv模块"></a>scv模块</h1><ul>
<li><a href="https://yiyibooks.cn/xx/python_352/library/csv.html#module-csv">官方文档</a>：看示例</li>
<li>注意;创建的excel文档是csv格式，另存</li>
</ul>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><ul>
<li><h1 id="参数encoding-‘utf-8’防止出现乱码；一般有中文要加-报错就删或者加"><a href="#参数encoding-‘utf-8’防止出现乱码；一般有中文要加-报错就删或者加" class="headerlink" title="参数encoding = ‘utf-8’防止出现乱码；一般有中文要加;报错就删或者加"></a>参数encoding = ‘utf-8’防止出现乱码；一般有中文要加;报错就删或者加</h1></li>
</ul>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\win10\\Desktop\\code\\.vscode\\python.csv&quot;</span>,newline = <span class="string">&#x27;&#x27;</span>)  <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    <span class="comment">#使用csv的reader()方法，创建一个reader对象</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader: </span><br><span class="line">    <span class="comment">#遍历reader对象的每一行</span></span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;读取完毕！&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\win10\\Desktop\\code\\.vscode\\python.csv&quot;</span>,<span class="string">&#x27;a&#x27;</span>,newline = <span class="string">&#x27;&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="keyword">as</span> f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    writer.writerow([<span class="number">832</span>,<span class="number">134</span>,<span class="number">1</span>,<span class="number">35</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>4.无处不在的抉择——C语言</title>
    <url>/blot.github.io/2022/03/03/4%E3%80%81%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E6%8A%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="四、无处不在的抉择"><a href="#四、无处不在的抉择" class="headerlink" title="四、无处不在的抉择"></a>四、无处不在的抉择</h1><h2 id="关系运算符与逻辑运算符"><a href="#关系运算符与逻辑运算符" class="headerlink" title="关系运算符与逻辑运算符"></a>关系运算符与逻辑运算符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242252.png" alt="image-20210803224119840"></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>&amp;&amp;</th>
<th>与：当2个操作数都为真结果为真</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>或：两个操作数至少一个为真结果为真</td>
</tr>
<tr>
<td>！</td>
<td>非：操作数为真结果为假</td>
</tr>
</tbody>
</table>
</div>
<p>短路特性</p>
<ul>
<li>表达式的值可先有计算的左操作数的值推导出来，就不会计算右操作数的值</li>
<li>可以使除0运算不发生</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul>
<li>逻辑非   &gt;   算数运算符   &gt;   关系运算符   &gt;   逻辑与   &gt;   逻辑或</li>
<li>也可以通过添加小括号提高优先级</li>
</ul>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="单分支选择结构（if语句）"><a href="#单分支选择结构（if语句）" class="headerlink" title="单分支选择结构（if语句）"></a>单分支选择结构（if语句）</h3><ul>
<li>结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式P)</span><br><span class="line">	语句A</span><br></pre></td></tr></table></figure>
<h3 id="双分支结构（if-else）"><a href="#双分支结构（if-else）" class="headerlink" title="双分支结构（if-else）"></a>双分支结构（if-else）</h3><pre><code>if(表达式P)
&#123;
    语句A
&#125;
else
&#123;
    语句B
&#125;
</code></pre><ul>
<li>用花括号内可以表达多个语句</li>
</ul>
<h3 id="多分支结构（else-if）"><a href="#多分支结构（else-if）" class="headerlink" title="多分支结构（else-if）"></a>多分支结构（else-if）</h3><pre><code>if(表达式1)
&#123;
    语句A
&#125;
else if(表达式2)
&#123;
    语句B
&#125;
else
&#123;
    语句C
&#125;
</code></pre><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><ul>
<li>表达式1？表达式2：表达式3；</li>
<li>含义：表达式1为真时，输出表达式2的值，否则输出表达式3的值</li>
</ul>
<h2 id="开关语句"><a href="#开关语句" class="headerlink" title="开关语句"></a>开关语句</h2><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)<span class="comment">//表达式是int型或char型</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">	语句序列<span class="number">1</span>；</span><br><span class="line">	<span class="keyword">break</span>;<span class="comment">//break跳出switch语句结构</span></span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">	语句序列<span class="number">2</span>；</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">default</span>:<span class="comment">//上面case都不能执行时，执行这个语句</span></span><br><span class="line">	语句序列n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数值溢出和损失问题"><a href="#数值溢出和损失问题" class="headerlink" title="数值溢出和损失问题"></a>数值溢出和损失问题</h2><h3 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h3><ul>
<li>自动类型转换会发生的问题</li>
<li>取值范围大的类型转换成取值范围小的类型发生数值溢出</li>
<li>类型表数范围有限</li>
</ul>
<h4 id="整数的数值溢出"><a href="#整数的数值溢出" class="headerlink" title="整数的数值溢出"></a>整数的数值溢出</h4><p><strong>上溢出</strong></p>
<ul>
<li>一个数值运算结&gt;类型能表示的最大数</li>
<li>进位超过最高位发生进位丢失</li>
<li>进位达到最高位改变符号位</li>
</ul>
<h4 id="浮点数的数值溢出"><a href="#浮点数的数值溢出" class="headerlink" title="浮点数的数值溢出"></a>浮点数的数值溢出</h4><p><strong>上溢出</strong></p>
<ul>
<li>浮点数运算结果&gt;类型能表示的最大数</li>
</ul>
<p><strong>下溢出</strong></p>
<ul>
<li>浮点数运算结构&lt;类型能表示的最小数</li>
</ul>
<h3 id="精度损失"><a href="#精度损失" class="headerlink" title="精度损失"></a>精度损失</h3><ul>
<li>高精度向低精度转换时发生精度损失</li>
<li>float到int(丢失小数部分)</li>
<li>二进制小数与十进制小数之间很多不是一一对应的关系</li>
<li>float能表示的有效数字为7位，double能表示的有效数字为16位</li>
</ul>
<p>用raptor绘制选择结构流程图</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>5.循环控制——C语言</title>
    <url>/blot.github.io/2022/03/03/5%E3%80%81%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="五、循环控制"><a href="#五、循环控制" class="headerlink" title="五、循环控制"></a>五、循环控制</h1><h2 id="计数控制循环"><a href="#计数控制循环" class="headerlink" title="计数控制循环"></a>计数控制循环</h2><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><ul>
<li>主要用于计数循环</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)<span class="comment">//表达式1初始条件，表达式2控制条件，表达式3转换条件</span></span><br><span class="line">&#123;</span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line">	语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行顺序：表达式1，表达式2，语句,表达式3</span></span><br></pre></td></tr></table></figure>
<p>逗号运算符</p>
<p>表达式1，表达式2，…，表达式n</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>,表达式n;表达式<span class="number">2</span>;表达式<span class="number">3</span>,表达式m)<span class="comment">//逗号表达式主要用在循环语句中，同时对多个变量赋初值</span></span><br><span class="line">&#123;</span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line">	语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while和do while语句</p>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">表达式<span class="number">1</span>；<span class="comment">//表达式1循环初始条件</span></span><br><span class="line"><span class="keyword">while</span>(表达式<span class="number">2</span>)<span class="comment">//表达式2循环控制条件</span></span><br><span class="line">&#123;</span><br><span class="line">	语句;</span><br><span class="line">	表达式<span class="number">3</span>；<span class="comment">//表达式3循环转换条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行顺序：从上往下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当型循环</li>
<li>循环次数已知</li>
</ul>
<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">表达式<span class="number">1</span>；<span class="comment">//表达式1循环初始条件</span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		语句；</span><br><span class="line">		表达式<span class="number">3</span>；<span class="comment">//表达式3循环转换条件</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(表达式<span class="number">2</span>)；<span class="comment">//表达式2循环控制条件,表达式成立时继续循环</span></span><br></pre></td></tr></table></figure>
<ul>
<li>循环至少执行一次</li>
<li>直到型循环</li>
<li>循环次数可以不已知</li>
</ul>
<p><strong>选择循环语句一般原则</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>循环次数已知</th>
<th>for语句</th>
</tr>
</thead>
<tbody>
<tr>
<td>循环次数未知，循环次数由一个给定条件控制</td>
<td>while语句和do-while语句</td>
</tr>
<tr>
<td>循环体至少执行一次</td>
<td>do-while语句</td>
</tr>
</tbody>
</table>
</div>
<h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><ol>
<li>正向递推</li>
<li>反向逆推</li>
</ol>
<h2 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h2><ul>
<li><p>列举所有的可能，逐一试探</p>
</li>
<li><p>根据问题的部分已知条件预估解的范围</p>
</li>
<li>直到找到满足已知条件的解为止</li>
</ul>
<p>goto语句</p>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><h3 id="程序常见错误"><a href="#程序常见错误" class="headerlink" title="程序常见错误"></a>程序常见错误</h3><ol>
<li>编译错误：语法错误</li>
<li>链接错误：缺少包含文件等</li>
<li>运行时错误：运行结果出错</li>
</ol>
<h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><ol>
<li>逆向推理：定位大致范围</li>
<li>分治排除：用注释切掉一些代码，调试无误打开</li>
<li>缩减输入：缩减输入数据</li>
</ol>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>6.函数——C语言</title>
    <url>/blot.github.io/2022/03/03/6%E3%80%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><ul>
<li>函数：构成C语言的基本模块</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数返回值类型 函数名(形参)</span><br><span class="line">&#123;</span><br><span class="line">	函数体；</span><br><span class="line">	<span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetMax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//形参也是局部变量</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  result;<span class="comment">//局部变量，只能在函数体内访问啊它</span></span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)</span><br><span class="line">	&#123;</span><br><span class="line">		result = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		result = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;<span class="comment">//函数的出口，只能返回一个值；要与返回值类型一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMax</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//表示无返回值省略默认为int;后面表示无参数可省略,明确告诉编译器不需要从外界接受数据</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  result,x,y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,x,y)</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)</span><br><span class="line">		result = x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		result = y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, result);</span><br><span class="line">	<span class="keyword">return</span> ;<span class="comment">//没有return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h2><ol>
<li>主调函数通过函数名调用被调函数</li>
<li>函数无返回值时，单独作为一个函数调用语句</li>
</ol>
<ul>
<li>函数定义的参数称为形式参数</li>
<li>函数调用的参数称为实际参数</li>
<li>实参和形参的位置一一对应</li>
</ul>
<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><p><strong>合并成完整程序</strong></p>
<h2 id="1-函数定义放在函数调用前"><a href="#1-函数定义放在函数调用前" class="headerlink" title="1.函数定义放在函数调用前"></a>1.函数定义放在函数调用前</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = (x+y)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,ave;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	ave = Average(a,b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ave);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-函数定义放在函数调用后"><a href="#2-函数定义放在函数调用后" class="headerlink" title="2.函数定义放在函数调用后"></a>2.函数定义放在函数调用后</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,ave;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	ave = Average(a,b);<span class="comment">//调用函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ave);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = (x+y)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数设计原则"><a href="#函数设计原则" class="headerlink" title="函数设计原则"></a>函数设计原则</h3><ol>
<li>函数规模小</li>
<li>函数功能单一</li>
<li>函数接口定义要清楚</li>
</ol>
<h1 id="断言与防御性程序设计"><a href="#断言与防御性程序设计" class="headerlink" title="断言与防御性程序设计"></a>断言与防御性程序设计</h1><h2 id="断言：assert"><a href="#断言：assert" class="headerlink" title="断言：assert"></a>断言：assert</h2><ul>
<li>测试程序中假设的正确性</li>
<li>如果假设被违反，则中断程序执行</li>
<li>程序开头要加#include<assert.h>———-他是在<assert.h>中定义的宏</li>
<li>仅用于调试，不能作为程序功能</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Iput m(m&gt;0):\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	&#125;<span class="keyword">while</span>(m &lt;= <span class="number">0</span>);</span><br><span class="line">	assert(m &gt;= <span class="number">0</span>);<span class="comment">//为假时，终止程序</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d != %lu\n&quot;</span>,m,Fact(m));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		result *= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="好代码风格"><a href="#好代码风格" class="headerlink" title="好代码风格"></a>好代码风格</h2><h3 id="1-代码行内空格"><a href="#1-代码行内空格" class="headerlink" title="1.代码行内空格"></a>1.代码行内空格</h3><ul>
<li>赋值、算数、关系、逻辑等二元运算符前后各加一个空格</li>
<li>关键字之后加空格</li>
</ul>
<h3 id="2-空行——-隔程序段落的作用"><a href="#2-空行——-隔程序段落的作用" class="headerlink" title="2.空行——-隔程序段落的作用"></a>2.空行——-隔程序段落的作用</h3><ul>
<li>灭个函数定义之后加空行</li>
<li>一个函数体内，相邻两组密切相关的语句之间加空格，语句块内不加空格</li>
</ul>
<h3 id="3-对齐"><a href="#3-对齐" class="headerlink" title="3.对齐"></a>3.对齐</h3><h3 id="4-命名"><a href="#4-命名" class="headerlink" title="4.命名"></a>4.命名</h3><ul>
<li>变量名形式：小写字母开头</li>
<li>函数名形式：大写字母开头</li>
<li>宏和const常量全用大写字母，并用下划线分割单词</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h1 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h1><ul>
<li>函数不能嵌套定义</li>
<li>但可以嵌套调用</li>
</ul>
<p>求组合数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">Comb</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> k)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m,k;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Iput m,k(m&gt;=k&gt;0):\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">	&#125;<span class="keyword">while</span>(m&lt;k || m&lt;<span class="number">0</span> || k&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,Comb(m,k) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">Comb</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> k)</span><span class="comment">//计算组合数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Fact(m)/(Fact(k)*Fact(m-k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//计算阶乘</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		result *= i; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数递归调用"><a href="#函数递归调用" class="headerlink" title="函数递归调用"></a>函数递归调用</h2><ul>
<li>递归调用：函数直接或者间接调用自己———递归函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n*Fact(n<span class="number">-1</span>);<span class="comment">//调用自己</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h2><ol>
<li>数学定义是递归：计算阶乘、最大公约数和数列等</li>
<li>数据结构是递归：队列、链表等</li>
<li>问题解法是递归的</li>
</ol>
<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><ol>
<li>数学归纳法</li>
<li>将n个圆盘看作1个和n-1个圆盘</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span>,<span class="type">char</span> b,<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Move</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input the number of disks:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;steps of moving %d disks from A to B by means of C:\n&quot;</span>,n);</span><br><span class="line">	Hanoi(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Move(n,a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Hanoi(n<span class="number">-1</span>,a,c,b);<span class="comment">//将n-1个圆盘从A移到C</span></span><br><span class="line">		Move(n,a,b);<span class="comment">//将第n个圆盘从A移到B</span></span><br><span class="line">		Hanoi(n<span class="number">-1</span>,c,b,a);<span class="comment">//将上面n-1个圆盘从C移到B</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Move</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Move %d:从%c移到%c\n&quot;</span>,n,a,b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归执行2个阶段"><a href="#递归执行2个阶段" class="headerlink" title="递归执行2个阶段"></a>递归执行2个阶段</h3><ul>
<li>递推阶段：有终止条件</li>
<li>回归阶段</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>;<span class="comment">//计算阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%u的阶乘为%u&quot;</span>,n,Fact(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n*Fact(n<span class="number">-1</span>);<span class="comment">//F（n-1）是递推阶段，return n*Fact(n-1)为回归阶段</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C程序的内存映像"><a href="#C程序的内存映像" class="headerlink" title="C程序的内存映像"></a>C程序的内存映像</h3><p>只读存储区：代码区、常量存储区（内存低地址端）</p>
<p>静态存储区</p>
<p>动态存储区：</p>
<ul>
<li><p>堆：从内存低地址向内存高地址端进行扩展</p>
</li>
<li><p>栈：从内存高地址向内存低地址端进行扩展</p>
</li>
<li>堆栈溢出：往堆栈中存入的数据超过预先给堆栈分配的容量</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242957.png" alt="image-20210815100547318"></p>
<h3 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h3><ul>
<li>优点：结构清晰、易懂等</li>
<li>缺点：调用开销大。耗费更多时间和栈空间</li>
</ul>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> a)</span>;<span class="comment">//计算阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%u的阶乘为%u&quot;</span>,n,Fact(n,<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Fact(n<span class="number">-1</span>,n*a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回归时不需要任何操作</li>
</ul>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><ul>
<li>变量的作用范围</li>
</ul>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li>在语句块内定义（函数、复合语句）的变量</li>
<li>只能在语句块内使用</li>
<li>作用域较小的局部变量隐藏作用域较大的局部变量</li>
<li>函数内定义的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y=<span class="number">2</span>;</span><br><span class="line">		x=<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );<span class="comment">//y为复合语句定义的y</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在大花括号定义的只能在花括号内使用</span></span><br><span class="line"><span class="comment">//作用域较小的局部变量隐藏作用域较大的局部变量</span></span><br></pre></td></tr></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul>
<li>在函数之外定义的变量</li>
<li>作用范围：定义变量的位置开始到程序结束</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部变量和全局变量同名时</p>
<ul>
<li>局部变量隐藏全局变量，互不干扰</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">3</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Fun();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );<span class="comment">//全局变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">2</span>,y=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );<span class="comment">//局部变量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="变量存储类型"><a href="#变量存储类型" class="headerlink" title="变量存储类型"></a>变量存储类型</h2><h3 id="C程序的内存映像-1"><a href="#C程序的内存映像-1" class="headerlink" title="C程序的内存映像"></a>C程序的内存映像</h3><p>只读存储区：代码区、常量存储区（内存低地址端）</p>
<p>静态存储区：存放程序中全局变量和静态变量等；静态发生在程序编译时</p>
<p>动态存储区：</p>
<ul>
<li>堆：从内存低地址向内存高地址端进行扩展</li>
<li>栈：从内存高地址向内存低地址端进行扩展；用于保存函数 调用时的返回地址、函数形参、局部变量等信息</li>
<li>堆栈溢出：往堆栈中存入的数据超过预先给堆栈分配的容量</li>
<li>动态发生在程序载入和运行时</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242268.png" alt="image-20210815100547318"></p>
<ul>
<li>存储类型决定变量的生存期<ul>
<li>静态存储区变量，全程占据内存</li>
<li>动态存储区变量，生存期与语句块共存亡</li>
</ul>
</li>
</ul>
<h4 id="声明变量存储类型"><a href="#声明变量存储类型" class="headerlink" title="声明变量存储类型"></a>声明变量存储类型</h4><ul>
<li>格式：存储类型    数据类型    变量名；</li>
<li>存储类型关键字<ul>
<li>auto:自动变量</li>
<li>static:静态变量</li>
<li>extern：外部变量——全局变量</li>
<li>register:寄存器变量</li>
</ul>
</li>
</ul>
<h1 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h1><ol>
<li>静态全局变量<ul>
<li>使用：全局变量前加static，修饰全局变量为静态全局变量。</li>
<li>作用：改变全局变量的可见性。静态全局变量的存储位置在静态存储区，未被初始化的静态全局变量会被自动初始化为0。静态全局变量在声明它的文件之外是不可见的，仅在从定义该变量的开始位置到文件结尾可见。</li>
</ul>
</li>
<li>静态局部变量<ul>
<li>使用：局部变量前加static，修饰局部变量为静态局部变量。</li>
<li>作用：改变局部变量的销毁时期。静态局部变量的作用域和局部变量的作用域一样，当定义它的函数或语句块结束的时候，作用域结束。不同的是，静态局部变量存储在静态存储区，当静态局部变量离开作用域后，并没有被销毁。当该函数再次被调用的时候，该变量的值为上次函数调用结束时的值。</li>
</ul>
</li>
<li>静态函数<ul>
<li>使用：函数返回类型前加static，修饰函数为静态函数。</li>
<li>作用：改变函数的可见性。函数的定义和声明在默认情况下都是extern的，但静态函数只在声明它的文件中可见，不能被其他文件使用。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>5.python基础自动画办公</title>
    <url>/blot.github.io/2022/04/03/5%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/</url>
    <content><![CDATA[<h1 id="自动化办公"><a href="#自动化办公" class="headerlink" title="自动化办公"></a>自动化办公</h1><h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="开-open（）"><a href="#开-open（）" class="headerlink" title="开-open（）"></a>开-open（）</h2><ul>
<li>绝对路径：<strong>绝对路径</strong>就是最完整的路径；将文件拖入VScode终端可以获得绝对路径</li>
<li>或者右键复制路劲</li>
<li>相对路径：指的就是【相对于当前文件夹】的路径</li>
<li>windows系统中\\来表示绝对路径，/表示相对路径</li>
<li><strong>格式：文件名=(‘路径’，’模式’，encoding=’utf-8’)</strong></li>
<li>sumlime text3要绝对路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\Ted\\Desktop\\test\\abc.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#将&#x27;\&#x27;替换成&#x27;\\&#x27;</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>)    <span class="comment">#相对路径</span></span><br><span class="line"><span class="comment">#相对路径也可以写成open(&#x27;./abc.txt&#x27;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>‘r’:表示以读得模式打开文件</li>
</ul>
<h3 id="模式汇总"><a href="#模式汇总" class="headerlink" title="模式汇总"></a>模式汇总</h3><div class="table-container">
<table>
<thead>
<tr>
<th>r(read，读)</th>
<th>r只读，指针在开头文件不存在则报错</th>
<th>rb二进制只读，其余同左</th>
<th>r+读写，其余同左</th>
<th>rb+二进制读写，其余同左</th>
</tr>
</thead>
<tbody>
<tr>
<td>w(write,写)</td>
<td>w只写，文件不存在则新建，存在则覆盖</td>
<td>wb二进制只写，其余同左</td>
<td>w+读写，其余同左</td>
<td>wb+二进制读写，其余同左</td>
</tr>
<tr>
<td>a(append,追加)</td>
<td>a追加,文件存在指针放在末尾,文件不存在则新建</td>
<td>ab二进制追加，其余同左</td>
<td>a+追加且可读,其余同左</td>
<td>ab+二进制追加，且可读，其余同左</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>‘wb’</strong>的模式，它的意思是以二进制的方式打开一个文件用于写入。因为图片和音频是以二进制的形式保存的，所以使用wb模式就好了</li>
</ul>
<h2 id="读-read（）"><a href="#读-read（）" class="headerlink" title="读-read（）"></a>读-read（）</h2><h3 id="直接读取"><a href="#直接读取" class="headerlink" title="直接读取"></a>直接读取</h3><p><strong>变量名=文件名.read()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#变量名=文件名.read()</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;/Users/Ted/Desktop/test/abc.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">filecontent = file1.read()      </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ile1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure>
<h3 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h3><ul>
<li>格式：<strong>变量名=文件名.readlines()</strong></li>
<li><strong>readlines()</strong> 会从txt文件取得一个列表，列表中的每个字符串就是文件中的每一行。而且每个字符串后面还有换行的<strong>\n</strong>符号。</li>
<li><strong>for循环</strong>来遍历这个列表</li>
</ul>
<h2 id="写-write"><a href="#写-write" class="headerlink" title="写-write()"></a>写-write()</h2><h3 id="‘w’模式"><a href="#‘w’模式" class="headerlink" title="‘w’模式"></a>‘w’模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)</span><br><span class="line">file1.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>‘w：表示写入文件’</li>
<li>参数为字符串</li>
<li>格式：<strong>文件名.write(‘内容’)</strong></li>
<li><strong>‘w’</strong>写入模式会给你暴力清空掉文件</li>
<li><strong>write()</strong>函数写入文本文件的也是字符串类型。</li>
<li>在<strong>‘w’</strong>和<strong>‘a’</strong>模式下，如果你打开的文件不存在，那么<strong>open()</strong>函数会自动帮你创建一个</li>
</ul>
<h3 id="‘a’模式"><a href="#‘a’模式" class="headerlink" title="‘a’模式"></a>‘a’模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line"><span class="comment">#以追加的方式打开文件abc.txt</span></span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;张无忌&#x27;写入文件file1</span></span><br><span class="line">file1.write(<span class="string">&#x27;宋青书\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;宋青书&#x27;写入文件file1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>追加模式：增加内容而不是覆盖原来的内容</li>
</ul>
<h2 id="关-close"><a href="#关-close" class="headerlink" title="关-close()"></a>关-close()</h2><ul>
<li>关闭文件</li>
<li>计算机能够打开的文件数量是有限制的，open()过多而不close()的话，就不能再打开文件了。</li>
<li>能保证写入的内容已经在文件里被保存好了。</li>
<li><strong>文件名.close</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure>
<h2 id="关键字with"><a href="#关键字with" class="headerlink" title="关键字with"></a>关键字with</h2><ul>
<li>为了避免打开文件后忘记关闭，占用资源或当不能确定关闭文件的恰当时机的时候，我们可以用到关键字with</li>
<li>格式：with open(‘文件地址’,’读写模式’) as 变量名:</li>
<li>后面编码：encoding=’utf-8’：如果要文件包括中文要加</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通写法</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用with关键字的写法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file1:</span><br><span class="line"><span class="comment">#with open(&#x27;文件地址&#x27;,&#x27;读写模式&#x27;,encoding=&#x27;utf-8&#x27;) as 变量名:</span></span><br><span class="line">    <span class="comment">#格式：冒号不能丢</span></span><br><span class="line">    file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">    <span class="comment">#格式：对文件的操作要缩进</span></span><br><span class="line">    <span class="comment">#格式：无需用close()关闭</span></span><br></pre></td></tr></table></figure>
<h2 id="split-分开字符串"><a href="#split-分开字符串" class="headerlink" title="split():分开字符串"></a>split():分开字符串</h2><ul>
<li>它会按空格把字符串里面的内容分开</li>
<li>最终组合成一个列表</li>
<li>格式：<strong>变量1=变量2.split()</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;score.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file_lines = file1.readlines()</span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_lines:   <span class="comment">#用for...in...把每一行的数据遍历  </span></span><br><span class="line">    data =i.split()    <span class="comment">#把字符串切分成更细的一个个的字符串</span></span><br><span class="line">    <span class="built_in">print</span>(data)        <span class="comment">#打印出来看看</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">&quot;abc abc\ndef\t&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string.split())</span><br><span class="line">打印结果：[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h1 id="scv模块"><a href="#scv模块" class="headerlink" title="scv模块"></a>scv模块</h1><ul>
<li><a href="https://yiyibooks.cn/xx/python_352/library/csv.html#module-csv">官方文档</a>：看示例</li>
<li>注意;创建的excel文档是csv格式，另存</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li><h1 id="参数encoding-‘utf-8’防止出现乱码；一般有中文要加-报错就删或者加"><a href="#参数encoding-‘utf-8’防止出现乱码；一般有中文要加-报错就删或者加" class="headerlink" title="参数encoding = ‘utf-8’防止出现乱码；一般有中文要加;报错就删或者加"></a>参数encoding = ‘utf-8’防止出现乱码；一般有中文要加;报错就删或者加</h1></li>
</ul>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><h4 id="reader"><a href="#reader" class="headerlink" title="reader()"></a>reader()</h4><ul>
<li>读取的是列表格式</li>
<li>用于读取一般的csv文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\win10\\Desktop\\code\\.vscode\\python.csv&quot;</span>,newline = <span class="string">&#x27;&#x27;</span>)  <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    <span class="comment">#使用csv的reader()方法，创建一个reader对象</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader: </span><br><span class="line">    <span class="comment">#遍历reader对象的每一行</span></span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;读取完毕！&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>row：单元格所在行</li>
</ul>
<h5 id="相对路径说明"><a href="#相对路径说明" class="headerlink" title="相对路径说明"></a>相对路径说明</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">practice_wb = load_workbook(<span class="string">&#x27;./material/practice0.xlsx&#x27;</span>)<span class="comment">#material和py文件在同一目录文件夹，注意前面要加./代表同目录</span></span><br></pre></td></tr></table></figure>
<h4 id="DictReader类"><a href="#DictReader类" class="headerlink" title="DictReader类"></a>DictReader类</h4><ul>
<li><code>DictReader</code>类的操作类似于常规的<code>reader()</code>，但<code>DictReader</code>会将读取到的信息转换为字典形式</li>
<li>实例化<code>DictReader</code>类后，会得到一个<code>DictReader对象</code>，这是一个可迭代对象，我们可以使用循环来遍历它的每一个元素。但不同于<code>reader()</code>的是，该对象里面的每一个元素都是一个<strong>字典</strong>，每一个<strong>字典的值</strong>都可以对应csv文件中的一行，<strong>键</strong>对应csv文件的表头</li>
<li>属性<strong>fieldnames</strong>，该属性可以将csv文件（表格）的表头（第一行）读取出来，返回值是<strong>列表</strong>。这个<strong>表头也就是字典的键</strong>(key)。</li>
<li>通常读取第一行为表头的csv文件。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 打开csv文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./DictReader_demo.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csv_file:</span><br><span class="line">    <span class="comment"># 将文件对象转换为DictReader对象</span></span><br><span class="line">    csv_reader = csv.DictReader(csv_file)</span><br><span class="line">    <span class="comment"># 获取表头</span></span><br><span class="line">    headers = csv_reader.fieldnames</span><br><span class="line">    <span class="comment"># 打印表头</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表头：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(headers))</span><br><span class="line">    <span class="comment"># 遍历DictReader对象</span></span><br><span class="line">    <span class="keyword">for</span> csv_row <span class="keyword">in</span> csv_reader:</span><br><span class="line">        <span class="comment"># 打印数据</span></span><br><span class="line">        <span class="built_in">print</span>(csv_row)</span><br></pre></td></tr></table></figure>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><h4 id="writer"><a href="#writer" class="headerlink" title="writer()"></a>writer()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">member_list = [</span><br><span class="line">    [<span class="string">&#x27;邱大仁&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;徐小刚&#x27;</span>, <span class="string">&#x27;陈知枫&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;王晴&#x27;</span>, <span class="string">&#x27;廖雨&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;writerow_demo.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 打开并创建&#x27;writerow_demo.csv&#x27;文件，注意参数的设置，获取文件对象</span></span><br><span class="line">    writer=csv.writer(file)<span class="comment"># 将文件对象转换为writer对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> member_list:<span class="comment"># 循环遍历列表中的元素</span></span><br><span class="line">        writer.writerow(i)<span class="comment"># 将列表中的元素写入csv文件中</span></span><br><span class="line">        <span class="comment">#csv_demo.writerows(member_list)等价for循环上面两个语句</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对象名.writerow(row)</strong>：要用for循环填入列表中</li>
<li><strong>对象名.writerows(row)</strong>：参数rows也是可迭代对象，可以理解为由多个row组成。</li>
</ul>
<h4 id="DictWriter"><a href="#DictWriter" class="headerlink" title="DictWriter"></a>DictWriter</h4><ul>
<li><code>DictWriter</code>的操作类似于常规的<code>writer()</code>，但<code>DictWriter</code>会将字典写入（映射）到csv文件的行中</li>
<li>写入的行为字典形式</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249587.png" alt="image-20210813221044806"></p>
<ul>
<li>必须要传入该参数。</li>
<li>我们需要将一个列表传给参数<code>fieldnames</code>，它的作用是设置csv文件的第一行数据（即表头数据）。当我们要将字典通过<code>DictWriter对象</code>写入csv文件时，通常会把字典的键(key)存入一个列表，再把这个列表传给参数<code>fieldnames</code>。</li>
</ul>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ol>
<li><code>writeheader()</code>，该方法可将表头（即字典中的键(key)）写入csv的第一行。也就是说，<strong>如果要写入表头，不仅要在DictWriter中传入参数fieldnames，还需要调用writeheader()方法</strong>。这点很重要，一定要记住。</li>
<li><code>writerow(row)</code>，与writer对象调用writerow(row)不同的是，这里的参数<code>row</code>必须是字典形式的数据。</li>
<li>在写入时，该方法会根据字典的键，找到相应的表头，然后再将此键对应的值写入表头对应的列。</li>
<li><strong>writeheader()</strong></li>
<li><strong>writerow（）</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">info_dict = &#123;<span class="string">&#x27;姓名&#x27;</span>: <span class="string">&#x27;徐小刚&#x27;</span>, <span class="string">&#x27;工号&#x27;</span>: <span class="string">&#x27;1005&#x27;</span>, <span class="string">&#x27;员工发展基金&#x27;</span>: <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;员工签字&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置表头</span></span><br><span class="line">headers = [<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;工号&#x27;</span>, <span class="string">&#x27;员工发展基金&#x27;</span>, <span class="string">&#x27;员工签字&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建并打开&#x27;./徐小刚信息.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./徐小刚信息.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> target_file:</span><br><span class="line">    <span class="comment"># 将文件对象转换为DictWriter对象</span></span><br><span class="line">    target_writer = csv.DictWriter(target_file, fieldnames=headers)<span class="comment">#fieldnames是表头传参</span></span><br><span class="line">    <span class="comment"># 写入表头</span></span><br><span class="line">    target_writer.writeheader()</span><br><span class="line">    <span class="comment"># 将字典写入csv文件</span></span><br><span class="line">    target_writer.writerow(info_dict)</span><br></pre></td></tr></table></figure>
<h1 id="快速获得文件名"><a href="#快速获得文件名" class="headerlink" title="快速获得文件名"></a>快速获得文件名</h1><h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><ul>
<li>操作系统模块，标准库</li>
<li>它常用于处理文件和目录（文件夹）的操作。例如删除文件、判断文件目录是否存在等功能。</li>
</ul>
<h4 id="自动创建文件"><a href="#自动创建文件" class="headerlink" title="自动创建文件"></a>自动创建文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 打开结果文件</span></span><br><span class="line">result_file = <span class="built_in">open</span>(<span class="string">&#x27;./result.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#如果文件名不存在则自动创建，否则就直接可以打开</span></span><br></pre></td></tr></table></figure>
<h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><ol>
<li>将图片png格式改为jpg格式</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dirName = <span class="string">&quot;C:\\Users\\win10\\Desktop\\图片\\&quot;</span>        <span class="comment"># 图片所在路径</span></span><br><span class="line"></span><br><span class="line">total_img = os.listdir(dirName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> total_img:                  <span class="comment"># 索引所有图像</span></span><br><span class="line">    newname = filename</span><br><span class="line">    newname = newname.split(<span class="string">&quot;.&quot;</span>)            <span class="comment"># 分离后缀</span></span><br><span class="line">    <span class="keyword">if</span> newname[-<span class="number">1</span>] == <span class="string">&quot;png&quot;</span>:                <span class="comment"># 假定原后缀为.png格式</span></span><br><span class="line">        newname[-<span class="number">1</span>] = <span class="string">&quot;jpg&quot;</span>                 <span class="comment"># 目标后缀为.jpg格式</span></span><br><span class="line">        newname = <span class="built_in">str</span>.join(<span class="string">&quot;.&quot;</span>, newname)    <span class="comment"># &#x27;.&#x27;与后缀名称相连接</span></span><br><span class="line">        filename = dirName + filename       <span class="comment"># 原始图片路径+名称</span></span><br><span class="line">        newname = dirName + newname         <span class="comment"># 新的图像路径+名称</span></span><br><span class="line">        os.rename(filename, newname)        <span class="comment"># 重命名</span></span><br><span class="line">        <span class="built_in">print</span>(newname, <span class="string">&quot;图片格式修改成功&quot;</span>)</span><br><span class="line"><span class="comment">#将png格式修改为jpg格式</span></span><br></pre></td></tr></table></figure>
<h3 id="listdir-函数"><a href="#listdir-函数" class="headerlink" title="listdir(函数)"></a>listdir(函数)</h3><ul>
<li>格式：<strong>变量名=os.listdir(路径)</strong><br>目的：将某文件夹中，所有<strong>文件夹名</strong>和<strong>文件名</strong>获取到</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;文件夹路径&#x27;</span></span><br><span class="line">filenames = os.listdir(path)</span><br><span class="line"><span class="built_in">print</span>(filenames)<span class="comment">#输出为列表格式</span></span><br></pre></td></tr></table></figure>
<h2 id="保存网页图片"><a href="#保存网页图片" class="headerlink" title="保存网页图片"></a>保存网页图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">img_src=<span class="string">&#x27;http://sm-wick-question.oss-cn-zhangjiakou.aliyuncs.com/QuestionAnswerImage/521422ccc14b47ef94adc9d0f5240451-11-question.jpg&#x27;</span></span><br><span class="line">response = requests.get(img_src)</span><br><span class="line">image = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line">image.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\9.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="添加表格信息"><a href="#添加表格信息" class="headerlink" title="添加表格信息"></a>添加表格信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">question</span>(<span class="params">s</span>):</span><br><span class="line">    j=<span class="number">0</span></span><br><span class="line">    s=<span class="built_in">list</span>(s)</span><br><span class="line">    s[s.index(<span class="string">&#x27;q&#x27;</span>)]=<span class="string">&#x27;a&#x27;</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span>.join(s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">url_img</span>(<span class="params">scr,path_name</span>):</span><br><span class="line">    response = requests.get(scr)</span><br><span class="line">    image = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line">    <span class="built_in">print</span>(path_name+<span class="string">&quot; 保存成功&quot;</span>)</span><br><span class="line">    image.save(path_name)</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;C:\\Users\\win10\\Desktop\\课程\\微机原理\\&#x27;</span></span><br><span class="line">filenames = os.listdir(path)</span><br><span class="line">new_path=path+<span class="built_in">str</span>(filenames[<span class="number">0</span>])</span><br><span class="line">img_path=<span class="string">&#x27;C:\\Users\\win10\\Desktop\\课程\\pic\\&#x27;</span></span><br><span class="line">staff_wb = load_workbook(new_path)</span><br><span class="line"></span><br><span class="line">staff_ws = staff_wb.active</span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">new_ws = new_wb.active</span><br><span class="line"><span class="comment">#获取名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row,name1 <span class="keyword">in</span> <span class="built_in">zip</span>(staff_ws.iter_rows( max_row=<span class="number">2000</span>, values_only=<span class="literal">True</span>),staff_ws[<span class="string">&#x27;H&#x27;</span>]):</span><br><span class="line">    <span class="comment"># 将数据写入新的工作表</span></span><br><span class="line">    <span class="keyword">if</span>(name1.value==<span class="string">&quot;王俊林&quot;</span>):</span><br><span class="line">        row=<span class="built_in">list</span>(row)</span><br><span class="line">        img_path1=img_path+row[<span class="number">2</span>]+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        url_img(row[<span class="number">3</span>],img_path1)</span><br><span class="line">        row.insert(<span class="number">8</span>,question(row[<span class="number">2</span>]))</span><br><span class="line">        new_ws.append(row)</span><br><span class="line">new_wb.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\表格.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成成功&quot;</span>)</span><br><span class="line"><span class="comment">#读取有王俊林表格的整个信息，并保存到一个表格中</span></span><br></pre></td></tr></table></figure>
<h2 id="文件筛选"><a href="#文件筛选" class="headerlink" title="文件筛选"></a>文件筛选</h2><p>流程</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249425.png" alt="image-20210812211800776"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件夹路径，获取文件夹下的所有文件名</span></span><br><span class="line">path = <span class="string">&#x27;./工作文件夹/&#x27;</span></span><br><span class="line">files_list = os.listdir(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置需要查找的关键词</span></span><br><span class="line">key_word = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的关键词：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开结果文件</span></span><br><span class="line">result_file = <span class="built_in">open</span>(<span class="string">&#x27;./result.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环处理每一个文件</span></span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> files_list:</span><br><span class="line">    <span class="comment"># 判断文件类型是否在文件名中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.txt&#x27;</span> <span class="keyword">in</span> file_name:</span><br><span class="line">        <span class="comment"># 找到文件时先打印提示</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到了文件：&quot;</span> + file_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将文件夹路径和文件名拼接成该文件的相对路径</span></span><br><span class="line">        target_file = path + file_name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开文件，读取文件内容，然后关闭文件</span></span><br><span class="line">        file = <span class="built_in">open</span>(target_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        content = file.read()</span><br><span class="line">        file.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断关键词是否在文件内容中</span></span><br><span class="line">        <span class="keyword">if</span> key_word <span class="keyword">in</span> content:</span><br><span class="line">            <span class="comment"># 匹配到关键词时先打印提示</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;妙啊，文件**&#123;&#125;**包含了关键词：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(target_file, key_word))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将包含关键词的文档的文件路径，写入结果文件。</span></span><br><span class="line">            result_file.write(target_file + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭结果文件</span></span><br><span class="line">result_file.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>相对路径</strong>使用两个特殊符号，点<code>.</code>和双点<code>..</code>，点<code>.</code>表示当前的目录，双点<code>..</code>表示当前目录的上一级目录。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#【工作文件夹】与【oa_01.py】都在【codes文件夹】中，所以【工作文件夹】和【codes文件夹】的相对路径就可以表示为：</span></span><br><span class="line"><span class="comment"># &#x27;工作文件夹&#x27;的相对路径</span></span><br><span class="line"><span class="string">&#x27;./工作文件夹/&#x27;</span></span><br><span class="line"><span class="comment"># &#x27;codes&#x27;的相对路径</span></span><br><span class="line"><span class="string">&#x27;./&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249064.png" alt="image-20210812213713336"></p>
<h1 id="对excel操作"><a href="#对excel操作" class="headerlink" title="对excel操作"></a>对excel<a href="https://blog.csdn.net/m0_59235508/article/details/122712465?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pytoh%E5%AF%B9exce%E8%A1%A8%E6%A0%BC%E5%A4%8D%E5%88%B6&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-122712465.142^v10^control,157^v8^control&amp;spm=1018.2226.3001.4187">操作</a></h1><p>python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库</p>
<h2 id="xlrd模块"><a href="#xlrd模块" class="headerlink" title="xlrd模块"></a>xlrd模块</h2><p>读模块</p>
<p>有点问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="comment">#data = xlrd.open_workbook(filename)#文件名以及路径，如果路径或者文件名有中文给前面加一个 r</span></span><br><span class="line">xlsx = xlrd.open_workbook(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\表格.xlsx&#x27;</span>)<span class="comment">#读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过sheet名查找：xlsx.sheet_by_name(&quot;sheet1&quot;)</span></span><br><span class="line"><span class="comment"># 通过索引查找：xlsx.sheet_by_index(3)</span></span><br><span class="line">table = xlsx.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个表格值 (2,1)表示获取第3行第2列单元格的值</span></span><br><span class="line">value = table.cell_value(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第3行2列值为&quot;</span>,value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取表格行数</span></span><br><span class="line">nrows = table.nrows</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;表格一共有&quot;</span>,nrows,<span class="string">&quot;行&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第4列所有值（列表生成式）</span></span><br><span class="line">name_list = [<span class="built_in">str</span>(table.cell_value(i, <span class="number">3</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nrows)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第4列所有的值：&quot;</span>,name_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="xlst模块操作"><a href="#xlst模块操作" class="headerlink" title="xlst模块操作"></a>xlst模块操作</h2><p>写模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0.导入xlst模块</span></span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1.创建 Workbook</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.创建 worksheet</span></span><br><span class="line">ws = wb.add_sheet(<span class="string">&#x27;test_sheet&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.写入第一行内容  ws.write(a, b, c)  a：行，b：列，c：内容</span></span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;球队&#x27;</span>)</span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;号码&#x27;</span>)</span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&#x27;姓名&#x27;</span>)</span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&#x27;位置&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">wb.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\myExcel.xls&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205241207709.png" alt="image-20220524120653747"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1.创建 Workbook</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.创建 worksheet</span></span><br><span class="line">ws = wb.add_sheet(<span class="string">&#x27;test_sheet&#x27;</span>)</span><br><span class="line">data = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;Team&#x27;</span>: <span class="string">&#x27;湖人&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Number&#x27;</span>: <span class="string">&#x27;34&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;奥尼尔&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Positions&#x27;</span>: <span class="string">&#x27;中锋&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;Team&#x27;</span>: <span class="string">&#x27;湖人&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Number&#x27;</span>: <span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;科比&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Positions&#x27;</span>: <span class="string">&#x27;后卫&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;Team&#x27;</span>: <span class="string">&#x27;湖人&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Number&#x27;</span>: <span class="string">&#x27;23&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;詹姆斯&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Positions&#x27;</span>: <span class="string">&#x27;前锋&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">0</span>, item[<span class="string">&#x27;Team&#x27;</span>])</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">1</span>, item[<span class="string">&#x27;Number&#x27;</span>])</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">2</span>, item[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">3</span>, item[<span class="string">&#x27;Positions&#x27;</span>])</span><br><span class="line">wb.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\myExcel.xls&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205241207980.png" alt="image-20220524120730735"></p>
<h1 id="excel按照姓名分表"><a href="#excel按照姓名分表" class="headerlink" title="excel按照姓名分表"></a>excel按照姓名分表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置员工发展基金确认表路径</span></span><br><span class="line">source_path = <span class="string">&#x27;./员工发展基金确认表.csv&#x27;</span></span><br><span class="line"><span class="comment"># 设置存放拆分结果文件的文件夹路径</span></span><br><span class="line">result_path = <span class="string">&#x27;./员工发展基金文件夹_demo/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开员工发展基金确认表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(source_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> source_file:<span class="comment">#newline=&#x27;&#x27;:这样可以避免一些不必要的空行</span></span><br><span class="line">    <span class="comment"># 将文件对象转换为DictReader对象</span></span><br><span class="line">    source_csv = csv.DictReader(source_file)</span><br><span class="line">    <span class="comment"># 将csv对象的表头读取出来</span></span><br><span class="line">    headers = source_csv.fieldnames</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环处理确认表中除表头外的每一行数据</span></span><br><span class="line">    <span class="keyword">for</span> csv_row <span class="keyword">in</span> source_csv:</span><br><span class="line">        <span class="comment"># 根据获取的员工名字拼接新文件名</span></span><br><span class="line">        file_name = csv_row[<span class="string">&#x27;姓名&#x27;</span>] + <span class="string">&#x27;.csv&#x27;</span></span><br><span class="line">        <span class="comment"># 拼接新文件路径</span></span><br><span class="line">        file_path = result_path + file_name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建新文件并添加数据</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> target_file:</span><br><span class="line">            <span class="comment"># 将文件对象转换为DictWriter对象</span></span><br><span class="line">            target_writer = csv.DictWriter(target_file, fieldnames=headers)</span><br><span class="line">            <span class="comment"># 写入表头</span></span><br><span class="line">            target_writer.writeheader()</span><br><span class="line">            <span class="comment"># 写入数据</span></span><br><span class="line">            target_writer.writerow(csv_row)</span><br></pre></td></tr></table></figure>
<h1 id="openpyxl库"><a href="#openpyxl库" class="headerlink" title="openpyxl库"></a>openpyxl库</h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249825.png" alt="image-20210814100038376"></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249164.png" alt="image-20210817093103821"></p>
<ul>
<li>安装库：pip install openpyxl</li>
</ul>
<p>（Windows系统）cmd中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install 库/模块名</span><br></pre></td></tr></table></figure>
<ul>
<li>处理<code>xlsx</code>格式表格的相关内容。</li>
</ul>
<h2 id="获取对象及创建"><a href="#获取对象及创建" class="headerlink" title="获取对象及创建"></a>获取对象及创建</h2><ul>
<li>load_workbook(filename)</li>
<li>filename代表工作簿的路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="comment"># 通过文件路径，打开工作簿</span></span><br><span class="line">wb1 = openpyxl.load_workbook(<span class="string">&#x27;./demo_excel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 用 Workbook() 创建新工作簿</span></span><br><span class="line">wb2 = openpyxl.Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过文件路径，打开已有工作簿</span></span><br><span class="line">wb1 = load_workbook(<span class="string">&#x27;./demo_excel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 用 Workbook() 创建新工作簿</span></span><br><span class="line">wb2 = Workbook()</span><br></pre></td></tr></table></figure>
<h2 id="新建工作簿2"><a href="#新建工作簿2" class="headerlink" title="新建工作簿2"></a>新建工作簿2</h2><h3 id="Workbook"><a href="#Workbook" class="headerlink" title="Workbook()"></a><strong>Workbook()</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 打印工作簿对象</span></span><br><span class="line"><span class="built_in">print</span>(new_wb)</span><br></pre></td></tr></table></figure>
<h3 id="工作簿对象-save-filename"><a href="#工作簿对象-save-filename" class="headerlink" title="工作簿对象.save(filename)"></a>工作簿对象.save(filename)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 将新建的工作簿保存为【new_excel.xlsx】</span></span><br><span class="line">new_wb.save(<span class="string">&#x27;./new_excel.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果参数<code>filename</code>不变，即保存在原有路径，相当于修改原文件；若参数<code>filename</code>变化，即保存在新的路径，相当于另存为新的文件。</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249450.png" alt="image-20210814095339493"></p>
<h2 id="工作表对象"><a href="#工作表对象" class="headerlink" title="工作表对象"></a>工作表对象</h2><ul>
<li>Worksheet对象</li>
</ul>
<h3 id="获取工作表对象1"><a href="#获取工作表对象1" class="headerlink" title="获取工作表对象1"></a>获取工作表对象1</h3><ul>
<li><strong>active</strong>:active会获取到活动的工作表</li>
<li>建议单一工作表使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">active_ws = staff_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印工作簿对象</span></span><br><span class="line"><span class="built_in">print</span>(staff_wb)</span><br><span class="line"><span class="comment"># 打印工作表对象</span></span><br><span class="line"><span class="built_in">print</span>(active_ws)</span><br></pre></td></tr></table></figure>
<h3 id="按表名取表2"><a href="#按表名取表2" class="headerlink" title="按表名取表2"></a>按表名取表2</h3><ul>
<li>工作簿对象[‘表名’]</li>
<li>建议多张工作表使用，获取指定工作表对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 按表名取表</span></span><br><span class="line">fhy_ws = staff_wb[<span class="string">&#x27;上半年公司名单&#x27;</span>]  <span class="comment"># fhy为first half year（上半年）的缩写；工作表对象</span></span><br><span class="line">shy_ws = staff_wb[<span class="string">&#x27;下半年公司名单&#x27;</span>]  <span class="comment"># shy为second half year（下半年）的缩写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印工作簿对象</span></span><br><span class="line"><span class="built_in">print</span>(staff_wb)</span><br><span class="line"><span class="comment"># 打印工作表对象</span></span><br><span class="line"><span class="built_in">print</span>(fhy_ws)</span><br><span class="line"><span class="built_in">print</span>(shy_ws)</span><br></pre></td></tr></table></figure>
<h3 id="获取单行或单列"><a href="#获取单行或单列" class="headerlink" title="获取单行或单列"></a>获取单行或单列</h3><ul>
<li>数字代表行，英文字母代表列</li>
<li>通过<strong>工作表对象[行数]</strong>或<strong>工作表对象[‘列名’]</strong>的方式获取到一个<strong>元组</strong>，这个<strong>元组</strong>中包含了指定行或列中的所有数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">active_ws = staff_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印获取到的第五行数据</span></span><br><span class="line"><span class="built_in">print</span>(active_ws[<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 打印获取到的第二列数据</span></span><br><span class="line"><span class="built_in">print</span>(active_ws[<span class="string">&#x27;B&#x27;</span>])<span class="comment">#每一个元素均为&lt;Cell &#x27;工作表名称&#x27;.坐标&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每一个元素均为<Cell '工作表名称'.坐标></li>
</ul>
<h3 id="获取多行数据"><a href="#获取多行数据" class="headerlink" title="获取多行数据"></a>获取多行数据</h3><h4 id="iter-rows"><a href="#iter-rows" class="headerlink" title="iter_rows"></a>iter_rows</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">工作表对象.iter_rows(min_row, max_row, min_col, max_col, values_only=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#min_row是最小行索引</span></span><br><span class="line"><span class="comment">#max_row是最大行索引</span></span><br><span class="line"><span class="comment">#min_col是最小列索引</span></span><br><span class="line"><span class="comment">#max_col是最大列索引</span></span><br><span class="line"><span class="comment">#values_only=True:是否返回单元格的值</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取【&#x27;上半年公司名单&#x27;】工作表</span></span><br><span class="line">fhy_ws = staff_wb[<span class="string">&#x27;上半年公司名单&#x27;</span>]</span><br><span class="line"><span class="comment"># 返回第2行至第12行，第2列（B列）至第3列（C列）这个范围的单元格内的所有数据（值）</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> fhy_ws.iter_rows(min_row=<span class="number">2</span>, max_row=<span class="number">12</span>, min_col=<span class="number">2</span>, max_col=<span class="number">3</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>最小行索引的值默认为1，最大行索引的值默认为表格中有数据的最下面一行的行数；</li>
<li>参数<code>values_only</code>决定是否返回单元格的值，如果为True则返回<strong>单元格的值</strong>，如果为False则返回<strong>单元格对象</strong>。通常情况下，只读数据时，需要将该参数设置为True，要写入数据时，保持其为默认的False就好。</li>
<li>如果指定的行中没有数据，就会返回一个空的元组。(None, None)</li>
</ul>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><ul>
<li>语法：<strong>工作表对象.append(列表/元组)</strong></li>
<li>使用后保存，用save（）函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">active_ws = staff_wb.active</span><br><span class="line">info_list = [<span class="string">&#x27;S1911&#x27;</span>, <span class="string">&#x27;萧爵瑟&#x27;</span>, <span class="number">3000</span>, <span class="string">&#x27;内容&#x27;</span>]</span><br><span class="line">info_tuple = (<span class="string">&#x27;S1912&#x27;</span>, <span class="string">&#x27;吴琐薇&#x27;</span>, <span class="number">5000</span>, <span class="string">&#x27;销售&#x27;</span>)</span><br><span class="line">active_ws.append(info_list)</span><br><span class="line">active_ws.append(info_tuple)</span><br><span class="line"><span class="comment"># 保存工作簿为【append_demo.xlsx】</span></span><br><span class="line">staff_wb.save(<span class="string">&#x27;./append_demo.xlsx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="单元格对象"><a href="#单元格对象" class="headerlink" title="单元格对象"></a>单元格对象</h2><ul>
<li>单元格对象代表工作表中的一个单元格。</li>
</ul>
<h3 id="获取单元格对象"><a href="#获取单元格对象" class="headerlink" title="获取单元格对象"></a>获取单元格对象</h3><p>1、通过for row in 工作表对象.iter_rows()来获取指定范围的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#for cell in 工作表对象[行数]</span></span><br><span class="line"><span class="comment">#for cell in 工作表对象[&#x27;列名&#x27;]</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">staff_ws = staff_wb.active</span><br><span class="line"><span class="comment"># for循环遍历，取出第三行的所有单元格对象</span></span><br><span class="line"><span class="keyword">for</span> row_cell <span class="keyword">in</span> staff_ws[<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(row_cell)</span><br><span class="line"><span class="comment"># for循环遍历，取出第三列（C列）的所有单元格对象</span></span><br><span class="line"><span class="keyword">for</span> col_cell <span class="keyword">in</span> staff_ws[<span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(col_cell)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、<strong>工作表对象[‘单元格坐标’]</strong></p>
<ul>
<li>工作表对象[‘A1’]就会获取到表格中，A1那个单元格对应的单元格对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">staff_ws = staff_wb.active</span><br><span class="line"><span class="comment"># 打印单元格对象A1</span></span><br><span class="line"><span class="built_in">print</span>(staff_ws[<span class="string">&#x27;A1&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单元格对象的基本操作"><a href="#单元格对象的基本操作" class="headerlink" title="单元格对象的基本操作"></a>单元格对象的基本操作</h3><ul>
<li>借助单元格对象的属性value，我们就可以得到具体的数据；同时，我们也可以通过这个属性给单元格对象赋值（修改单元格的值或给单元格添加值）。</li>
<li>直接赋值操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取单元格的值单元格对象.value</span></span><br><span class="line"><span class="comment"># 给单元格对象赋值单元格对象.value = 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从openpyxl库导入load_workbook函数</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【10月员工绩效表】的工作簿，获取活动工作表</span></span><br><span class="line">performance_wb  = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"><span class="comment"># 取出[&#x27;A1&#x27;]单元格对象</span></span><br><span class="line">cell1 = performance_ws[<span class="string">&#x27;A1&#x27;</span>]</span><br><span class="line"><span class="comment"># 使用单元格对象的value属性取出单元格的值，并打印</span></span><br><span class="line"><span class="built_in">print</span>(cell1.value)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">performance = ws[<span class="string">&#x27;E11&#x27;</span>].value	<span class="comment">#赋值</span></span><br><span class="line">ws[<span class="string">&#x27;H1&#x27;</span>].value = <span class="string">&#x27;总工资&#x27;</span> <span class="comment">#改写赋值</span></span><br></pre></td></tr></table></figure>
<h1 id="常见语法错误"><a href="#常见语法错误" class="headerlink" title="常见语法错误"></a>常见语法错误</h1><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><ul>
<li>语法错误(syntax errors)是初学者最容易犯的错误</li>
<li>当你的代码完全符合Python的语法规范后，就该尝试运行程序了。但在程序运行过程中，还是有可能会发生问题，我们把这类问题称为<strong>异常(exceptions)</strong>。</li>
<li>代码不符合Python的语法规范，比如漏了冒号，混用中英文符号等，就会出现这种错误。</li>
</ul>
<h3 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h3><ul>
<li><strong>SyntaxError: invalid syntax（无效语法）</strong><ul>
<li>遗漏了标点符号</li>
<li>关键字拼写错误或遗漏</li>
<li>变量名或函数名使用了关键字。</li>
</ul>
</li>
<li><p><strong>SyntaxError: invalid character in identifier（标识符中有无效字符）</strong></p>
<ul>
<li>代码里使用了大量中文符号</li>
</ul>
</li>
<li><p><strong>SyntaxError: EOL while scanning string literal（检查到不完整的字符串）</strong></p>
<ul>
<li>遗漏了字符串两边的引号，或者混用了引号</li>
</ul>
</li>
</ul>
<h3 id="IndentationError"><a href="#IndentationError" class="headerlink" title="IndentationError"></a>IndentationError</h3><ul>
<li><strong>缩进错误</strong><ul>
<li><strong>IndentationError: expected an indented block（需要缩进的代码块）</strong></li>
</ul>
</li>
<li><strong>IndentationError: unindent does not match any outer indentation level（缩进内容不匹配任何一个层级）</strong></li>
</ul>
<h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><h3 id="TypeError类型错误"><a href="#TypeError类型错误" class="headerlink" title="TypeError类型错误"></a>TypeError类型错误</h3><ul>
<li><strong>异常</strong>的“错误消息”会显示Traceback (most recent call last）<ul>
<li><strong>TypeError: unsupported operand type(s) for …（不支持的运算）</strong></li>
</ul>
</li>
<li><strong>TypeError: can only concatenate str (not “int”) to str （只能用字符串拼接字符串）</strong></li>
<li><strong>TypeError: ‘xxx’ object is not iterable（对象不可被迭代）</strong><ul>
<li>可迭代对象应该包括：字符串类型，列表，元组和字典。剩下的一些类型，比如：int类型，float类型，布尔类型和None就不是可迭代对象。</li>
</ul>
</li>
</ul>
<h3 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a>IndexError</h3><ul>
<li>IndexError这个异常，和列表取值有关。</li>
<li><strong>索引错误</strong>是<strong>IndexError: list index out of range（索引超出了范围）</strong></li>
</ul>
<h3 id="操作文件异常"><a href="#操作文件异常" class="headerlink" title="操作文件异常"></a>操作文件异常</h3><h4 id="ModuleNotFoundError"><a href="#ModuleNotFoundError" class="headerlink" title="ModuleNotFoundError"></a>ModuleNotFoundError</h4><ul>
<li>ModuleNotFoundError 未找到模块错误，是一种有关模块的异常</li>
<li>检查模块名是否拼写正确</li>
</ul>
<h4 id="AttributeError"><a href="#AttributeError" class="headerlink" title="AttributeError"></a>AttributeError</h4><ul>
<li>检查模块是否使用了不存在的方法或属性</li>
<li>检查方法或属性是否正确</li>
</ul>
<h4 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError:"></a>FileNotFoundError:</h4><ul>
<li>检查文件路径是否正确</li>
</ul>
<h4 id="FileNotFoundError-1"><a href="#FileNotFoundError-1" class="headerlink" title="FileNotFoundError:"></a>FileNotFoundError:</h4><ul>
<li>检查encoding的编码类型和实际文件是否一致</li>
</ul>
<h1 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h1><ul>
<li>选取部分行：语法:new_row = [row[1],row[3], row[5]]</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249975.png" alt="image-20210817102224209"></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250249.png" alt="image-20210817115202085"></p>
<h2 id="获取个人工资信息"><a href="#获取个人工资信息" class="headerlink" title="获取个人工资信息"></a>获取个人工资信息</h2><ul>
<li>我们需要从【10月员工绩效表】中找到江宇的信息，然后写入【江宇工资信息表】中10月工资信息对应的行</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250001.png" alt="image-20210817095621289"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code_highlight_9.py</span><br><span class="line"><span class="comment"># 从openpyxl库导入load_workbook函数</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表】的工作簿，获取活动工作表</span></span><br><span class="line">performance_wb  = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【江宇工资信息表】的工作簿，获取活动工作表</span></span><br><span class="line">info_wb = load_workbook(<span class="string">&#x27;./material/江宇工资信息表.xlsx&#x27;</span>)</span><br><span class="line">info_ws = info_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取【绩效】值</span></span><br><span class="line">performance = performance_ws[<span class="string">&#x27;D14&#x27;</span>].value</span><br><span class="line"><span class="comment"># 获取【奖金】值</span></span><br><span class="line">bonus = performance_ws[<span class="string">&#x27;E14&#x27;</span>].value</span><br><span class="line"><span class="comment"># 获取【基本工资】值</span></span><br><span class="line">base = performance_ws[<span class="string">&#x27;F14&#x27;</span>].value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入【绩效】值</span></span><br><span class="line">info_ws[<span class="string">&#x27;E11&#x27;</span>].value = performance</span><br><span class="line"><span class="comment"># 写入【奖金】值</span></span><br><span class="line">info_ws[<span class="string">&#x27;F11&#x27;</span>].value = bonus</span><br><span class="line"><span class="comment"># 写入【基本工资】值</span></span><br><span class="line">info_ws[<span class="string">&#x27;G11&#x27;</span>].value = base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存对【江宇工资信息表】工作簿的写入</span></span><br><span class="line">info_wb.save(<span class="string">&#x27;./material/江宇工资信息表.xlsx&#x27;</span>)</span><br><span class="line">点击这里可以改变学习模式～</span><br></pre></td></tr></table></figure>
<h2 id="生成前十行绩效信息表"><a href="#生成前十行绩效信息表" class="headerlink" title="生成前十行绩效信息表"></a>生成前十行绩效信息表</h2><ul>
<li>是需要从【10月员工绩效表】中提取前十行信息，写入一个新的工作簿。这样，保存后可以用作员工绩效信息的模板表格。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从openpyxl库导入load_workbook和Workbook</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表.xlsx】工作簿</span></span><br><span class="line">performance_wb = load_workbook(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">new_ws = new_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取performance_ws的前十行数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> performance_ws.iter_rows(max_row=<span class="number">10</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 将数据写入新的工作表</span></span><br><span class="line">    new_ws.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存新工作簿为【员工绩效表-模板.xlsx】</span></span><br><span class="line">new_wb.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\10月员工绩效表.xlsx员工绩效表-模板.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="计算并打印奖金信息"><a href="#计算并打印奖金信息" class="headerlink" title="计算并打印奖金信息"></a>计算并打印奖金信息</h2><ul>
<li>依然是从【10月员工绩效表】提取所有员工的工资信息，然后根据每行中员工的“绩效”与“提成”的数值之和，计算出奖金总额，最后按照固定格式输出每位员工的奖金信息。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从openpyxl库导入load_workbook和Workbook</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表.xlsx】工作簿</span></span><br><span class="line">performance_wb = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取performance_ws中除表头外的数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> performance_ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 读取【工号】</span></span><br><span class="line">    staff_id = row[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 读取【员工姓名】</span></span><br><span class="line">    staff_name = row[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 读取【绩效】</span></span><br><span class="line">    performance = row[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 读取【提成】</span></span><br><span class="line">    bonus = row[<span class="number">4</span>]</span><br><span class="line">    <span class="comment"># 计算“奖金”</span></span><br><span class="line">    award = performance + bonus</span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;工号：&#123;&#125;，姓名：&#123;&#125;，本月奖金为：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(staff_id, staff_name, award))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建薪资信息字典"><a href="#创建薪资信息字典" class="headerlink" title="创建薪资信息字典"></a>创建薪资信息字典</h2><ul>
<li>要从这个总的薪资表中，读取所需数据范围的行数据，然后取出部分信息，将其对应存储在字典中。</li>
<li>【10月薪资绩效表】中的员工信息比较多，如果要找到某位同事（比如找到江宇的绩效、基本工资等）得按行整个查找一遍。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从openpyxl库导入load_workbook函数</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表.xlsx】工作簿</span></span><br><span class="line">performance_wb = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建员工信息字典</span></span><br><span class="line">staff_info = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第二行开始读取工作表中的信息</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> performance_ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出工号</span></span><br><span class="line">    member_number = row[<span class="number">0</span>]<span class="comment">#某行对应的数列序号</span></span><br><span class="line">    <span class="comment"># 将信息存入员工信息字典</span></span><br><span class="line">    staff_info[member_number] = &#123;  			<span class="comment">#staff_info[member_number]:以工号键；字典嵌套</span></span><br><span class="line">         <span class="string">&#x27;姓名&#x27;</span>: row[<span class="number">1</span>],<span class="comment">#row[1]元组索引</span></span><br><span class="line">         <span class="string">&#x27;部门&#x27;</span>: row[<span class="number">2</span>],</span><br><span class="line">         <span class="string">&#x27;绩效&#x27;</span>: row[<span class="number">3</span>],</span><br><span class="line">         <span class="string">&#x27;奖金&#x27;</span>: row[<span class="number">4</span>],</span><br><span class="line">         <span class="string">&#x27;基本工资&#x27;</span>: row[<span class="number">5</span>],</span><br><span class="line">         <span class="string">&#x27;是否确认&#x27;</span>: row[<span class="number">6</span>]</span><br><span class="line">     &#125;</span><br><span class="line"><span class="built_in">print</span>(staff_info)</span><br></pre></td></tr></table></figure>
<h1 id="筛选匹配"><a href="#筛选匹配" class="headerlink" title="筛选匹配"></a>筛选匹配</h1><ul>
<li>在【10月考勤统计.xlsx】工作簿中，保存了公司一百名员工的迟到信息，这些信息包含了<strong>迟到时间</strong>和<strong>迟到次数</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月考勤统计.xlsx】工作簿</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;./material/10月考勤统计.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取表头</span></span><br><span class="line">late_header = []</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws[<span class="number">1</span>]:</span><br><span class="line">    late_header.append(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 获取新工作簿中的工作表</span></span><br><span class="line">new_ws = new_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将表头写入新工作簿的工作表中</span></span><br><span class="line">new_ws.append(late_header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第二行开始遍历表格</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出姓名，迟到时间和迟到次数</span></span><br><span class="line">    name = row[<span class="number">1</span>]</span><br><span class="line">    time = row[<span class="number">3</span>]</span><br><span class="line">    number = row[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 判断是否迟到</span></span><br><span class="line">    <span class="keyword">if</span> time &gt; <span class="number">45</span> <span class="keyword">and</span> number &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;迟到了&#123;&#125;分钟，迟到了&#123;&#125;次&#x27;</span>.<span class="built_in">format</span>(name, time, number))</span><br><span class="line">        <span class="comment"># 将迟到人员信息写入新工作簿的工作表中</span></span><br><span class="line">        new_ws.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新工作簿保存为【10月迟到人员信息.xlsx】</span></span><br><span class="line">new_wb.save(<span class="string">&#x27;./material/10月迟到人员信息.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="数据匹配"><a href="#数据匹配" class="headerlink" title="数据匹配"></a>数据匹配</h1><ul>
<li>使用字典，把可以<strong>连接</strong>表格的数据作为键，要匹配的数据作为值</li>
<li>再将另一个表格中要匹配的值与字典中对应的值关联起来，实现匹配逻辑</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开工作簿【10月考勤统计.xlsx】，获取活动工作表</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;./material/10月考勤统计.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建迟到人员字典</span></span><br><span class="line">info_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环读取除表头外的表格数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出员工工号</span></span><br><span class="line">    staff_id = row[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取出迟到次数</span></span><br><span class="line">    staff_late = row[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 将信息添加入字典，字典格式为&#123;&#x27;员工工号&#x27;: &#x27;迟到次数&#x27;&#125;</span></span><br><span class="line">    info_dict[staff_id] = staff_late</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开工作簿【迟到次数月度统计（10月更新）.xlsx】，获取活动工作表</span></span><br><span class="line">monthly_wb = load_workbook(<span class="string">&#x27;./material/迟到次数月度统计（10月更新）.xlsx&#x27;</span>)</span><br><span class="line">monthly_ws = monthly_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环读取出表头外的表格数据</span></span><br><span class="line"><span class="keyword">for</span> monthly_row <span class="keyword">in</span> monthly_ws.iter_rows(min_row=<span class="number">3</span>, max_col=<span class="number">13</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出员工工号</span></span><br><span class="line">    member_id = monthly_row[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取出十月份的迟到次数</span></span><br><span class="line">    member_late = monthly_row[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 匹配迟到次数是否相等</span></span><br><span class="line">    <span class="keyword">if</span> member_late != info_dict[member_id]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;工号&#123;&#125;迟到情况不匹配，请核查后更新&#x27;</span>.<span class="built_in">format</span>(member_id))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>6.python数据分析</title>
    <url>/blot.github.io/2022/04/03/6%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="6、数据分析"><a href="#6、数据分析" class="headerlink" title="6、数据分析"></a>6、数据分析</h1><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="jupyter-代码编辑器"><a href="#jupyter-代码编辑器" class="headerlink" title="jupyter 代码编辑器"></a><a href="https://py.forchangecode.com/?app_id=17&amp;app_type=formal#/scene/%2F%E4%B8%89%E6%AE%B5%E8%AF%BE%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E5%85%B3%E5%8D%A1%E4%B8%80%2F%E9%A1%B9%E7%9B%AE%E5%9C%BA%E6%99%AF_%E6%98%8E%E7%A1%AE%E7%9B%AE%E6%A0%87">jupyter 代码编辑器</a></h2><ul>
<li>专门为数据分析工作而打造的编辑器</li>
<li>代码的输入以及代码结果的输出都是在 Cell 中实现的</li>
<li>Cell 一共由两个部分组成：<code>In[]</code> 和 <code>Out[]</code>，即输入框和输出框</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建字典</span></span><br><span class="line">temp_dict = &#123;<span class="string">&#x27;性别&#x27;</span>: [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>], <span class="string">&#x27;年龄&#x27;</span>: [<span class="number">23</span>, <span class="number">22</span>, <span class="number">23</span>], <span class="string">&#x27;成绩&#x27;</span>: [<span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>]&#125;</span><br><span class="line"><span class="comment"># 查看 temp_dict</span></span><br><span class="line">temp_dict<span class="comment">#查看变量值的时候，只要输入变量名就可以了</span></span><br><span class="line">temp_dict[<span class="string">&#x27;成绩&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>重新打开学习系统的时候，系统就会“忘记”之前运行过的变量的值。</p>
</li>
<li><p>这个时候就需要点击网页右上角的【运行全部 Cells】按钮，让系统重新“记住”我们所需要用到的变量的值。</p>
</li>
</ul>
<h2 id="pandas-库基础知识"><a href="#pandas-库基础知识" class="headerlink" title="pandas 库基础知识"></a>pandas 库基础知识</h2><ul>
<li>pandas 库是一个专门用来解决数据分析问题的库</li>
<li>一般会将 pandas 简化为 pd</li>
<li>速度快以及效率高。</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250370.png" alt="image-20210817210808985"></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Series对象"><a href="#Series对象" class="headerlink" title="Series对象"></a>Series对象</h4><ul>
<li>主要由一组数据及其对应的索引组成</li>
<li>dtype: object:其中，dtype 指的是 pandas 库中的数据类型，object 就等价于之前 python 学过的字符串类</li>
</ul>
<p>创建Series对象</p>
<ul>
<li>格式：pd.Series()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建Series对象</span></span><br><span class="line">surname = pd.Series([<span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;钱&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;李&#x27;</span>])</span><br><span class="line"><span class="comment"># 查看surname</span></span><br><span class="line"><span class="built_in">print</span>(surname)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">surname = pd.Series([<span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;钱&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;李&#x27;</span>], index = [<span class="string">&#x27;学生1&#x27;</span>, <span class="string">&#x27;学生2&#x27;</span>, <span class="string">&#x27;学生3&#x27;</span>, <span class="string">&#x27;学生4&#x27;</span>])</span><br><span class="line"><span class="comment">#index人为设定对象索引</span></span><br><span class="line"><span class="built_in">print</span>(surname)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>备注</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>字典</td>
<td>pd.Series([‘赵’, ‘钱’, ‘孙’, ‘李’]）</td>
</tr>
<tr>
<td>标量</td>
<td>pd.Series(5)</td>
</tr>
<tr>
<td>n维数组</td>
<td>import numpy as np;pd.Series(np.array([1,2]))</td>
</tr>
<tr>
<td>字符串</td>
<td>pd.Series(“hello “)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="DataFrame-对象"><a href="#DataFrame-对象" class="headerlink" title="DataFrame 对象"></a>DataFrame 对象</h4><ul>
<li>DataFrame对象是一种表格型的数据结构，包含行索引、列索引以及一组数据。</li>
</ul>
<p>创建DataFrame对象</p>
<ul>
<li>pd.DataFrame(data)</li>
<li>当我们给参数 data 传入字典的时候，<strong>字典的键</strong>会变成 DataFrame 对象的<strong>列索引</strong>，字典的<strong>键所对应的值</strong>会变成 DataFrame <strong>对象的数据</strong>。</li>
<li>传入的字典的各个键所对应的值长度一定相等；否则会报错</li>
<li>对象[‘键名’]：通过列索引————是Series对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line">new_df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>: [<span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>],</span><br><span class="line">                       <span class="string">&#x27;岗位&#x27;</span>: [<span class="string">&#x27;客服&#x27;</span>, <span class="string">&#x27;运营&#x27;</span>, <span class="string">&#x27;公关&#x27;</span>],</span><br><span class="line">                       <span class="string">&#x27;年购买量&#x27;</span>: [<span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>]&#125;)<span class="comment">#键所对应得值长度都为3</span></span><br><span class="line"><span class="comment"># 查看 new_df</span></span><br><span class="line"><span class="built_in">print</span>(new_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_df[<span class="string">&#x27;年龄&#x27;</span>])<span class="comment">#通过列索引</span></span><br></pre></td></tr></table></figure>
<ul>
<li>n 维数组的方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">class_df2 = pd.DataFrame(np.array([[<span class="number">25</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                                   [<span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                                   [<span class="number">23</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                                   [<span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>]]),</span><br><span class="line">                         columns = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>],</span><br><span class="line">                         index = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 查看 class_df2</span></span><br><span class="line"><span class="built_in">print</span>(class_df2)</span><br></pre></td></tr></table></figure>
<ul>
<li>分析流程：明确目标、数据处理、数据分析、数据展现以及报告撰写</li>
</ul>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><ul>
<li>pd.read_csv(path, encoding) 就是其中一种高效读取 csv 文件的方法，返回的是一个 DataFrame 对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line"><span class="comment"># 导入 csv 数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_data)<span class="comment">#行数列数也看得到</span></span><br></pre></td></tr></table></figure>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><ul>
<li><p>数据处理步骤：数据清洗、数据整理、数据写入</p>
</li>
<li><p>在 pandas 库中，NaN 代表缺失值，意思是这里的数据是空的。</p>
</li>
</ul>
<h4 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h4><ul>
<li><strong>df.info()</strong>：可查看数据情况—数据总结</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line"><span class="comment"># 导入 csv 数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_data)</span><br><span class="line">my_data.info()<span class="comment">#查看数据情况</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250336.png" alt="image-20210817212424956"></p>
<h5 id="查找缺失值"><a href="#查找缺失值" class="headerlink" title="查找缺失值"></a>查找缺失值</h5><ul>
<li>isna() 方法来查找 DataFrame 对象以及 Series 对象中的缺失值</li>
<li>缺失数据会用 True 来表示，False 则代表这里的数据不缺失</li>
<li>，还可以使用<code>df.head()</code>或<code>df.tail()</code>方法查看数据。</li>
<li>DataFrame 对象使用 df.head() 方法默认可以查看数据的前 5 行，df.tail() 方法则默认可以查看数据的后 5 行；</li>
<li>df.head(i)中i代表常看前i行；df.tail(i) 中i代表常看后i行</li>
<li>NaN 代表的就是缺失数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_data.isna())<span class="comment">#查找缺失值</span></span><br><span class="line"><span class="built_in">print</span>(my_data.tail())<span class="comment">#查看数据后5行</span></span><br><span class="line"><span class="comment"># 删除所有缺失值</span></span><br><span class="line"><span class="built_in">print</span>(my_data.dropna())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看&#x27;明细&#x27;一列含有缺失值的数据</span></span><br><span class="line">exercise[exercise[<span class="string">&#x27;明细&#x27;</span>].isna()]</span><br></pre></td></tr></table></figure>
<h5 id="删除缺失值"><a href="#删除缺失值" class="headerlink" title="删除缺失值"></a>删除缺失值</h5><ul>
<li>只要执行 df.dropna() 这一代码方法，就可以将 DataFrame 对象中包含缺失值的每一行全部删掉</li>
<li>刚才我们运行的 <code>mask_data.dropna()</code> 代码返回的是一个删掉所有缺失数据的 DataFrame 对象，但这并不意味着它修改了 mask_data 数据。</li>
<li>我们需要将 mask_data.dropna() 的运行结果重新赋值给 mask_data 变量，这样就可以将运行结果保存下来</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line"><span class="comment"># 导入 csv 数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 删除所有缺失值</span></span><br><span class="line">my_data=my_data.dropna()<span class="comment">#删去缺失值重新赋值</span></span><br><span class="line"><span class="built_in">print</span>(my_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>针对某几列的缺失数据进行删除</strong><ul>
<li>对象。dropna(subset=[‘所删除列名’])</li>
<li>test_data 中’品牌’、’上牌时间’、 ‘里程数(km)’和 ‘保值率’四列数据缺失的行，可以如下书写代码：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_data.dropna(subset=[<span class="string">&#x27;品牌&#x27;</span>, <span class="string">&#x27;上牌时间&#x27;</span>, <span class="string">&#x27;里程数(km)&#x27;</span>, <span class="string">&#x27;保值率&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h5 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h5><ul>
<li>DataFrame对象和Series对象都可以使用<strong>fillna()</strong>的方法给缺失值填充数据。</li>
<li>只需要将要填充的数据作为参数写在括号内，就能把所有缺失值都替换成括号里的数据</li>
<li>有些缺失数据我们最好不要删除，因为它们依然有很强的分析价值，这时会用填充缺失值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换&#x27;明细&#x27;中的缺失值为&#x27;矿泉水&#x27;</span></span><br><span class="line">exercise[<span class="string">&#x27;明细&#x27;</span>] = exercise[<span class="string">&#x27;明细&#x27;</span>].fillna(<span class="string">&#x27;矿泉水&#x27;</span>)</span><br><span class="line"><span class="comment"># 查看exercise的基本信息总结</span></span><br><span class="line">exercise.info()</span><br></pre></td></tr></table></figure>
<h4 id="处理重复值"><a href="#处理重复值" class="headerlink" title="处理重复值"></a>处理重复值</h4><ul>
<li>查找重复行<ul>
<li>使用 <strong>df.duplicated()</strong> 方法会返回一个 Series 对象，找出所有重复值。重复为 True，不重复为 Falsel</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask_data.duplicated()<span class="comment">#查找重复行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以将 <strong>mask_data.duplicated()</strong>返回的结果放入中括号 [] 中，用来索引 mask_data 数据，查看 mask_data 数据中重复的行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 mask_data 中的重复数据</span></span><br><span class="line">mask_data[mask_data.duplicated()]<span class="comment">#用print打印</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用 pandas 库的 <strong>df.drop_duplicates()</strong> 方法直接删除 DataFrame 对象中重复出现的整行数据。<ul>
<li>df.drop_duplicates() 方法删除的也都是重复出现的行，因此所有重复数据的第一行都会保留</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接删除所有重复值</span></span><br><span class="line">mask_data = mask_data.drop_duplicates()</span><br><span class="line"><span class="comment"># 查看 mask_data 中的重复数据</span></span><br><span class="line">mask_data[mask_data.duplicated()]</span><br></pre></td></tr></table></figure>
<h4 id="处理异常值"><a href="#处理异常值" class="headerlink" title="处理异常值"></a>处理异常值</h4><ul>
<li>检查异常值 <strong>describe()</strong><ul>
<li>describe() 方法返回出来的统计信息分别代表数值型数据的频数统计、平均值、标准差、最小值、第一四分位数、中位数、第三四分位数以及最大值。</li>
<li>e+n 代表的是 10 的 n 次方</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask_data.describe()</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="抽取数据范围"><a href="#抽取数据范围" class="headerlink" title="抽取数据范围"></a><strong>抽取数据范围</strong></h3><ul>
<li>单价一列小于等于 200 的数据，就可以设置条件表达式 mask_data[‘单价’] &lt;= 200</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看单价小于等于 200 的数据</span></span><br><span class="line">mask_data[mask_data[<span class="string">&#x27;单价&#x27;</span>] &lt;= <span class="number">200</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h3><ul>
<li>指的是我们在数据分析前对所需字段进行数据排序、数据转换、数据抽取、数据合并、数据计算等准备操作</li>
<li><code>字段</code>指的是表格的列，像我们这次分析的数据就包含 ‘订单编号’、’日期’、’省’……等字段。</li>
</ul>
<h4 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h4><ul>
<li>专门储存时间日期的数据类型，可以直接从中提取想要的时间单位</li>
</ul>
<h5 id="转换日期数据"><a href="#转换日期数据" class="headerlink" title="转换日期数据"></a>转换日期数据</h5><ul>
<li>pandas 库中我们可以使用 <code>pd.to_datetime(arg, format)</code> 来将 <code>DataFrame</code> 对象或者 <code>Series</code> 对象的数据类型转换成 datetime 类型。</li>
<li><code>arg</code> 参数为我们要转换的数据，它可以是 DataFrame 对象或 Series 对象</li>
<li>mask_data 中的’日期’字段，所以对应的 arg 参数就是 mask_data[‘日期’]。</li>
<li>format 参数为 datetime 类型的日期格式，比如说这份数据，它是以年-月-日的形式出现的，那么它对应的 format 就是 ‘%Y-%m-%d’（year-month-day的缩写）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.to_datetime(mask_data[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span> = <span class="string">&#x27;%Y-%m-%d&#x27;</span>)<span class="comment">#提取mask_data中的日期</span></span><br></pre></td></tr></table></figure>
<ul>
<li>人提取日期信息<ul>
<li>获取这份数据的年、月、日的信息，可以通过 <strong>Series.dt.year</strong><code>、</code><strong>Series.dt.month</strong><code>以及</code><strong>Series.dt.day</strong>来获取</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换日期数据，并设置对应的日期格式</span></span><br><span class="line">date_data = pd.to_datetime(mask_data[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span> = <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 提取日期数据中的月份信息</span></span><br><span class="line">month_data = date_data.dt.month</span><br><span class="line"><span class="comment"># 查看 month_data</span></span><br><span class="line"><span class="built_in">print</span>(month_data)</span><br></pre></td></tr></table></figure>
<ul>
<li>添加新的一列<ul>
<li>df[‘colname’] = Series的方式来为原数据添加新的一列：colname 指的是要添加的新列的列名</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask_data[<span class="string">&#x27;月份&#x27;</span>] = month_data<span class="comment">#month_data为提取的一列</span></span><br></pre></td></tr></table></figure>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><ul>
<li>df.to_csv(‘路径’，编码)方法</li>
<li>可以生成新文件</li>
<li>pandas 库将 csv 文件读取为 DataFrame对象 时都会自动生成行索引。；默认值为 True，会让你写入的 csv 文件包含一列行索引</li>
<li>把这个参数设置为 index = False 就可以取消写入行索引，不用将行索引那一列写入 csv 文件。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask_data.to_csv(<span class="string">&#x27;./工作/mask_data_clean.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存清洗干净的数据，并取消写入行索引</span></span><br><span class="line">mask_data.to_csv(<span class="string">&#x27;./工作/mask_data_clean.csv&#x27;</span>, index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250361.png" alt="image-20210818174059829"></p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><ul>
<li>分组聚合操作指的是按照某项规则对数据进行分组，接着对分完组的数据执行总结统计的操作（求和、平均值等）</li>
</ul>
<h3 id="单层分组聚合操作"><a href="#单层分组聚合操作" class="headerlink" title="单层分组聚合操作"></a>单层分组聚合操作</h3><ul>
<li><strong>df.groupby(by)[‘列索引’].mean()</strong></li>
<li>返回Series对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建DataFrame对象</span></span><br><span class="line">grade_df = pd.DataFrame(&#123;<span class="string">&#x27;班级&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">                         <span class="string">&#x27;性别&#x27;</span>: [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;眼镜&#x27;</span>: [<span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;成绩&#x27;</span>: [<span class="number">95</span>, <span class="number">90</span>, <span class="number">96</span>, <span class="number">92</span>, <span class="number">94</span>, <span class="number">85</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">86</span>]&#125;)</span><br><span class="line"><span class="comment"># 查看grade_df</span></span><br><span class="line"><span class="built_in">print</span>(grade_df)</span><br><span class="line">grade_df1 = grade_df.groupby(<span class="string">&#x27;班级&#x27;</span>)[<span class="string">&#x27;成绩&#x27;</span>].mean()<span class="comment">#求班级的平均分</span></span><br><span class="line"><span class="comment"># 查看grade_df1</span></span><br><span class="line"><span class="built_in">print</span>(grade_df1)</span><br></pre></td></tr></table></figure>
<ul>
<li>单层分组操作<ul>
<li>分组操作：dfgroupdy(by)</li>
<li>参数 <code>by</code> 代表了我们想要对哪一列数据进行分组操作</li>
</ul>
</li>
<li>聚合操作 <ul>
<li>[‘列索引’].mean</li>
<li>‘列索引’指的是需要对哪一列数据进行聚合操作</li>
<li>mean() 指的是求平均值</li>
</ul>
</li>
</ul>
<h4 id="常见聚合操作"><a href="#常见聚合操作" class="headerlink" title="常见聚合操作"></a>常见聚合操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th>流程</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>求最小值</td>
<td>min()</td>
<td>一组数据最小值</td>
</tr>
<tr>
<td>求最大值</td>
<td>max()</td>
<td>一组数据的最大值</td>
</tr>
<tr>
<td>求标准差</td>
<td>std()</td>
<td>一组数据的标准差</td>
</tr>
<tr>
<td>求平均值</td>
<td>mean()</td>
<td>一组数据的总和除以一组数据的个数</td>
</tr>
<tr>
<td>求中位数</td>
<td>mendian()</td>
<td>—组数据中处于中间位置的数</td>
</tr>
<tr>
<td>求总和</td>
<td>sum()</td>
<td>一组数据的总和</td>
</tr>
<tr>
<td>求数量</td>
<td>count()</td>
<td>一组数据的非空数据的个数</td>
</tr>
<tr>
<td>求频数分布</td>
<td>value_counts()</td>
<td>一组数据各个类别出现的次数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="多层分组聚合操作"><a href="#多层分组聚合操作" class="headerlink" title="多层分组聚合操作"></a>多层分组聚合操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 获取不同班级下不同性别的学生的平均分</span></span><br><span class="line">grade_df3 = grade_df.groupby([<span class="string">&#x27;班级&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>])[<span class="string">&#x27;成绩&#x27;</span>].mean()</span><br><span class="line"><span class="comment"># 查看grade_df3</span></span><br><span class="line">grade_df3</span><br></pre></td></tr></table></figure>
<ul>
<li>格式：df.groupby(by)[‘列索引’].mean()。</li>
<li>多层分组聚合操作需要传多个列索引给参数 by</li>
</ul>
<h4 id="s-unstack-函数"><a href="#s-unstack-函数" class="headerlink" title="s.unstack() 函数"></a>s.unstack() 函数</h4><ul>
<li>可以将一个多层分组聚合后的 Series 对象转变成 DataFrame 对象</li>
<li>作用就是将其索引的最后一列转变成 DataFrame 对象的列索引，而剩下的索引则转变成 DataFrame 对象的行索引。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建DataFrame对象</span></span><br><span class="line">grade_df = pd.DataFrame(&#123;<span class="string">&#x27;班级&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">                         <span class="string">&#x27;性别&#x27;</span>: [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;眼镜&#x27;</span>: [<span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;成绩&#x27;</span>: [<span class="number">95</span>, <span class="number">90</span>, <span class="number">96</span>, <span class="number">92</span>, <span class="number">94</span>, <span class="number">85</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">86</span>]&#125;)</span><br><span class="line"><span class="comment"># 查看grade_df</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取不同班级、不同性别、戴与不戴眼镜的学生的最高分</span></span><br><span class="line">grade_df5 = grade_df.groupby([<span class="string">&#x27;班级&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;眼镜&#x27;</span>])[<span class="string">&#x27;成绩&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"><span class="comment"># 查看grade_df5</span></span><br><span class="line"><span class="built_in">print</span>(grade_df5)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(grade_df5.unstack())</span><br></pre></td></tr></table></figure>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="matplotlib-库"><a href="#matplotlib-库" class="headerlink" title="matplotlib 库"></a>matplotlib 库</h2><ul>
<li><p>pandas 库是根据一个更加底层的绘图库——matplotlib，封装而来</p>
</li>
<li><p>设置中文字体</p>
<ul>
<li>plt.rcParams[‘font.family’] 可以获取 matplotlib 库中的字体，’SimHei’ 指的是我们windows系统自带的中文字体</li>
<li>windows</li>
</ul>
<p>| 中文字体 | 英文名   |<br>| ———— | ———— |<br>| 黑体     | SimHei   |<br>| 宋体     | SimSun   |<br>| 新宋体   | NSimSun  |<br>| 仿宋     | FangSong |<br>| 楷体     | KaiTI    |</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line">li_jian = pd.Series([<span class="number">80</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">91</span>, <span class="number">88</span>, <span class="number">95</span>],</span><br><span class="line">                    index=[<span class="string">&#x27;2月&#x27;</span>, <span class="string">&#x27;3月&#x27;</span>, <span class="string">&#x27;4月&#x27;</span>, <span class="string">&#x27;5月&#x27;</span>, <span class="string">&#x27;6月&#x27;</span>, <span class="string">&#x27;7月&#x27;</span>])</span><br><span class="line"><span class="comment"># 绘制单条折线图</span></span><br><span class="line">li_jian.plot(kind=<span class="string">&#x27;line&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;李健月考成绩&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure>
<ul>
<li>windows</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>中文字体</th>
<th>英文名</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑体</td>
<td>SimHei</td>
</tr>
<tr>
<td>宋体</td>
<td>SimSun</td>
</tr>
<tr>
<td>新宋体</td>
<td>NSimSun</td>
</tr>
<tr>
<td>仿宋</td>
<td>FangSong</td>
</tr>
<tr>
<td>楷体</td>
<td>KaiTI</td>
</tr>
</tbody>
</table>
</div>
<h3 id="绘制单条折线图"><a href="#绘制单条折线图" class="headerlink" title="绘制单条折线图"></a>绘制单条折线图</h3><ul>
<li><strong>s.plot()</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>参数值类型（常用）</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>kind</td>
<td>设置图表类型</td>
<td>字符串</td>
<td>kind=’line’</td>
</tr>
<tr>
<td>figsize</td>
<td>设置图标大小</td>
<td>元组</td>
<td>figsize=(7,6)   注：左宽，右高</td>
</tr>
<tr>
<td>title</td>
<td>设置图标标题</td>
<td>字符串</td>
<td>title=’中国’</td>
</tr>
<tr>
<td>use_indx</td>
<td>是否要用行索引作为x轴的刻度值</td>
<td>布尔值</td>
<td>use_index=False</td>
</tr>
<tr>
<td>xticks</td>
<td>设置横坐标的值</td>
<td>序列</td>
<td>xticks=[0]</td>
</tr>
<tr>
<td>yticks</td>
<td>设置做纵坐标的值</td>
<td>序列</td>
<td>yticks=[90]</td>
</tr>
<tr>
<td>rot</td>
<td>设置刻度值的旋转角度</td>
<td>整数</td>
<td>rot=30</td>
</tr>
<tr>
<td>fontsize</td>
<td>设置刻度值的字体大小</td>
<td>整数</td>
<td>fontsize=20</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li_jian.plot(kind=<span class="string">&#x27;line&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;李健月考成绩&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="多条折线图"><a href="#多条折线图" class="headerlink" title="多条折线图"></a>多条折线图</h3><ul>
<li>多条折线图是针对一个 DataFrame 对象来绘制的，而单条折线图是针对一个 Series 对象来绘制的。</li>
<li>df.plot()</li>
<li>观察折线图，有三个要点，一是整体的走势，二是走势的规律性，三是走势的波动。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line"><span class="comment"># 创建三位学生成绩的df</span></span><br><span class="line">students_grade = pd.DataFrame(&#123;<span class="string">&#x27;李健&#x27;</span>: [<span class="number">80</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">91</span>, <span class="number">88</span>, <span class="number">95</span>],</span><br><span class="line">                               <span class="string">&#x27;王聪&#x27;</span>: [<span class="number">95</span>, <span class="number">92</span>, <span class="number">90</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">80</span>],</span><br><span class="line">                               <span class="string">&#x27;过凡&#x27;</span>: [<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">91</span>]</span><br><span class="line">                              &#125;, index=[<span class="string">&#x27;2月&#x27;</span>, <span class="string">&#x27;3月&#x27;</span>, <span class="string">&#x27;4月&#x27;</span>, <span class="string">&#x27;5月&#x27;</span>, <span class="string">&#x27;6月&#x27;</span>, <span class="string">&#x27;7月&#x27;</span>])</span><br><span class="line"><span class="comment"># 绘制多条折线图</span></span><br><span class="line">students_grade.plot(kind=<span class="string">&#x27;line&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;月考成绩&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure>
<h3 id="其他图形拓展"><a href="#其他图形拓展" class="headerlink" title="其他图形拓展"></a>其他图形拓展</h3><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><ul>
<li>主要可以用来反映数据的占比情况</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;./工作/clean_data.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取行业的频率分布</span></span><br><span class="line">profession = my_data[<span class="string">&#x27;行业&#x27;</span>].value_counts()/my_data[<span class="string">&#x27;行业&#x27;</span>].value_counts().<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 绘制行业频率分布的饼图</span></span><br><span class="line">profession.plot(kind=<span class="string">&#x27;pie&#x27;</span>, autopct=<span class="string">&#x27;%.2f%%&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;行业频率分布图&#x27;</span>, label=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数plt.pie()函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置扇形面积值</span></span><br><span class="line">x = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"><span class="comment"># 设置百分比小数的位数：保留百分比小数点后两位</span></span><br><span class="line">autopct=<span class="string">&#x27;%.2f%%&#x27;</span></span><br><span class="line"><span class="comment"># 设置百分比字体大小和颜色</span></span><br><span class="line">textprops = &#123;<span class="string">&#x27;fontsize&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;black&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 设置饼图的“爆炸效果”：让扇形远离圆心</span></span><br><span class="line">explode = [<span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 设置不同扇形的颜色</span></span><br><span class="line">colors = [<span class="string">&#x27;cornflowerblue&#x27;</span>, <span class="string">&#x27;salmon&#x27;</span>, <span class="string">&#x27;yellowgreen&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line"><span class="comment"># 绘制饼图</span></span><br><span class="line">plt.pie(x, autopct=autopct, textprops=textprops,</span><br><span class="line">        explode=explode, colors=colors)</span><br><span class="line"><span class="comment"># 设置图表标题名及字体大小</span></span><br><span class="line">plt.title(<span class="string">&#x27;闪光科技2020年各季度研发费用占比饼图&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置图例</span></span><br><span class="line">plt.legend([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>]) </span><br><span class="line"></span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250229.png" alt="image-20210820215528507"></p>
<h4 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h4><ul>
<li>主要可以用来反映不同数据值的差异性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;./工作/clean_data.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取岗位的频率分布</span></span><br><span class="line">position = my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts()/my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts().<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 绘制岗位的频率分布条形图</span></span><br><span class="line">position.plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">13</span>, <span class="number">6</span>), title=<span class="string">&#x27;岗位频率分布条形图&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"><span class="comment"># 获取岗位的频率分布</span></span><br><span class="line">position = my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts()/my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts().<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 绘制岗位的频率分布条形图</span></span><br><span class="line">position.plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">13</span>, <span class="number">6</span>), title=<span class="string">&#x27;岗位频率分布条形图&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250384.png" alt="image-20210820220044211"></p>
<ul>
<li>从应用范围上来看，在 python 数据分析领域，matplotlib 库是与 numpy 库、pandas 库并驾齐驱的三库之一，被称作 python 数据分析的“三剑客”，由此可见其应用范围之广。</li>
<li>个完整的图形除了图表，还包括一系列的图表元素：图表标题、坐标轴刻度、坐标轴标题、图例以及数据标签。</li>
</ul>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>设置画布大小 ：<strong>plt.figure()</strong></p>
<ul>
<li>元组形式:plt.figure(figsize=(6,6))</li>
</ul>
<p>对画布进行保存：<strong>plt.savefig()</strong></p>
<ul>
<li>plt.savefig(‘路径’)</li>
</ul>
<h3 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250815.png" alt="image-20210820221407062"></p>
<ul>
<li>颜色</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250816.png" alt="image-20210820221516449"></p>
<ul>
<li>marker参数</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250314.png" alt="image-20210820221620572"></p>
<ul>
<li><strong>plt.plot()函数</strong><ul>
<li>color 参数表示图表的颜色</li>
<li>plt.plot(x,y,color=’颜色’)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))<span class="comment">#设置画布大小</span></span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#plt.plot(x, y, color=&#x27;dodgerblue&#x27;)# 绘制折线图，并调整线条颜色为湖蓝色</span></span><br><span class="line">plt.plot(x, y,linewidth=<span class="number">2</span>,color=<span class="string">&#x27;dodgerblue&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,markerfacecolor=<span class="string">&#x27;red&#x27;</span>,markersize=<span class="number">8</span>)</span><br><span class="line"><span class="comment">#plt.savefig(&#x27;C:\\Users\\win10\\Desktop\\电工\\各月总订单量趋势图.png&#x27;)--保存图片</span></span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="柱状图绘制"><a href="#柱状图绘制" class="headerlink" title="柱状图绘制"></a>柱状图绘制</h3><ul>
<li><strong>plt.bar()函数</strong><ul>
<li>plt.bar()的参数是 x 和 height，height 表示柱子的高(对应 y 坐标值）； alpha 参数表示图表的透明度</li>
<li>plt.bar(x,height=y,color=’颜色’,alpha=c)</li>
<li>c为0到1</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"><span class="comment"># 绘制柱状图，并调整颜色为深橘色，透明度为 60%</span></span><br><span class="line">plt.bar(x, height=y, color=<span class="string">&#x27;darkorange&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250770.png" alt="image-20210820223956663"></p>
<h3 id="设置图标标题，坐标轴"><a href="#设置图标标题，坐标轴" class="headerlink" title="设置图标标题，坐标轴"></a>设置图标标题，坐标轴</h3><h4 id="plt-title-函数"><a href="#plt-title-函数" class="headerlink" title="plt.title()函数"></a><strong>plt.title()函数</strong></h4><ul>
<li>plt.title(lable,fontsize=None)</li>
<li>label表示标题，为字符串类型；fontsize为字体大小，为数值类型</li>
<li>还可用fontdict代替fontsize</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250818.png" alt="image-20210820164926230"></p>
<ul>
<li>width 则需要传入(0, 1]区间 (大于 0，小于等于 1) 内的浮点数，数值越大表示柱子的宽度越宽；当 width 的值为 1 时，柱子之间的间隙就为 0。</li>
<li>参数 alpha可以设置柱子颜色的透明度，需要传入(0, 1]区间内的浮点数，数值越小，表示柱子颜色越浅；相反，则越深。适当地调整颜色深浅，可以提升视觉舒适度。</li>
</ul>
<h4 id="设置坐标轴刻度"><a href="#设置坐标轴刻度" class="headerlink" title="设置坐标轴刻度"></a>设置坐标轴刻度</h4><ul>
<li>坐标轴刻度，设置 x、y 轴刻度的函数分别是 plt.xticks()和 plt.yticks()。</li>
<li>调用这两个函数，就可以根据 x、y 坐标值自动生成 x、y 轴刻度字体大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.xticks(fontsize=<span class="number">12</span>, rotation=<span class="number">90</span>)<span class="comment"># 设置坐标轴的刻度字体大小，逆时针旋转x轴刻度90度</span></span><br><span class="line">plt.yticks(fontsize=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h4 id="坐标轴标题"><a href="#坐标轴标题" class="headerlink" title="坐标轴标题"></a>坐标轴标题</h4><ul>
<li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251763.png" alt="image-20210820165429945"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;闪光科技2020年各季度研发费用分布图&#x27;</span>, fontdict=&#123;</span><br><span class="line">        <span class="string">&#x27;family&#x27;</span>: <span class="string">&#x27;SimHei&#x27;</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;size&#x27;</span>: <span class="number">16</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">plt.bar(x, height=y, color=<span class="string">&#x27;darkorange&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;季度&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line"><span class="comment"># 设置 x、y 轴标题分别为&#x27;季度&#x27;、&#x27;研发费用（百万元）&#x27;，字体大小均为 15</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;研发费用（百万元）&#x27;</span>,fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure>
<h4 id="设置图例"><a href="#设置图例" class="headerlink" title="设置图例"></a>设置图例</h4><ul>
<li>设置图例用到 <strong>plt.legend()</strong>函数，其中的参数labels表示图例名称，对应图中的多个条件，通常传入可迭代对象，比如列表、Series 对象等。</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251987.png" alt="image-20210820213925177"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.legend([<span class="string">&#x27;变化&#x27;</span>，<span class="string">&#x27;分布&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="设置数据标签"><a href="#设置数据标签" class="headerlink" title="设置数据标签"></a>设置数据标签</h4><ul>
<li>调用 plt.text()函数可以在图表的指定位置添加文本，但是每次只能添加一个。</li>
<li>这里需要重点强调 x、y 的用法，x、<code>y</code> 表示所添加文本的位置，受到函数本身的属性限制，常见为数值或者字符串类型，这与绘图函数中 x、y 可以传入可迭代对象有很大的差异。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.text(<span class="string">&#x27;第三季度&#x27;</span>, <span class="number">68</span>, <span class="number">68</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>, fontsize=<span class="number">12</span>)<span class="comment">#只给第三季度设置数据标签</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251708.png" alt="image-20210820214155006"></p>
<ul>
<li><p><strong>zip（）函数</strong></p>
<ul>
<li><p>zip(x,y)</p>
</li>
<li><p>你可以将 <code>zip()</code>函数理解为拉链，<code>x=(x1, x2, x3,……, xn)</code>为拉链的左边，<code>y=(y1, y2, y3,……, yn)</code>为拉链的右边，经过 <code>zip()</code>函数，就合并为<code>(x1, y1), (x2, y2), (x3, y3),……,(xn, yn)</code>。</p>
</li>
<li><code>zip()</code>函数可以从 x、y 元素序列中依次取出元素，按照顺序进行一对一匹配。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">plt.bar(x, height=y, color=<span class="string">&#x27;darkorange&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置数据标签</span></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(x, y):<span class="comment">#x,y数据一一对应</span></span><br><span class="line">    plt.text(a, b, b, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 x 坐标值</span></span><br><span class="line">x = order_number.index<span class="comment">#返回的是一个 index 对象，里面存储了月份信息。</span></span><br><span class="line"><span class="comment"># 设置 y 坐标值</span></span><br><span class="line">y = order_number.values  <span class="comment">#values返回的是一个 array 对象，里面存储了各月口罩订单总量的信息</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251010.png" alt="image-20210820223704165"></p>
</li>
</ul>
<h4 id="Series-对象排序"><a href="#Series-对象排序" class="headerlink" title="Series 对象排序"></a>Series 对象排序</h4><ul>
<li>在 pandas 中，我们可以使用<code>s.sort_values()</code>对 Series 对象的数值型数据进行排序。</li>
<li>默认为升序排列（从小到大），将 <strong>ascending</strong> 参数设置为 False 就可以让它降序排列（从大到小）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 降序排列sales_sum</span></span><br><span class="line">sales_sum = sales_sum.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="C:\Users\win10\Desktop\下载\43G6VFT71612681434803.png" alt="43G6VFT71612681434803"></p>
<h1 id="Apriori-算法"><a href="#Apriori-算法" class="headerlink" title="Apriori 算法"></a>Apriori 算法</h1><h2 id="设置列索引值"><a href="#设置列索引值" class="headerlink" title="设置列索引值"></a>设置列索引值</h2><ul>
<li>以<strong>字典</strong>作为数据传入时，字典的<strong>键</strong>会作为 DataFrame 对象的列名显示，而字典的<strong>值</strong>会作为对象的列数据显示。</li>
<li>以<strong>嵌套列表</strong>作为数据传入时，列表的元素会作为 DataFrame 对象的行数据显示，且会为数据默认生成从 0 开始的列名。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dict_1 = &#123;<span class="string">&#x27;年龄&#x27;</span>: [<span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>], <span class="string">&#x27;岗位&#x27;</span>: [<span class="string">&#x27;客服&#x27;</span>, <span class="string">&#x27;运营&#x27;</span>, <span class="string">&#x27;公关&#x27;</span>], <span class="string">&#x27;年购买量&#x27;</span>: [<span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>]&#125;</span><br><span class="line">jobs_df = pd.DataFrame(dict_1)</span><br><span class="line"><span class="built_in">print</span>(jobs_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========================&#x27;</span>)</span><br><span class="line">goods_info = [</span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">77.675</span>, <span class="string">&#x27;47箱&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">58.755</span>, <span class="string">&#x27;40箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">7.385</span>, <span class="string">&#x27;285盒&#x27;</span>, <span class="string">&#x27;广西南宁仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">34.823</span>, <span class="string">&#x27;20件&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">62.648</span>, <span class="string">&#x27;30箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">45.75</span>, <span class="string">&#x27;12箱&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">5.235</span>, <span class="string">&#x27;148盒&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">33.736</span>, <span class="string">&#x27;28件&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>]<span class="comment">#列表内一个列表代表一行</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">goods_df = pd.DataFrame(goods_info)</span><br><span class="line"><span class="built_in">print</span>(goods_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----------------------&#x27;</span>)</span><br><span class="line">newgoods_df = pd.DataFrame(goods_info, columns=[<span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;单价&#x27;</span>, <span class="string">&#x27;库存&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>])<span class="comment">#colums可以设置列名</span></span><br><span class="line"><span class="built_in">print</span>(newgoods_df)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数 columns 的值可以是一个列表，该列表的长度需与传入 DataFrame() 的列表的元素长度一致</p>
</li>
<li><p>已创建的DataFrame对象列表名修改</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">goods_df.columns = [<span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;单价&#x27;</span>, <span class="string">&#x27;库存&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>]<span class="comment"># 修改 goods_df 的列名</span></span><br></pre></td></tr></table></figure>
<h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><h3 id="sort-values-by-方法"><a href="#sort-values-by-方法" class="headerlink" title="sort_values(by) 方法"></a>sort_values(by) 方法</h3><ul>
<li>该方法可以对指定列进行排序操作，默认升序排列;by可为列名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依照【单价】列的数据进行排序</span></span><br><span class="line">sorted_goods = newgoods_df.sort_values(by=<span class="string">&#x27;单价&#x27;</span>)</span><br><span class="line"><span class="comment"># 提取【单价】列的数据进行排序</span></span><br><span class="line">newgoods_df[<span class="string">&#x27;单价&#x27;</span>].sort_values()</span><br></pre></td></tr></table></figure>
<h3 id="重置行索引"><a href="#重置行索引" class="headerlink" title="重置行索引"></a>重置行索引</h3><ul>
<li>重置索引可以使用 reset_index() 方法<ul>
<li>drop的值为False时保留原来的索引；drop的值为True时重置索引（从0开始）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置数据 sorted_goods 的行索引</span></span><br><span class="line">reset_goods = sorted_goods.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">reset_goods</span><br></pre></td></tr></table></figure>
<h3 id="数值的四舍五入"><a href="#数值的四舍五入" class="headerlink" title="数值的四舍五入"></a>数值的四舍五入</h3><ul>
<li>round()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reset_goods[<span class="string">&#x27;单价&#x27;</span>] = <span class="built_in">round</span>(reset_goods[<span class="string">&#x27;单价&#x27;</span>], <span class="number">2</span>)<span class="comment">#2表示保留2位小数</span></span><br></pre></td></tr></table></figure>
<h3 id="去除数据单位"><a href="#去除数据单位" class="headerlink" title="去除数据单位"></a>去除数据单位</h3><ul>
<li>s.agg(func)<ul>
<li>agg() 中的参数 func 可以为自定义的函数名，如我们上方定义的 new_func()</li>
<li>传入自定义的函数时，<strong>只需要写上函数名</strong>，不需要加上括号以及函数的参数</li>
</ul>
</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251017.png" alt="image-20210827204737110"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_func</span>(<span class="params">data</span>):<span class="comment"># 定义函数 new_func()</span></span><br><span class="line">    number = data[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(number)</span><br><span class="line"></span><br><span class="line">goods_info = [</span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">77.675</span>, <span class="string">&#x27;47箱&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">58.755</span>, <span class="string">&#x27;40箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">7.385</span>, <span class="string">&#x27;285盒&#x27;</span>, <span class="string">&#x27;广西南宁仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">34.823</span>, <span class="string">&#x27;20件&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">62.648</span>, <span class="string">&#x27;30箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">45.75</span>, <span class="string">&#x27;12箱&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">5.235</span>, <span class="string">&#x27;148盒&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">33.736</span>, <span class="string">&#x27;28件&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">#给列赋值名称</span></span><br><span class="line"></span><br><span class="line">goods_df = pd.DataFrame(goods_info, columns=[<span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;单价&#x27;</span>, <span class="string">&#x27;库存&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 agg() 方法对【库存】列的数据进行切片处理</span></span><br><span class="line">goods_df[<span class="string">&#x27;库存&#x27;</span>] = goods_df[<span class="string">&#x27;库存&#x27;</span>].agg(new_func)</span><br><span class="line"><span class="built_in">print</span>(goods_df)</span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251747.png" alt="image-20210827204856980"></p>
<ul>
<li>同时输出多个内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义字典 dict_2</span></span><br><span class="line">dict_2 = &#123;</span><br><span class="line">    <span class="string">&#x27;单价&#x27;</span>: <span class="string">&#x27;mean&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;库存&#x27;</span>: <span class="string">&#x27;sum&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 同时计算各食品的平均单价和总库存量</span></span><br><span class="line">reset_goods.groupby(<span class="string">&#x27;名称&#x27;</span>).agg(dict_2)</span><br></pre></td></tr></table></figure>
<h2 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251931.png" alt="image-20210827211810206"></p>
<h3 id="Python-调用-apriori-函数"><a href="#Python-调用-apriori-函数" class="headerlink" title="Python 调用 apriori 函数"></a>Python 调用 apriori 函数</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251193.png" alt="image-20210827212016647"></p>
<h2 id="实事绘图"><a href="#实事绘图" class="headerlink" title="实事绘图"></a>实事绘图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ax = []                    <span class="comment"># 定义一个 x 轴的空列表用来接收动态的数据</span></span><br><span class="line">ay = []                    <span class="comment"># 定义一个 y 轴的空列表用来接收动态的数据</span></span><br><span class="line">a1=[]</span><br><span class="line">b1=[]</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line">plt.ion()                  <span class="comment"># 开启一个画图的窗口</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):       <span class="comment"># 遍历0-99的值</span></span><br><span class="line">    ax.append(i)           <span class="comment"># 添加 i 到 x 轴的数据中</span></span><br><span class="line">    ay.append(i**<span class="number">2</span>)        <span class="comment"># 添加 i 的平方到 y 轴的数据中</span></span><br><span class="line">    a1.append(i*<span class="number">2</span>)</span><br><span class="line">    j=j+<span class="number">1</span></span><br><span class="line">    b1.append(i*<span class="number">3</span>)</span><br><span class="line">    plt.clf()              <span class="comment"># 清除之前画的图</span></span><br><span class="line">    plt.plot(ax,ay)        <span class="comment"># 画出当前 ax 列表和 ay 列表中的值的图形</span></span><br><span class="line">    plt.plot(a1,b1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(j)+<span class="string">&quot;次输出图像&quot;</span>)</span><br><span class="line">    plt.pause(<span class="number">0.5</span>)         <span class="comment"># 暂停一秒</span></span><br><span class="line">    plt.ioff()             <span class="comment">#</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>7.python基础实时绘图</title>
    <url>/blot.github.io/2022/04/03/7.%E5%AE%9E%E6%97%B6%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="7-实时绘图"><a href="#7-实时绘图" class="headerlink" title="7.实时绘图"></a>7.<a href="https://blog.csdn.net/eefresher/article/details/90022648?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=matplotlib.pyplot%E7%BB%95%E5%8E%9F%E7%82%B9%E7%BB%98%E5%9B%BE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-90022648.142^v9^control,157^v4^control&amp;spm=1018.2226.3001.4187">实时绘图</a></h1><h2 id="math函数"><a href="#math函数" class="headerlink" title="math函数"></a>math函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span> (math.sin(pi/<span class="number">2</span>))<span class="comment">#用弧度</span></span><br><span class="line"><span class="built_in">print</span>(math.sin(math.radians(<span class="number">90</span>)))<span class="comment">#度数</span></span><br></pre></td></tr></table></figure>
<p>实时绘图例子</p>
<h2 id="matplotlib-pyplot"><a href="#matplotlib-pyplot" class="headerlink" title="matplotlib.pyplot"></a>matplotlib.pyplot</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#控制图的x,y坐标轴的取值范围</span></span><br><span class="line">plt.axis([-<span class="number">1</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">80</span>])</span><br><span class="line"><span class="comment">#直接绘图</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = [<span class="number">1.2</span>, <span class="number">2.5</span>, <span class="number">4.5</span>, <span class="number">7.3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot函数作图</span></span><br><span class="line">plt.plot(x, y)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># show函数展示出这个图，如果没有这行代码，则程序完成绘图，但看不到</span></span><br><span class="line">plt.show()  </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ax = []                    <span class="comment"># 定义一个 x 轴的空列表用来接收动态的数据</span></span><br><span class="line">ay = []                    <span class="comment"># 定义一个 y 轴的空列表用来接收动态的数据</span></span><br><span class="line">a1=[]</span><br><span class="line">b1=[]</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line">plt.ion()                  <span class="comment"># 开启一个画图的窗口</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):       <span class="comment"># 遍历0-99的值</span></span><br><span class="line">    ax.append(i)           <span class="comment"># 添加 i 到 x 轴的数据中</span></span><br><span class="line">    ay.append(i**<span class="number">2</span>)        <span class="comment"># 添加 i 的平方到 y 轴的数据中</span></span><br><span class="line">    a1.append(i*<span class="number">2</span>)</span><br><span class="line">    j=j+<span class="number">1</span></span><br><span class="line">    b1.append(i*<span class="number">3</span>)</span><br><span class="line">    plt.clf()              <span class="comment"># 清除之前画的图</span></span><br><span class="line">    plt.plot(ax,ay)        <span class="comment"># 画出当前 ax 列表和 ay 列表中的值的图形</span></span><br><span class="line">    plt.plot(a1,b1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(j)+<span class="string">&quot;次输出图像&quot;</span>)</span><br><span class="line">    plt.pause(<span class="number">0.5</span>)         <span class="comment"># 暂停一秒</span></span><br><span class="line">    plt.ioff()             <span class="comment">#防止图形一闪而过</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>连接两个端点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">p1 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">p2 = [<span class="number">3</span>, <span class="number">50</span>]</span><br><span class="line"><span class="comment"># 第一个参数是x的取值范围 第二个参数是y的取值范围</span></span><br><span class="line">plt.plot([p1[<span class="number">0</span>], p2[<span class="number">0</span>]], [p1[<span class="number">1</span>], p2[<span class="number">1</span>]], color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># 画点</span></span><br><span class="line">plt.scatter([p1[<span class="number">0</span>], p2[<span class="number">0</span>]], [p1[<span class="number">1</span>], p2[<span class="number">1</span>]], color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>绕原点旋转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">L1=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#P2坐标</span></span><br><span class="line">p1=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    a1=math.cos(math.radians(i))</span><br><span class="line">    b1=math.sin(math.radians(i))</span><br><span class="line">    ax=L1*a1</span><br><span class="line">    ay=L1*b1</span><br><span class="line">    p2 = [ax, ay]</span><br><span class="line">    plt.clf()              <span class="comment"># 清除之前画的图</span></span><br><span class="line">    plt.plot([p1[<span class="number">0</span>], p2[<span class="number">0</span>]], [p1[<span class="number">1</span>], p2[<span class="number">1</span>]], color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="comment">#坐标轴</span></span><br><span class="line">    plt.plot([<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">4</span>,<span class="number">4</span>], color=<span class="string">&#x27;k&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>)</span><br><span class="line">    plt.plot([-<span class="number">4</span>, <span class="number">4</span>], [<span class="number">0</span>,<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>)</span><br><span class="line">    plt.axis([-<span class="number">4</span>,<span class="number">4</span>,-<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">    plt.scatter([p1[<span class="number">0</span>], p2[<span class="number">0</span>]], [p1[<span class="number">1</span>], p2[<span class="number">1</span>]], color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    plt.pause(<span class="number">0.1</span>)         <span class="comment"># 暂停一秒</span></span><br><span class="line">    j=j+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(j)+<span class="string">&quot;次运行&quot;</span>)</span><br><span class="line">    plt.ioff()             <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>四足运动学正解</p>
<ul>
<li>已知肩部，大腿小腿的角度，求足端坐标</li>
<li>力控</li>
</ul>
<p>运动学逆解</p>
<ul>
<li>已知足端坐标，求大腿小腿角度</li>
<li>位控</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">time=<span class="number">0</span></span><br><span class="line">t=[]</span><br><span class="line">S=<span class="number">100</span></span><br><span class="line">H=<span class="number">30</span></span><br><span class="line">T=<span class="number">2.0</span></span><br><span class="line">Tf=<span class="number">1.0</span></span><br><span class="line">Ts=T-Tf</span><br><span class="line">x=[]</span><br><span class="line">y=[]</span><br><span class="line">t=[]</span><br><span class="line">Fe=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    time=time+<span class="number">0.001</span></span><br><span class="line">    t.append(time)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">    fe=(i/Tf)-<span class="number">1.0</span>/(<span class="number">4</span>*math.pi)*math.sin(<span class="number">4</span>*math.pi*i/Tf)</span><br><span class="line">    Fe.append(fe)</span><br><span class="line"><span class="keyword">for</span> t1,fe1 <span class="keyword">in</span> <span class="built_in">zip</span>(t,Fe):</span><br><span class="line">    <span class="keyword">if</span> t1&lt;Tf/<span class="number">2</span>:</span><br><span class="line">        sgn = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> t1&gt;=Tf/<span class="number">2</span>:</span><br><span class="line">        sgn=-<span class="number">1</span></span><br><span class="line">    x.append(S*( t1/Tf-<span class="number">1</span>/(<span class="number">2</span>*math.pi)*math.sin(<span class="number">2</span>*math.pi*t1/Tf)))</span><br><span class="line">    y.append(H*(sgn*(<span class="number">2</span>*fe1-<span class="number">1</span>)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># #x——y位移图像</span></span><br><span class="line"><span class="comment"># ax=[]</span></span><br><span class="line"><span class="comment"># ay=[]</span></span><br><span class="line"><span class="comment"># j=1</span></span><br><span class="line"><span class="comment"># for x1,y1 in zip(x,y):       # 遍历0-99的值</span></span><br><span class="line"><span class="comment">#     ax.append(x1)           # 添加 i 到 x 轴的数据中</span></span><br><span class="line"><span class="comment">#     ay.append(y1) </span></span><br><span class="line"><span class="comment">#     plt.clf()              # 清除之前画的图</span></span><br><span class="line"><span class="comment">#     plt.plot(ax,ay)        # 画出当前 ax 列表和 ay 列表中的值的图形</span></span><br><span class="line"><span class="comment">#     j=j+1</span></span><br><span class="line"><span class="comment">#     print(&quot;第&quot;+str(j)+&quot;次输出图像&quot;)</span></span><br><span class="line"><span class="comment">#     plt.pause(0.01)         # 暂停一秒</span></span><br><span class="line"><span class="comment">#     plt.ioff()             #防止图形一闪而过</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">L=[<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span>,<span class="number">120</span>,<span class="number">60</span>,<span class="number">0</span>]</span><br><span class="line">angle1_1=[]</span><br><span class="line">angle1_2=[]</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(x,y):</span><br><span class="line">    a=<span class="number">2</span>*L[<span class="number">0</span>]*i</span><br><span class="line">    b=<span class="number">2</span>*L[<span class="number">0</span>]*j</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i:&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot; j:&quot;</span>+<span class="built_in">str</span>(j))</span><br><span class="line">    c=i**<span class="number">2</span>+j**<span class="number">2</span>+L[<span class="number">0</span>]**<span class="number">2</span>-(L[<span class="number">1</span>]+L[<span class="number">5</span>])**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((a**<span class="number">2</span>+b**<span class="number">2</span>-c**<span class="number">2</span>)&gt;<span class="number">0</span>):</span><br><span class="line">        p=<span class="number">2</span>*math.atan((b-math.sqrt(a**<span class="number">2</span>+b**<span class="number">2</span>-c**<span class="number">2</span>))/(a+c))</span><br><span class="line">        <span class="comment"># print(p)</span></span><br><span class="line">        angle1_2.append(p)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># print(&quot;a:&quot;+str(a)+&quot;  b:&quot;+str(b)+&quot;  c:&quot;+str(c))</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##绘图两点</span></span><br><span class="line"><span class="comment"># p1=[0,0]</span></span><br><span class="line"><span class="comment"># j=0</span></span><br><span class="line"><span class="comment"># for i in angle1_2:</span></span><br><span class="line"><span class="comment">#     a1=math.cos(math.radians(i))</span></span><br><span class="line"><span class="comment">#     b1=math.sin(math.radians(i))</span></span><br><span class="line"><span class="comment">#     ax=L[0]*a1</span></span><br><span class="line"><span class="comment">#     ay=L[0]*b1</span></span><br><span class="line"><span class="comment">#     p2 = [ax, ay]</span></span><br><span class="line"><span class="comment">#     plt.clf()              # 清除之前画的图</span></span><br><span class="line"><span class="comment">#     plt.plot([p1[0], p2[0]], [p1[1], p2[1]], color=&#x27;r&#x27;)</span></span><br><span class="line"><span class="comment">#     #坐标轴</span></span><br><span class="line"><span class="comment">#     plt.plot([0, 0], [-300,300], color=&#x27;k&#x27;,linestyle=&quot;-.&quot;)</span></span><br><span class="line"><span class="comment">#     plt.plot([-300, 300], [0,0], color=&#x27;k&#x27;,linestyle=&quot;-.&quot;)</span></span><br><span class="line"><span class="comment">#     plt.axis([-300,300,-300,300])</span></span><br><span class="line"><span class="comment">#     plt.scatter([p1[0], p2[0]], [p1[1], p2[1]], color=&#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">#     plt.pause(0.1)         # 暂停一秒</span></span><br><span class="line"><span class="comment">#     j=j+1</span></span><br><span class="line"><span class="comment">#     print(&quot;第&quot;+str(j)+&quot;次运行&quot;)</span></span><br><span class="line"><span class="comment">#     plt.ioff()             #</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="四足"><a href="#四足" class="headerlink" title="四足"></a>四足</h1><h2 id="五连杆matlab代码"><a href="#五连杆matlab代码" class="headerlink" title="五连杆matlab代码"></a><strong>五连杆matlab代码</strong></h2><p><strong>求x-y位移轨迹</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">time=<span class="number">0</span>;</span><br><span class="line">S = <span class="number">100</span>;<span class="comment">%步长</span></span><br><span class="line">H = <span class="number">30</span>;<span class="comment">%抬腿高度</span></span><br><span class="line">T = <span class="number">2.0</span>;<span class="comment">%步态周期</span></span><br><span class="line">Tf = <span class="number">1.0</span>;</span><br><span class="line">Ts = T - Tf;</span><br><span class="line">PI=<span class="number">3.1415926</span>;</span><br><span class="line">x = <span class="number">1</span>:<span class="number">1</span>:<span class="number">1000</span>;</span><br><span class="line">y = <span class="number">1</span>:<span class="number">1</span>:<span class="number">1000</span>;</span><br><span class="line">dx = <span class="number">0.001</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">dy = <span class="number">1</span>:<span class="number">1</span>:<span class="number">1000</span>;</span><br><span class="line">ddx = <span class="number">0.001</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">ddy = <span class="number">1</span>:<span class="number">1</span>:<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">time=time+<span class="number">0.001</span>;</span><br><span class="line">t = <span class="built_in">mod</span>(time,<span class="number">1.0</span>);</span><br><span class="line">Fe = (t/Tf)<span class="number">-1</span>/(<span class="number">4</span>*PI)*<span class="built_in">sin</span>(<span class="number">4</span>*PI*t/Tf);</span><br><span class="line">    <span class="keyword">if</span> t&lt;Tf/<span class="number">2</span></span><br><span class="line">        sgn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> t&gt;Tf/<span class="number">2</span></span><br><span class="line">        sgn=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">x(<span class="built_in">i</span>) = S*( t/Tf<span class="number">-1</span>/(<span class="number">2</span>*PI)*<span class="built_in">sin</span>(<span class="number">2</span>*PI*t/Tf));</span><br><span class="line">y(<span class="built_in">i</span>) = H*(sgn*(<span class="number">2</span>*Fe<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">tt = <span class="number">0.001</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;x-y位移图像&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">dx = diff(x)/<span class="number">0.001</span>;</span><br><span class="line">dx(<span class="number">1000</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">plot</span>(tt,dx);</span><br><span class="line">title(<span class="string">&quot;Vx-t图像&quot;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">250</span>]);<span class="comment">%设置坐标轴范围</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line">dy = diff(y)/<span class="number">0.001</span>;</span><br><span class="line">dy(<span class="number">1000</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">plot</span>(tt,dy);</span><br><span class="line">title(<span class="string">&quot;Vy-t图像&quot;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">120</span>]);<span class="comment">%设置坐标轴范围</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(tt,x);</span><br><span class="line">title(<span class="string">&quot;x-t图像&quot;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">120</span>]);<span class="comment">%设置坐标轴范围</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">plot</span>(tt,y);</span><br><span class="line">title(<span class="string">&quot;y-t图像&quot;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">35</span>]);<span class="comment">%设置坐标轴范围</span></span><br><span class="line"><span class="comment">% plot(y,t,&#x27;+&#x27;);</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">6</span>);</span><br><span class="line">ddx = diff(dx)/<span class="number">0.001</span>;</span><br><span class="line">ddx(<span class="number">1000</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">plot</span>(tt,ddx);</span><br><span class="line">title(<span class="string">&quot;Ax-t图像&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">8</span>);</span><br><span class="line">ddy = diff(dy)/<span class="number">0.001</span>;</span><br><span class="line">ddy(<span class="number">1000</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">plot</span>(tt,ddy);</span><br><span class="line">title(<span class="string">&quot;Ay-t图像&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="计算角度"><a href="#计算角度" class="headerlink" title="计算角度"></a><strong>计算角度</strong></h2><p><strong>逆解</strong></p>
<p>有三种情况注意角度计算</p>
<ol>
<li>当足端点落在第二象限时，左腿角度计算</li>
<li>当足端在第一象限且x&gt;L5</li>
<li>当足端在第一象限且x&lt;L5</li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204272316468.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">L=[<span class="number">0</span>,<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span>,<span class="number">120</span>,<span class="number">60</span>,<span class="number">0</span>]</span><br><span class="line">x=-<span class="number">102</span></span><br><span class="line">y=<span class="number">107</span></span><br><span class="line">a1=math.atan(math.fabs(y/x))</span><br><span class="line">h1=math.sqrt(x**<span class="number">2</span>+y**<span class="number">2</span>)</span><br><span class="line">t=(h1**<span class="number">2</span> + L[<span class="number">1</span>]**<span class="number">2</span>-L[<span class="number">2</span>]**<span class="number">2</span>)/(<span class="number">2</span>*h1*L[<span class="number">1</span>])</span><br><span class="line">a2=math.acos(t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;左边腿角度：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>):</span><br><span class="line">	<span class="comment">#腿在第一象限</span></span><br><span class="line">	<span class="built_in">print</span>(a1+a2)</span><br><span class="line">	<span class="comment"># print((a1+a2)*57.3)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="comment">#腿在第二象限</span></span><br><span class="line">	<span class="built_in">print</span>(math.pi-a1+a2)</span><br><span class="line">	<span class="comment"># print(180-(a1-a2)*57.3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算右腿</span></span><br><span class="line">a3=math.atan(y/(math.fabs(x-L[<span class="number">5</span>])))</span><br><span class="line">h2=math.sqrt(y**<span class="number">2</span>+(L[<span class="number">5</span>]-x)**<span class="number">2</span>)</span><br><span class="line">a4=(h2**<span class="number">2</span>+L[<span class="number">4</span>]**<span class="number">2</span>-L[<span class="number">3</span>]**<span class="number">2</span>)/(<span class="number">2</span>*L[<span class="number">4</span>]*h2)</span><br><span class="line">a5=math.acos(a4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;右腿角度：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(x&lt;L[<span class="number">5</span>]):</span><br><span class="line">	<span class="built_in">print</span>(math.pi-a3-a5)</span><br><span class="line">	<span class="comment"># print(180-(a3+a5)*57.3)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(a3-a5)</span><br><span class="line">	<span class="comment"># print((a3-a5)*57.3)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cmath <span class="keyword">import</span> pi</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">L=[<span class="number">0</span>,<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span>,<span class="number">120</span>,<span class="number">60</span>,<span class="number">0</span>]</span><br><span class="line">left_a=<span class="number">260</span>/(<span class="number">180</span>/math.pi)</span><br><span class="line">right_a=<span class="number">50</span>/(<span class="number">180</span>/math.pi)</span><br><span class="line"><span class="comment"># print(180/math.pi)</span></span><br><span class="line">Xa=L[<span class="number">1</span>]*math.cos(left_a)</span><br><span class="line">Ya=L[<span class="number">1</span>]*math.sin(left_a)</span><br><span class="line">Xc=L[<span class="number">5</span>]+L[<span class="number">4</span>]*math.cos(right_a)</span><br><span class="line">Yc=L[<span class="number">4</span>]*math.sin(right_a)</span><br><span class="line">lengAC=math.sqrt((Xc-Xa)**<span class="number">2</span>+(Yc-Ya)**<span class="number">2</span>)</span><br><span class="line">A=<span class="number">2</span>*L[<span class="number">2</span>]*(Xc-Xa)</span><br><span class="line">B=<span class="number">2</span>*L[<span class="number">2</span>]*(Yc-Ya)</span><br><span class="line">C=L[<span class="number">2</span>]**<span class="number">2</span>+lengAC**<span class="number">2</span>-L[<span class="number">3</span>]**<span class="number">2</span></span><br><span class="line">a1=<span class="number">2</span>*math.atan((B+math.sqrt(A**<span class="number">2</span>+B**<span class="number">2</span>-C**<span class="number">2</span>))/(A+C))</span><br><span class="line">x=Xa+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.cos(a1)</span><br><span class="line">y=Ya+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.sin(a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&quot;</span>+<span class="built_in">str</span>(x)+<span class="string">&quot; y:&quot;</span>+<span class="built_in">str</span>(y))</span><br><span class="line"><span class="comment">#左边为x范围，右边为y范围</span></span><br><span class="line">point=[[[<span class="number">0</span>,Xa],[Xa,x],[x,Xc],[L[<span class="number">5</span>],Xc]],[[<span class="number">0</span>,Ya],[Ya,y],[y,Yc],[<span class="number">0</span>,Yc]]]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_1</span>(<span class="params">point1,point2</span>):</span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(point1,point2):</span><br><span class="line">        plt.plot(i,j, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        plt.scatter(i,j, color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show_1(point[<span class="number">0</span>],point[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="已知文档数据"><a href="#已知文档数据" class="headerlink" title="已知文档数据"></a>已知文档数据</h2><p>获取txt文档数据</p>
<h3 id="已知角度求x-y坐标"><a href="#已知角度求x-y坐标" class="headerlink" title="已知角度求x,y坐标"></a>已知角度求x,y坐标</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cv2 <span class="keyword">import</span> kmeans</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\代码存储\\其他\\vscode配置\\.vscode\\python\\plot.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file_lines = file1.readlines()</span><br><span class="line">file1.close()</span><br><span class="line">file2 = <span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\代码存储\\其他\\vscode配置\\.vscode\\python\\ploty.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file_lines2 = file2.readlines()</span><br><span class="line">file2.close()</span><br><span class="line">leg_r=[]<span class="comment">#右腿角度</span></span><br><span class="line">leg_l=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_lines:   <span class="comment">#用for...in...把每一行的数据遍历  </span></span><br><span class="line">    datax =i.split()    <span class="comment">#把字符串切分成更细的一个个的字符串</span></span><br><span class="line">    leg_r.append(<span class="built_in">float</span>(datax[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_lines2:</span><br><span class="line">    datay=i.split()</span><br><span class="line">    leg_l.append(<span class="built_in">float</span>(datay[<span class="number">0</span>]))</span><br><span class="line">x=[]</span><br><span class="line">y=[]</span><br><span class="line">L=[<span class="number">0</span>,<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span>,<span class="number">120</span>,<span class="number">60</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_1</span>(<span class="params">point1,point2</span>):</span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(point1,point2):</span><br><span class="line">        plt.plot(i,j, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        plt.scatter(i,j, color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.ion() </span><br><span class="line">k=<span class="number">11</span></span><br><span class="line">nu=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(leg_l,leg_r):</span><br><span class="line">    left_a=i</span><br><span class="line">    right_a=j</span><br><span class="line"><span class="comment"># print(180/math.pi)</span></span><br><span class="line">    Xa=L[<span class="number">1</span>]*math.cos(left_a)</span><br><span class="line">    Ya=L[<span class="number">1</span>]*math.sin(left_a)</span><br><span class="line">    Xc=L[<span class="number">5</span>]+L[<span class="number">4</span>]*math.cos(right_a)</span><br><span class="line">    Yc=L[<span class="number">4</span>]*math.sin(right_a)</span><br><span class="line">    lengAC=math.sqrt((Xc-Xa)**<span class="number">2</span>+(Yc-Ya)**<span class="number">2</span>)</span><br><span class="line">    A=<span class="number">2</span>*L[<span class="number">2</span>]*(Xc-Xa)</span><br><span class="line">    B=<span class="number">2</span>*L[<span class="number">2</span>]*(Yc-Ya)</span><br><span class="line">    C=L[<span class="number">2</span>]**<span class="number">2</span>+lengAC**<span class="number">2</span>-L[<span class="number">3</span>]**<span class="number">2</span></span><br><span class="line">    a1=<span class="number">2</span>*math.atan((B+math.sqrt(A**<span class="number">2</span>+B**<span class="number">2</span>-C**<span class="number">2</span>))/(A+C))</span><br><span class="line">    x1=Xa+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.cos(a1)</span><br><span class="line">    y1=Ya+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.sin(a1)</span><br><span class="line">    k=k+<span class="number">1</span></span><br><span class="line">    plt.clf()</span><br><span class="line">    <span class="comment">#坐标轴</span></span><br><span class="line">    <span class="keyword">if</span> k%<span class="number">7</span>==<span class="number">0</span>:</span><br><span class="line">        </span><br><span class="line">        nu=nu+<span class="number">1</span></span><br><span class="line">        plt.plot([<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">300</span>,<span class="number">300</span>], color=<span class="string">&#x27;k&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>)</span><br><span class="line">        plt.plot([-<span class="number">300</span>, <span class="number">300</span>], [<span class="number">0</span>,<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>)</span><br><span class="line">        plt.axis([-<span class="number">400</span>,<span class="number">400</span>,-<span class="number">400</span>,<span class="number">400</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(k)+<span class="string">&quot;次输出图像&quot;</span>)</span><br><span class="line">        point=[[[<span class="number">0</span>,Xa],[Xa,x1],[x1,Xc],[L[<span class="number">5</span>],Xc]],[[<span class="number">0</span>,Ya],[Ya,y1],[y1,Yc],[<span class="number">0</span>,Yc]]]</span><br><span class="line">        show_1(point[<span class="number">0</span>],point[<span class="number">1</span>])</span><br><span class="line">        x.append(x1)</span><br><span class="line">        y.append(y1)</span><br><span class="line">        plt.plot(x,y)</span><br><span class="line">        plt.savefig(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\python处理\\&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(nu))<span class="comment">#保存图片</span></span><br><span class="line">        plt.pause(<span class="number">0.01</span>)         <span class="comment"># 暂停一秒</span></span><br><span class="line">    plt.ioff()  </span><br><span class="line"><span class="comment"># plt.plot(x, y)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # show函数展示出这个图，如果没有这行代码，则程序完成绘图，但看不到</span></span><br><span class="line"><span class="comment"># plt.show() </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="已知x-y求角度"><a href="#已知x-y求角度" class="headerlink" title="已知x,y求角度"></a>已知x,y求角度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import math</span><br><span class="line">file1 = open(&#x27;.vscode\python\plotxZB.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) </span><br><span class="line">file_lines = file1.readlines()</span><br><span class="line">file1.close()</span><br><span class="line">file2 = open(&#x27;.vscode\python\plotyZB.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) </span><br><span class="line">file_lines2 = file2.readlines()</span><br><span class="line">file2.close()</span><br><span class="line">x=[]#x坐标</span><br><span class="line">y=[]</span><br><span class="line">for i in file_lines:   #用for...in...把每一行的数据遍历  </span><br><span class="line">    datax =i.split()    #把字符串切分成更细的一个个的字符串</span><br><span class="line">    x.append(float(datax[0]))</span><br><span class="line">for i in file_lines2:</span><br><span class="line">    datay=i.split()</span><br><span class="line">    y.append(float(datay[0]))</span><br><span class="line"></span><br><span class="line">L=[0,120,240,240,120,60,0]</span><br><span class="line">k=0</span><br><span class="line">for i,j in zip(x,y):</span><br><span class="line">    x1=i</span><br><span class="line">    y1=j</span><br><span class="line">    a1=math.atan(math.fabs(y1/x1))</span><br><span class="line">    h1=math.sqrt(x1**2+y1**2)</span><br><span class="line">    t=(h1**2 + L[1]**2-L[2]**2)/(2*h1*L[1])</span><br><span class="line">    print(&quot;i:&quot;+str(i)+&quot; j:&quot;+str(j)+&quot; &quot;+str(t))</span><br><span class="line">    a2=math.acos(t)</span><br><span class="line">    # print(&quot;左边腿角度：&quot;)</span><br><span class="line">    if(x1&gt;0):</span><br><span class="line">	#腿在第一象限</span><br><span class="line">        print(a1+a2)</span><br><span class="line">        # print((a1+a2)*57.3)</span><br><span class="line">    else:</span><br><span class="line">    #腿在第二象限</span><br><span class="line">        print(math.pi-a1+a2)</span><br><span class="line">    # print(180-(a1-a2)*57.3)</span><br><span class="line"></span><br><span class="line">#计算右腿</span><br><span class="line">    a3=math.atan(y1/(math.fabs(x1-L[5])))</span><br><span class="line">    h2=math.sqrt(y1**2+(L[5]-x1)**2)</span><br><span class="line">    a4=(h2**2+L[4]**2-L[3]**2)/(2*L[4]*h2)</span><br><span class="line">    a5=math.acos(a4)</span><br><span class="line">    # print(&quot;右腿角度：&quot;)</span><br><span class="line">    if(x1&lt;L[5]):</span><br><span class="line">        print(math.pi-a3-a5)</span><br><span class="line">    # print(180-(a3+a5)*57.3)</span><br><span class="line">    else:</span><br><span class="line">        print(a3-a5)</span><br><span class="line">    # print((a3-a5)*57.3)</span><br><span class="line">    k=k+1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>已知坐标求角度，再用角度求坐标图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cv2 <span class="keyword">import</span> kmeans</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">leg_r=[-<span class="number">0.06</span>,-<span class="number">0.977141</span>]<span class="comment">#右腿角度</span></span><br><span class="line">leg_l=[<span class="number">0.06</span>+math.pi,<span class="number">0.977141</span>+math.pi]</span><br><span class="line"></span><br><span class="line">x=[]</span><br><span class="line">y=[]</span><br><span class="line">L=[<span class="number">0</span>,<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span>,<span class="number">120</span>,<span class="number">60</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_1</span>(<span class="params">point1,point2</span>):</span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(point1,point2):</span><br><span class="line">        plt.plot(i,j, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        plt.scatter(i,j, color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.ion() </span><br><span class="line">k=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(leg_l,leg_r):</span><br><span class="line">    left_a=i</span><br><span class="line">    right_a=j</span><br><span class="line"><span class="comment"># print(180/math.pi)</span></span><br><span class="line">    Xa=L[<span class="number">1</span>]*math.cos(left_a)</span><br><span class="line">    Ya=L[<span class="number">1</span>]*math.sin(left_a)</span><br><span class="line">    Xc=L[<span class="number">5</span>]+L[<span class="number">4</span>]*math.cos(right_a)</span><br><span class="line">    Yc=L[<span class="number">4</span>]*math.sin(right_a)</span><br><span class="line">    lengAC=math.sqrt((Xc-Xa)**<span class="number">2</span>+(Yc-Ya)**<span class="number">2</span>)</span><br><span class="line">    A=<span class="number">2</span>*L[<span class="number">2</span>]*(Xc-Xa)</span><br><span class="line">    B=<span class="number">2</span>*L[<span class="number">2</span>]*(Yc-Ya)</span><br><span class="line">    C=L[<span class="number">2</span>]**<span class="number">2</span>+lengAC**<span class="number">2</span>-L[<span class="number">3</span>]**<span class="number">2</span></span><br><span class="line">    a1=<span class="number">2</span>*math.atan((B+math.sqrt(A**<span class="number">2</span>+B**<span class="number">2</span>-C**<span class="number">2</span>))/(A+C))</span><br><span class="line">    x1=Xa+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.cos(a1)</span><br><span class="line">    y1=Ya+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.sin(a1)</span><br><span class="line">    k=k+<span class="number">1</span></span><br><span class="line">    plt.clf()</span><br><span class="line">    <span class="comment">#坐标轴</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(k)+<span class="string">&quot;次输出图像&quot;</span>)</span><br><span class="line">   </span><br><span class="line">    point=[[[<span class="number">0</span>,Xa],[Xa,x1],[x1,Xc],[L[<span class="number">5</span>],Xc]],[[<span class="number">0</span>,Ya],[Ya,y1],[y1,Yc],[<span class="number">0</span>,Yc]]]</span><br><span class="line">    show_1(point[<span class="number">0</span>],point[<span class="number">1</span>])</span><br><span class="line">    x.append(x1)</span><br><span class="line">    y.append(y1)</span><br><span class="line">    plt.plot(x,y)</span><br><span class="line">    plt.plot([<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">300</span>,<span class="number">300</span>], color=<span class="string">&#x27;k&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>)</span><br><span class="line">    plt.plot([-<span class="number">300</span>, <span class="number">300</span>], [<span class="number">0</span>,<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>)</span><br><span class="line">    plt.axis([-<span class="number">200</span>,<span class="number">200</span>,-<span class="number">150</span>,<span class="number">270</span>])</span><br><span class="line">    plt.savefig(<span class="string">&#x27;.vscode\python\img\&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(k))<span class="comment">#保存图片</span></span><br><span class="line">    plt.pause(<span class="number">5</span>)         <span class="comment"># 暂停一秒</span></span><br><span class="line">    plt.ioff()  </span><br><span class="line"><span class="comment"># plt.plot(x, y)  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>已知角度画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cv2 <span class="keyword">import</span> kmeans</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">leg_r=[-<span class="number">0.435223</span>,-<span class="number">0.977141</span>]<span class="comment">#右腿角度</span></span><br><span class="line">leg_l=[<span class="number">1.5708</span>+math.pi,<span class="number">0.977141</span>+math.pi]</span><br><span class="line"></span><br><span class="line">x=[]</span><br><span class="line">y=[]</span><br><span class="line">L=[<span class="number">0</span>,<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span>,<span class="number">120</span>,<span class="number">60</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_1</span>(<span class="params">point1,point2</span>):</span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(point1,point2):</span><br><span class="line">        plt.plot(i,j, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        plt.scatter(i,j, color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.ion() </span><br><span class="line">k=<span class="number">11</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(leg_l,leg_r):</span><br><span class="line">    left_a=i</span><br><span class="line">    right_a=j</span><br><span class="line"><span class="comment"># print(180/math.pi)</span></span><br><span class="line">    Xa=L[<span class="number">1</span>]*math.cos(left_a)</span><br><span class="line">    Ya=L[<span class="number">1</span>]*math.sin(left_a)</span><br><span class="line">    Xc=L[<span class="number">5</span>]+L[<span class="number">4</span>]*math.cos(right_a)</span><br><span class="line">    Yc=L[<span class="number">4</span>]*math.sin(right_a)</span><br><span class="line">    lengAC=math.sqrt((Xc-Xa)**<span class="number">2</span>+(Yc-Ya)**<span class="number">2</span>)</span><br><span class="line">    A=<span class="number">2</span>*L[<span class="number">2</span>]*(Xc-Xa)</span><br><span class="line">    B=<span class="number">2</span>*L[<span class="number">2</span>]*(Yc-Ya)</span><br><span class="line">    C=L[<span class="number">2</span>]**<span class="number">2</span>+lengAC**<span class="number">2</span>-L[<span class="number">3</span>]**<span class="number">2</span></span><br><span class="line">    a1=<span class="number">2</span>*math.atan((B+math.sqrt(A**<span class="number">2</span>+B**<span class="number">2</span>-C**<span class="number">2</span>))/(A+C))</span><br><span class="line">    x1=Xa+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.cos(a1)</span><br><span class="line">    y1=Ya+(L[<span class="number">2</span>]+L[<span class="number">6</span>])*math.sin(a1)</span><br><span class="line">    k=k+<span class="number">1</span></span><br><span class="line">    plt.clf()</span><br><span class="line">    <span class="comment">#坐标轴</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(k)+<span class="string">&quot;次输出图像&quot;</span>)</span><br><span class="line">    point=[[[<span class="number">0</span>,Xa],[Xa,x1],[x1,Xc],[L[<span class="number">5</span>],Xc]],[[<span class="number">0</span>,Ya],[Ya,y1],[y1,Yc],[<span class="number">0</span>,Yc]]]</span><br><span class="line">    show_1(point[<span class="number">0</span>],point[<span class="number">1</span>])</span><br><span class="line">    x.append(x1)</span><br><span class="line">    y.append(y1)</span><br><span class="line">    plt.plot(x,y)</span><br><span class="line">    plt.pause(<span class="number">5</span>)         <span class="comment"># 暂停一秒</span></span><br><span class="line">    plt.ioff()  </span><br><span class="line"><span class="comment"># plt.plot(x, y)  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>7.数组与指针——C语言</title>
    <url>/blot.github.io/2022/03/03/7%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="七、数组与指针"><a href="#七、数组与指针" class="headerlink" title="七、数组与指针"></a>七、数组与指针</h1><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维素组"><a href="#一维素组" class="headerlink" title="一维素组"></a>一维素组</h2><ul>
<li>定义：基类型   a[b];</li>
<li>a为数组名；b为数组长度，数组下标从0开始，取不到b</li>
<li>不能用变量来定义数组长度：int  a[n];</li>
<li>使用宏定义可以：int a[N];N已定义</li>
<li>占内存字节数：数组长度*sizeof(基类型)</li>
</ul>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">60</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;<span class="comment">//花括号元素个数不能超过数组长度</span></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//根据花括号元素个数来确定数组大小</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过<strong>memset（a,0,sizeof(a)）;</strong>初始化</li>
<li>sizeof(a)获取数组a所占内存字节数</li>
<li>记得开头加#include<string.h></li>
</ul>
<h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><ul>
<li>数组名[下标]</li>
<li>允许下标是整型变量或表达式</li>
</ul>
<h3 id="元素赋值"><a href="#元素赋值" class="headerlink" title="元素赋值"></a>元素赋值</h3><ul>
<li>通过循环语句赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	b[i] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过mencpy赋值<ul>
<li>记得开头加#include<string.h></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span>(a));<span class="comment">//数组a复制给数组b</span></span><br></pre></td></tr></table></figure>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><ul>
<li>按行存放</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义：基类型   a[b][c];<span class="comment">//三维数组：基类型   a[b][c][d];n维数组依此类推</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]<span class="comment">//表示2行3列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;<span class="comment">//第二位长度不能省略</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;<span class="comment">//等价第一行代码</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;,&#123;<span class="number">6</span>&#125;&#125;<span class="comment">//大花括号内的小花括号代表某行，4代表列数，即一行最多存储4个数</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;<span class="comment">//等价第三行代码</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//写法错误，不能判断几行几列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="comment">//行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)<span class="comment">//列判断</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>不要数组下标越界</li>
<li>字符数组要留意”\0”</li>
</ul>
<h2 id="向函数传递数组"><a href="#向函数传递数组" class="headerlink" title="向函数传递数组"></a>向函数传递数组</h2><ul>
<li>数组作为函数参数：实参数组和形参数组占据同一存储单元</li>
<li><strong>传递地址</strong>:所以不用去返回数值</li>
</ul>
<h3 id="传递一维数组"><a href="#传递一维数组" class="headerlink" title="传递一维数组"></a>传递一维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadScore</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score[N],aver,n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input n:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	ReadScore(score,n);</span><br><span class="line">	aver = Average(score,n);<span class="comment">//用不带下标的数组名作为函数实参，不需要方括号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Average score is %d\n&quot;</span>,aver);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadScore</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//输入n位学生成绩</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input score:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;score[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//计算平均分</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += score[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用<strong>不带下标的数组名作为函数实参</strong></li>
</ul>
<h3 id="传递二维数组"><a href="#传递二维数组" class="headerlink" title="传递二维数组"></a>传递二维数组</h3><ul>
<li>声明<strong>二维数组形参</strong>时，不能省略数组<strong>第二维长度</strong></li>
<li>元素地址：首地址+偏移量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AverforStud</span><span class="params">(<span class="type">int</span> score[][COURSE_N],<span class="type">int</span> sum[],<span class="type">float</span> aver[],<span class="type">int</span> n)</span><span class="comment">//计算每门课程平均分</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;COURSE_N;j++)<span class="comment">//遍历每门课程</span></span><br><span class="line">	&#123;</span><br><span class="line">		sum[j]=<span class="number">0</span>;<span class="comment">//第j门课程总分</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//遍历每个学生</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum[j]=sum[j]+score[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		aver[j]=(<span class="type">float</span>)sum[j]/COURSE_N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AverforStud</span><span class="params">(<span class="type">int</span> score[][COURSE_N],<span class="type">int</span> sum[],<span class="type">float</span> aver[],<span class="type">int</span> n)</span><span class="comment">//计算每个学生的平均分</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//遍历每个学生</span></span><br><span class="line">	&#123;</span><br><span class="line">		sum[i]=<span class="number">0</span>;<span class="comment">//第i个学生总分</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;COURSE_N;j++)<span class="comment">//遍历每门课程</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum[i]=sum[i]+score[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		aver[i]=(<span class="type">float</span>)sum[i]/COURSE_N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul>
<li>冒泡排序：比较相邻两个数据，顺序不对，则将其位置交换 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//排序算法（升序）</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j,temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(score[j]&lt;score[j<span class="number">-1</span>])<span class="comment">//交换相邻元素</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp = score[j];</span><br><span class="line">				score[j] = score[j<span class="number">-1</span>];</span><br><span class="line">				score[j<span class="number">-1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>交换排序：将第1个数与后面数进行比较，然后交换位置，然后第二个数开始比较</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ChangSort</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//交换法升序</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j,temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="comment">//</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>+i;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(score[j]&lt;score[i])<span class="comment">//两个元素比较</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp = score[j];</span><br><span class="line">				score[j] = score[j<span class="number">-1</span>];</span><br><span class="line">				score[j<span class="number">-1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>选择法排序：在每一遍比较中，在剩余的待比较的数中选择一个最小的数与这个剩余序列的第一个数交换位置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//交换法升序</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j,temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="comment">//第i个位置的元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		k=i;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>+i;j&lt;n;j++)<span class="comment">//寻找最低分所在下标k的过程</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(score[j]&lt;score[k])</span><br><span class="line">			&#123;</span><br><span class="line">				k = j;<span class="comment">//记录最小数的下标位置</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(k != i)<span class="comment">//最小数不在下标位置</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp = score[j];</span><br><span class="line">				score[j] = score[j<span class="number">-1</span>];</span><br><span class="line">				score[j<span class="number">-1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul>
<li>内存编址：每个字节都有唯一的编号 （地址）</li>
<li>地址为无符号整数，16进制</li>
<li>指针不是地址，指针变量的值是一个地址</li>
<li>可以保存变量、数组、字符串的首地址，保存函数的入口</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>基类型   *变量；</li>
<li>基类型：指针变量指向的数据类型</li>
<li>%p:输出变量地址</li>
<li>指针变量使用前必须初始化<ul>
<li>不知道指向那里，就指向NULL</li>
</ul>
</li>
<li>初始化:<ul>
<li>基类型   *变量1=&amp;变量2</li>
<li>基类型   *变量1；变量1=&amp;变量2</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int *pa;//定义指针</span></span><br><span class="line">    <span class="type">int</span> *pa=&amp;a;<span class="comment">//指针初始化；</span></span><br><span class="line">    <span class="comment">//int *pa=NULL;//指针初始化</span></span><br><span class="line">    <span class="comment">//pa=NULL;//指针初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%p\n&quot;</span>,pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><ul>
<li>值为NULL的指针</li>
</ul>
<h3 id="指针解引用"><a href="#指针解引用" class="headerlink" title="指针解引用"></a>指针解引用</h3><ul>
<li>通过间接寻址运算符访问指针指针指向变量的值</li>
<li>基类型   *变量=&amp;变量1；<ul>
<li>*变量=变量2；</li>
<li>说明：*变量为变量1的别名，可以赋值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *pa=&amp;a;<span class="comment">//指针初始化；</span></span><br><span class="line">    *pa=<span class="number">1</span>;<span class="comment">//给a赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*pa);<span class="comment">//等价上一条语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041243431.png" alt="image-20210904092305525"></p>
<ul>
<li>可以通过实参变量的地址，进而改变指针形参的值</li>
<li>这样函数可以返回多个值。</li>
<li>提供了修改实参值得方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> *par)</span>;<span class="comment">//函数指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span> ,a);</span><br><span class="line">    Fun(&amp;a);<span class="comment">//传递地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> *par)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,*par);</span><br><span class="line">    *par=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li><h4 id="两数交换"><a href="#两数交换" class="headerlink" title="两数交换"></a>两数交换</h4><ul>
<li>可以直接将值传给实参</li>
<li>不能借助一个未初始化得指针变量进行两数交换</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">9</span>;</span><br><span class="line">    Swap(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span><span class="comment">//两数交换</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp=*x;</span><br><span class="line">    *x=*y;</span><br><span class="line">    *y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li>格式：数据类型 （*指针变量名）（形参列表）；</li>
<li>作用<ul>
<li>编写 通用性更强的函数</li>
<li>实例1：通用计算任意函数定积分得函数</li>
<li>实例2：通用的排序函数</li>
<li>方便直接在主函数调用其他函数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//声明了函数名为f，返回值是整型指针类型得函数；在main里面</span></span><br><span class="line">f=Max;<span class="comment">//Max是定义得函数名</span></span><br><span class="line">result=(*f)(a,b);<span class="comment">//调用赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,result;</span><br><span class="line">    <span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    Fun(a,b,Max);</span><br><span class="line">    Fun(a,b,Min);</span><br><span class="line">    Fun(a,b,Add);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>))</span><span class="comment">//直接输出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result=(*f)(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,result );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//判断最大数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//判断最小数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//计算总和</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指针符号情况"><a href="#指针符号情况" class="headerlink" title="指针符号情况"></a>指针符号情况</h2><ul>
<li>在不同类型赋值地址时，有的需要加&amp;，有的不需要加&amp;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*p为定义的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要加&amp;,给的首地址</span></span><br><span class="line">p=num<span class="comment">//str为数组</span></span><br><span class="line">p=str<span class="comment">//str为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要加&amp;</span></span><br><span class="line">p=&amp;a<span class="comment">//一般为整型，浮点型等</span></span><br><span class="line">p=&amp;str[<span class="number">2</span>]<span class="comment">//字符串,指定某个字符时</span></span><br><span class="line">p=&amp;struc<span class="comment">//struc为结构体</span></span><br><span class="line">p=&amp;num[<span class="number">2</span>]<span class="comment">//数组,指定某个元素</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h2><h3 id="用scanf-输入"><a href="#用scanf-输入" class="headerlink" title="用scanf()输入"></a>用scanf()输入</h3><ul>
<li>不能输入带空格的字符串</li>
<li>%s:输入字符</li>
<li>不读走回车，留在缓冲区中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[STR_LEN+<span class="number">1</span>];<span class="comment">//定义字符串数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符：\n&quot;</span> );</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用gets输入"><a href="#用gets输入" class="headerlink" title="用gets输入"></a>用gets输入</h3><ul>
<li>以回车换行作为终止符，可以带入空格字符串，应为空和制表符都是字符串的一部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[STR_LEN+<span class="number">1</span>];<span class="comment">//定义字符串数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符：\n&quot;</span> );</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表示与存储"><a href="#表示与存储" class="headerlink" title="表示与存储"></a>表示与存储</h2><h3 id="字符数组的定义"><a href="#字符数组的定义" class="headerlink" title="字符数组的定义"></a>字符数组的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="type">char</span> str[STR_LEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//字符常量的初始化列表对数组初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用字符串常量直接对数组初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=&#123;<span class="string">&quot;China&quot;</span>&#125;;<span class="comment">//用字符串常量直接对数组初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=<span class="string">&quot;China&quot;</span>;<span class="comment">//一般选择</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;China&quot;</span>;<span class="comment">//后面的元素会自动处理成ACSII码值为0</span></span><br></pre></td></tr></table></figure>
<h3 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h3><ul>
<li>字符指针就是字符串首地址的指针</li>
<li>pstr的值可被修改，他所指向的字符串也可被修改</li>
<li>原则<ol>
<li>明确字符串被保存哪里</li>
<li>字符指针指向哪里</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//char *pstr[6]=&quot;China&quot;;</span></span><br><span class="line">    <span class="comment">//将字符指针指向一个字符数组</span></span><br><span class="line">    <span class="type">char</span> str[]=<span class="string">&quot;China&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *pstr;</span><br><span class="line">    pstr = str;<span class="comment">//地址保存，字符指针指向数组; 等价pstr = &amp;str[0];</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    *pstr=<span class="string">&#x27;w&#x27;</span>;<span class="comment">//地址指向的是首地址，等价str[0]=&#x27;w&#x27;或pstr[0]=&#x27;w&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    str[<span class="number">3</span>]=<span class="string">&#x27;D&#x27;</span>;<span class="comment">//修改字符数组的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><ul>
<li>开头要加<strong>#include<string.h></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(字符串);<span class="comment">//计算字符串长度,实际长度</span></span><br><span class="line"><span class="built_in">strcpy</span>(目的字符数组，源字符串);<span class="comment">//将源字符串复制到目的字符数组;目的字符数组要比元字符串大</span></span><br><span class="line"><span class="built_in">strncpy</span>(目的字符数组，源字符串,n);<span class="comment">//将源字符串的前n个字符复制到目的字符数组;更安全</span></span><br><span class="line"><span class="built_in">strcat</span>(目的字符数组，源字符串);<span class="comment">//将源字符串添加到目的字符数组</span></span><br><span class="line"><span class="built_in">strcmp</span>(字符串<span class="number">1</span>，字符串<span class="number">2</span>);</span><br><span class="line"><span class="comment">//字符串的比较是比较字符串中各对字符的ASCII码</span></span><br><span class="line"><span class="comment">//自左向右逐个按照ASCII码值进行比较，直到出现不同的字符或遇’\0’为止。</span></span><br><span class="line"><span class="comment">//第一个字符串大于第二个字符串，则返回大于0的数字</span></span><br><span class="line"><span class="comment">//第一个字符串等于第二个字符串，则返回0</span></span><br><span class="line"><span class="comment">//第一个字符串小于第二个字符串，则返回小于0的数字</span></span><br><span class="line"><span class="built_in">strncmp</span>(字符串<span class="number">1</span>，字符串<span class="number">2</span>,n);</span><br></pre></td></tr></table></figure>
<p>案例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#define N 100</span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    char <span class="built_in">str</span>[<span class="number">10</span>]=<span class="string">&quot;China&quot;</span>;</span><br><span class="line">    char str1[N];</span><br><span class="line">    char str2[N];</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>,strlen(<span class="built_in">str</span>));//输出字符串长度</span><br><span class="line">    strcpy(str1,<span class="built_in">str</span>);</span><br><span class="line">    printf(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    strcat(str1,strcpy(<span class="built_in">str</span>,<span class="string">&quot;  hello&quot;</span>));</span><br><span class="line">    printf(<span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line">    strcmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向函数传递字符串"><a href="#向函数传递字符串" class="headerlink" title="向函数传递字符串"></a>向函数传递字符串</h3><ul>
<li>用字符数组作为函数参数</li>
<li>也可用字符指针做函数参数</li>
<li>传字符串的首地址，不是全部地址</li>
</ul>
<p><strong>计算实际字符个数</strong></p>
<ul>
<li>const作用：保护指针变量指向的内容不被改变</li>
<li>若只向函数传数据，则把形参定义为const，防止他被意外修改</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">MyStrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pstr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch[N];</span><br><span class="line">    gets(ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,MyStrlen(ch));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">MyStrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pstr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;*pstr!=<span class="string">&#x27;\0&#x27;</span>;pstr++)<span class="comment">//pstr++:地址加1</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数返回字符串方法</strong></p>
<ul>
<li>数组和指针作为函数形参</li>
<li>从函数返回指向字符串的指针</li>
<li>数组不能作为函数的返回值</li>
</ul>
<p>缓冲区溢出和溢出攻击</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">Ex</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,Ex(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">Ex</span><span class="params">(<span class="type">char</span> *str)</span><span class="comment">//返回字符串需要用到指针函数（函数名前加*）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s3[N];<span class="comment">//static将s3变为全局变量，不加则不能返回函数内定义的字符串</span></span><br><span class="line">    <span class="type">int</span> i,k;</span><br><span class="line">    k=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s3[k<span class="number">-1</span>-i]=str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><ul>
<li>可以用指针代替数组下标操作</li>
</ul>
<h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><ul>
<li>加上整数，减去整数，两个指针相减</li>
<li>参与运算：加，减整数，自增，自减，关系，赋值</li>
</ul>
<p>指针指向数组元素才有意义</p>
<ul>
<li>p+j不是加j个字节，而是取决于p的基类型</li>
<li>指向同一数组时，还可以比较</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">int</span> *p,*q;</span><br><span class="line">    p=&amp;a[i];</span><br><span class="line">    q=p+j;</span><br><span class="line">    q=p-j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h2><p>首地址&amp;a[0]</p>
<ul>
<li>&amp;a[i]等价于（a+i）</li>
<li>a+1指的是：a+i*sizeof(基类型)</li>
<li>数组地址的相差取决于基类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>],*p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=a;p&lt;a+<span class="number">5</span>;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p=a;p&lt;a+<span class="number">5</span>;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d\n&quot;</span>,*p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="自加区别"><a href="#自加区别" class="headerlink" title="自加区别"></a>自加区别</h3><ul>
<li><p>*p++是指下一个地址。</p>
</li>
<li><p>(*p)++是指将星p所指的数据的值加一。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*p++与（*p）++区别</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,*p=a,*q=a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p );</span><br><span class="line">    x=*p++;<span class="comment">//执行这一句后x=a[0]=1，p=a+1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    y=(*q)++;<span class="comment">//执行这一句后，y=a[0]+1=2，q仍然=a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><h3 id="指向二维数组的行指针"><a href="#指向二维数组的行指针" class="headerlink" title="指向二维数组的行指针"></a>指向二维数组的行指针</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>int (*p)[3];//行指针，基类型int[3]类型 </li>
<li>int *q[3];//指针数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//a[i][j]的元素值等价于*(*(p+i)+j)</span></span><br><span class="line"><span class="comment">//*(p+i),即a[i]，指向第i行第0列的int型元素</span></span><br><span class="line"><span class="comment">//*(p+i)+j指向第i行第j列的int型元素</span></span><br><span class="line"><span class="comment">//*(*(p+i)+j)取出第i行第j列的内容，即a[i][j]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041243909.png" alt="image-20210912172323876"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li>按行查找，再按列查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>];<span class="comment">//行指针，基类型int[3]类型 </span></span><br><span class="line">    p=a;<span class="comment">//&amp;a[0]指向第0行的int[3]型元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="comment">//行下标变化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)<span class="comment">//列下标变化</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*(p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="指向二维数组的列指针"><a href="#指向二维数组的列指针" class="headerlink" title="指向二维数组的列指针"></a>指向二维数组的列指针</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li>int *p;//列指针，基类型是int 型</li>
<li>将二维看成一维数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//*(a+0)+0)即&amp;a[0][0],指向a[0][0]的int元素</span></span><br><span class="line">*(p+i*<span class="number">3</span>+j)<span class="comment">//代表着第一个元素，i代表前i行,j代表着本行第j个元素</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041243194.png" alt="image-20210912172246480"></p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//*(a+0)+0)即&amp;a[0][0],指向a[0][0]的int元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p+i*<span class="number">3</span>+j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二维数组输入"><a href="#二维数组输入" class="headerlink" title="二维数组输入"></a>二维数组输入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> q[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;q[i]);<span class="comment">//对于一维相当字符串，二维输入字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,q[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><h2 id="二维字符数组"><a href="#二维字符数组" class="headerlink" title="二维字符数组"></a>二维字符数组</h2><ul>
<li>第二维下标不能省略</li>
<li>相对字符指针数组空间浪费</li>
<li>定义：char country[][10]={“A”,”E”,”A”,”C”,”j”};</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> country[][<span class="number">10</span>]=&#123;<span class="string">&quot;America&quot;</span>,<span class="string">&quot;England&quot;</span>,<span class="string">&quot;Australia&quot;</span>,<span class="string">&quot;China&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;<span class="comment">//定义二维字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,country[i]);<span class="comment">//访问数组，输出每行的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符指针数组"><a href="#字符指针数组" class="headerlink" title="字符指针数组"></a>字符指针数组</h2><ul>
<li>每个数组元素都是一个指向字符串的指针</li>
<li>定义：char *country[]={“A”,”E”,”A”,”C”,”j”};</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *country[]=&#123;<span class="string">&quot;America&quot;</span>,<span class="string">&quot;England&quot;</span>,<span class="string">&quot;Australia&quot;</span>,<span class="string">&quot;China&quot;</span>,<span class="string">&quot;jsf&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,country[i]);<span class="comment">//输出每行的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>用数组指针的基类型——-指向数组的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>用指针作数组的基类型———指针数组<ul>
<li>元素维指针类型的数组</li>
<li>定义：数据类型   *数组名[数组长度]</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>8.结构体——C语言</title>
    <url>/blot.github.io/2022/03/03/8%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="8、结构体"><a href="#8、结构体" class="headerlink" title="8、结构体"></a>8、结构体</h1><h1 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h1><ul>
<li>数组只能将相同类型的数据放在一起，结构体是可以将不同类型的数据放在一起</li>
</ul>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体模板</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生年</span></span><br><span class="line">        <span class="type">int</span> scoreMath;<span class="comment">//数学成绩</span></span><br><span class="line">        <span class="type">int</span> scoreEnglish;<span class="comment">//英语成绩</span></span><br><span class="line">        <span class="type">int</span> scoreComputer;<span class="comment">//计算机</span></span><br><span class="line">        <span class="type">int</span> scoreP;</span><br><span class="line">  	    <span class="comment">//int score[4];//等价上面成绩</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="定义结构体变量"><a href="#定义结构体变量" class="headerlink" title="定义结构体变量"></a>定义结构体变量</h2><p>1、先定义结构体类型，在定义变量名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span>//<span class="title">student</span>为标签名</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span><span class="comment">//定义变量</span></span><br></pre></td></tr></table></figure>
<p>2、在定义结构体类型的同时定义变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生</span></span><br><span class="line">    &#125;stu1;</span><br></pre></td></tr></table></figure>
<p>3、直接定义结构体变量（不指定结构体标签）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生年</span></span><br><span class="line">    &#125;stu1;</span><br></pre></td></tr></table></figure>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><ul>
<li>用typedef给数据类型定义一个别名</li>
<li>别名用全部大写</li>
<li>struct student等价STUDENT</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;stu1;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">STUDENT</span>;</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;STUDENT;<span class="comment">//结构体声明</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化列表成员必须与结构体类型定义的顺序一致</li>
<li>没给初始值就默认为0</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生年分</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">    STUDENT stu1=&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>，<span class="string">&quot;Man&quot;</span>,<span class="number">1991</span>,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<h1 id="结构体与数组嵌套"><a href="#结构体与数组嵌套" class="headerlink" title="结构体与数组嵌套"></a>结构体与数组嵌套</h1><h2 id="嵌套的结构体"><a href="#嵌套的结构体" class="headerlink" title="嵌套的结构体"></a>嵌套的结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">    &#125;DATE;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex[<span class="number">10</span>];<span class="comment">//性别</span></span><br><span class="line">        DATE yearBirth;<span class="comment">//出生年</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<ul>
<li>嵌套的结构体要用花括号表示内容—里面花括号</li>
<li>外面花括号—-原结构体数组类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STUDENT stu1=&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><ul>
<li>前面结构体声明一样</li>
<li>数据就用花括号嵌套表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STUDENT stu1[<span class="number">3</span>]=&#123;&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;,</span><br><span class="line">                    &#123;<span class="number">13503</span>,<span class="string">&quot;小红&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;,</span><br><span class="line">                    &#123;<span class="number">1253</span>,<span class="string">&quot;小西南&quot;</span>,<span class="string">&quot;WOMan&quot;</span>,&#123;<span class="number">1983</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;</span><br><span class="line">                &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="计算结构体内存数"><a href="#计算结构体内存数" class="headerlink" title="计算结构体内存数"></a>计算结构体内存数</h2><ul>
<li>sizeof(变量或表达式)</li>
<li>为满足内存地址要求，在较小的成员加入补位</li>
</ul>
<h1 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h1><ul>
<li>通过名字访问结构体成员</li>
<li><strong>成员选择运算符</strong>（原点运算符）</li>
<li><strong>结构体变量名.成员名</strong></li>
<li>对于嵌套体成员，必须以级联方式访问</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">    &#125;DATE;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        DATE Birth;</span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">    STUDENT stu1=&#123;<span class="number">12033</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&#x27;M&#x27;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//访问操作</span></span><br><span class="line">    stu1.studentID=<span class="number">101001</span>;<span class="comment">//访问id</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stu1.studentName,<span class="string">&quot;小&quot;</span>);<span class="comment">//访问，字符数组要用strcpy函数</span></span><br><span class="line">    stu1.studentSex=<span class="string">&#x27;M&#x27;</span>;<span class="comment">//若是定义单个字符，直接赋值</span></span><br><span class="line">    stu1.Birth.year=<span class="number">19</span>;<span class="comment">//级联方式访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名为%s\n性别是%c\n学号是%d\n&quot;</span>,stu1.studentName,stu1.studentSex,stu1.studentID);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><ul>
<li>只能在相同类型的结构体变量之间进行赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">    &#125;DATE;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex[<span class="number">10</span>];<span class="comment">//性别</span></span><br><span class="line">        DATE yearBirth;<span class="comment">//出生年</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">    STUDENT stu1=&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;</span><br><span class="line">    STUDENT stu2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    stu2.studentID=stu1.studentID;<span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        stu2.score[i]=stu1.score[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu2.score[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取地址操作"><a href="#取地址操作" class="headerlink" title="取地址操作"></a>取地址操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STUDENT stu2;</span><br><span class="line">stu1=stu2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;stu1=%p\n&quot;</span>,&amp;stu1 );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;stu2=%p&quot;</span>,&amp;stu2);</span><br></pre></td></tr></table></figure>
<h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ul>
<li>通过成员选择运算符访问</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*pt).studentID=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过指向运算符访问：<strong>-&gt;</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pt -&gt; studentID=1;</span><br></pre></td></tr></table></figure>
<p>总体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex[<span class="number">10</span>];<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">    <span class="comment">//定义结构体指针</span></span><br><span class="line">    STUDENT stu1;</span><br><span class="line">    STUDENT *pt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pt = &amp;stu1;<span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//STUDENT *pt = &amp;stu1;//与上式等价</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    (*pt).studentID=<span class="number">1</span>;</span><br><span class="line">    pt -&gt; studentID=<span class="number">1</span>;</span><br><span class="line">    stu1.studentID=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体数组-1"><a href="#结构体数组-1" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STUDENT stu[<span class="number">30</span>];</span><br><span class="line">STUDENT *pt;</span><br><span class="line">pt=stu;<span class="comment">//数组首地址指向指针</span></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">STUDENT *pt=stu;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">STUDENT *pt = &amp;stu[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">pt -&gt; studentID;<span class="comment">//等价于stu[0].studentID</span></span><br></pre></td></tr></table></figure>
<h1 id="向函数传递结构体"><a href="#向函数传递结构体" class="headerlink" title="向函数传递结构体"></a>向函数传递结构体</h1><p><strong>传递单个成员</strong></p>
<p><strong>向函数传递结构体的完整结构</strong></p>
<ul>
<li>赋值结构体的所有成员 </li>
</ul>
<p><strong>向函数传递结构体的首地址</strong></p>
<ul>
<li>仅复制一个地址值</li>
</ul>
<p>应用</p>
<ul>
<li>封装函数参数：精简参数个数、函数接口简洁</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>//结构体声明</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">    &#125;POINT;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT *p)</span>;<span class="comment">//函数结构体指针定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    POINT position=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,position.x,position.y,position.z);</span><br><span class="line">    Func(&amp;position);<span class="comment">//传参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,position.x,position.y,position.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT *pt)</span></span><br><span class="line">&#123;</span><br><span class="line">    pt -&gt; x=<span class="number">1</span>;</span><br><span class="line">    pt -&gt; y=<span class="number">2</span>;</span><br><span class="line">    pt -&gt; z=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>向函数传递结构体完整结构</th>
<th>向函数传递结构体的首地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>用结构体变量做函数参数</td>
<td>用结构体数组/结构指针做函数参数</td>
</tr>
<tr>
<td>复制整个结构体成员内容，一组数据</td>
<td>仅复制结构体的首地址，一个数据</td>
</tr>
<tr>
<td>参数传递直观，开销大，效率低</td>
<td>参数传递效率高</td>
</tr>
<tr>
<td>函数内对结构体内容的修改不影响原来结构体</td>
<td>可修改结构体指针所指向的结构体内容</td>
</tr>
</tbody>
</table>
</div>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><ul>
<li>应用：当某些量仅由有限个整型数据值组成时</li>
<li>枚举常量是整型常量</li>
<li>增强程序看可读性：定义标志变量</li>
<li>MON后面常量依次加1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weeks</span> =</span>&#123;SUN=<span class="number">7</span>,MON=<span class="number">1</span>,TUE,WED,THU,FRI,SAT&#125;<span class="comment">//枚举类型声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> weeks =&#123;SUN=<span class="number">7</span>,MON=<span class="number">1</span>,TUE,WED,THU,FRI,SAT&#125; WEEKS;<span class="comment">//定义别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weeks</span> <span class="title">today</span>;</span></span><br><span class="line">WEEKS today;</span><br></pre></td></tr></table></figure>
<h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><h2 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h2><ul>
<li>字节数取决于占空间最多的成员变量<ul>
<li>同一内存在每一瞬间只能保存一个成员；起作用的成员是最后一次赋值的成员</li>
</ul>
</li>
<li>与结构体类似</li>
<li>成员最好互斥</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">short</span> i;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sample</span> <span class="title">s</span>;</span><span class="comment">//定义变量</span></span><br><span class="line">    s.i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sample</span> <span class="title">u</span>=</span>&#123;<span class="number">1</span>&#125;;<span class="comment">//只能对共用体第一个成员进行初始化</span></span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>构造混合的数据类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">    &#125;NUMBER;</span><br><span class="line"></span><br><span class="line">    NUMBER <span class="built_in">array</span>[<span class="number">100</span>];<span class="comment">//既可以存储int型，也可以存储float型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>].i=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>].f=<span class="number">3.2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>结构体</th>
<th>共用体</th>
</tr>
</thead>
<tbody>
<tr>
<td>关系紧密且逻辑相关的多种不同类型的数据的结集合</td>
<td>情形互斥但逻辑相关的多种不同类型的数据的集合</td>
</tr>
<tr>
<td>可以保存所有成员的值，用sizeof来计算占用内存的总字节数</td>
<td>内存重叠存储，每一瞬间只能保存一个成员，最后一次赋值的成员起作用</td>
</tr>
<tr>
<td>对所有成员初始化</td>
<td>只能对第一个成员初始化</td>
</tr>
</tbody>
</table>
</div>
<h1 id="C程序的内存映像"><a href="#C程序的内存映像" class="headerlink" title="C程序的内存映像"></a>C程序的内存映像</h1><p>变量的内存分配方式</p>
<ul>
<li>从静态存储区分配<ul>
<li>全局变量和静态变量</li>
</ul>
</li>
<li>从栈上分配</li>
<li>从堆上分配</li>
</ul>
<h2 id="动态内存分配函数"><a href="#动态内存分配函数" class="headerlink" title="动态内存分配函数"></a>动态内存分配函数</h2><ul>
<li>void*型指针不指定其指向哪一种类型，可指向任意类型的变量</li>
<li>使用时，需强转（Type*）为其他类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//向系统申请大小为size的内存块；</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//向系统申请num个size大小的内存块</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *p,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//改变原来分配存储空间的大小</span></span><br><span class="line"><span class="comment">//指针p所指向存储空间的大小改为size个字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;<span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line">p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//强制转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>3.c++常用库及操作</title>
    <url>/blot.github.io/2022/05/05/C++%E5%B8%B8%E7%94%A8%E5%BA%93%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="C-常用库及操作"><a href="#C-常用库及操作" class="headerlink" title="C++常用库及操作"></a>C++常用库及操作</h1><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort<a href="https://ac-fun.blog.csdn.net/article/details/105936466?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2">排序</a></h2><ul>
<li>需要声明<strong>#include <algorithm></strong>；sort(begin,end)，表示一个范围</li>
<li>sort()函数可以对给定区间所有元素进行排序。它有三个参数sort(begin, end, cmp)，其中<strong>begin</strong>为指向待sort()的<strong>数组的第一个元素的指针</strong>，e<strong>nd为指向待sort()的数组的最后一个元素的下一个位置的指针</strong>，cmp参数为排序准则，<strong>cmp参数可以不写</strong>，如果不写的话，<strong>默认从小到大进行排序</strong>。如果我们想从大到小排序可以将cmp参数写为greater<int>()就是对int数组进行排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">数组：<span class="built_in">sort</span>(num,num+<span class="number">10</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())</span><br><span class="line">字符串：<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">char</span>&gt;()</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;//万能头文件</span></span><br><span class="line"><span class="comment">//sort(首地址,首地址+长度)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(num,num+<span class="number">10</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//greater&lt;int&gt;()从大到小</span></span><br><span class="line">    <span class="comment">//sort(num,num+10)//从小到大</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;<span class="comment">//输出结果:9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	string a;</span><br><span class="line">	cin&gt;&gt;a;</span><br><span class="line">	<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;从小到大：&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">char</span>&gt;());</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;从大到小：&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义字符串数组</span></span><br><span class="line">    string a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="comment">// cout&lt;&lt;a;不能直接输出</span></span><br><span class="line">    cout&lt;&lt;a[<span class="number">4</span>];<span class="comment">//输出第5个字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">empty</span>(); <span class="comment">// 判断是否为空字符串</span></span><br><span class="line">s1.<span class="built_in">size</span>(); <span class="comment">// 效果如s1.length(), O(1)</span></span><br><span class="line">s1.pop_back; <span class="comment">// 删掉最后一个字符</span></span><br><span class="line">ch=<span class="built_in">to_string</span>(a)<span class="comment">//将整数变为字符，a为整数</span></span><br></pre></td></tr></table></figure>
<h3 id="to-string"><a href="#to-string" class="headerlink" title="to_string()"></a>to_string()</h3><ul>
<li>将整数变为字符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cun[<span class="number">5</span>]=&#123;<span class="number">133</span>,<span class="number">7236</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	string res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i:cun)&#123;</span><br><span class="line">		res=<span class="built_in">to_string</span>(i);</span><br><span class="line">        <span class="comment">//res+=to_string(i);将遍历到的字符加到res后面</span></span><br><span class="line">		cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串相加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    a=<span class="string">&#x27;8&#x27;</span>+a+<span class="string">&#x27;9&#x27;</span>;<span class="comment">//在字符串首尾直接添加字符</span></span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h3><ul>
<li>substring (begin,end)方法用于提取字符串中介于两个指定下标之间的字符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string a=<span class="string">&quot;012345678&quot;</span></span><br><span class="line"><span class="comment">//第一个参数为位置，第二个参数为截取的长度</span></span><br><span class="line">a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>)<span class="comment">//截取字符串第0到第5的位置，012345</span></span><br><span class="line">str=str.<span class="built_in">substr</span>(<span class="number">2</span>);<span class="comment">//表示从原串下标为2的字符开始截取到完。</span></span><br></pre></td></tr></table></figure>
<p><strong>substring(begin,end)</strong></p>
<ul>
<li>substring (begin,end)方法用于提取字符串中介于两个指定下标之间的字符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin:开始索引（包括），索引从0开始</span><br><span class="line">end:结束索引（不包括）</span><br></pre></td></tr></table></figure>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>vector是STL中最常见的容器，它是一种顺序容器，支持随机访问； 而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">//必须包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//几种vector声明</span></span><br><span class="line">    <span class="comment">//&lt;&gt;里面是类型</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v1;        <span class="comment">//定义空的vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(<span class="number">10</span>);    <span class="comment">//产生大小为10的vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">-1</span>);    <span class="comment">//产生大小为10，并且每个元素都是-1的vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v4</span>(v3);        <span class="comment">//用一个vector产生一个vecotr</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v5</span>(arr,&amp;arr[<span class="number">5</span>]);    <span class="comment">//以区间[beg;end)做为初值的vector</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前元素数量&quot;</span>&lt;&lt;v5.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1大小是否为0:&quot;</span>&lt;&lt; (v1.<span class="built_in">empty</span>()?<span class="string">&quot;空&quot;</span>:<span class="string">&quot;不空&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2大小是否为0:&quot;</span>&lt;&lt; (v2.<span class="built_in">empty</span>()?<span class="string">&quot;空&quot;</span>:<span class="string">&quot;不空&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1可容纳的元素最大数量:&quot;</span>&lt;&lt;v1.<span class="built_in">max_size</span>()&lt;&lt;endl;    <span class="comment">//电脑内存4GB</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2可容纳的元素最大数量:&quot;</span>&lt;&lt;v2.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2重新分配前所能容纳的元素最大数:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">20</span>); <span class="comment">//给v2重新分配20个空间</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2.reserve(20)后重新分配前所能容纳的元素最大数:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v3 v4是否相等:&quot;</span>&lt;&lt;(v3==v4 ? <span class="string">&quot;相等&quot;</span>:<span class="string">&quot;不等&quot;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">11</span>);<span class="comment">//在尾部添加一个元素1</span></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">22</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器是随机存取迭代器，对vector来说就是指针，迭代器持续有效</span></span><br><span class="line">    <span class="comment">//除非在一个较小索引位置插入删除元素或者内存重新分配</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator ita; <span class="comment">//声明一个迭代器</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(), i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)<span class="comment">//v1.begin()指向v1的第一个元素，v1.end()指向最后元素的下一位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    v1.<span class="built_in">pop_back</span>();<span class="comment">//在尾部删除一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟v1.begin()和v1.end()对应的有v1.rbegin()和v1.rend(),</span></span><br><span class="line">    <span class="comment">//v1.begin()指向逆向的第一个元素，v1.end()指向逆向最后元素的下一位置，使用    vector&lt;int&gt;::reverse_iterator ita;</span></span><br><span class="line"></span><br><span class="line">    v2=v1; <span class="comment">//将v1的元素全部拷到v2</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v2.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v2.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v2中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v2[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//v2.clear();</span></span><br><span class="line">    v2.<span class="built_in">assign</span>(<span class="number">3</span>,<span class="number">44</span>);    </span><br><span class="line">    <span class="keyword">for</span>(ita=v2.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v2.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v2中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v2[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    v2.<span class="built_in">assign</span>(arr,&amp;arr[<span class="number">5</span>]);    </span><br><span class="line">    <span class="keyword">for</span>(ita=v2.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v2.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v2中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v2[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="comment">//swap(v1,v2);</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1第2个元素&quot;</span>&lt;&lt;v1.<span class="built_in">at</span>(<span class="number">1</span>)&lt;&lt;endl;    <span class="comment">//越界抛出异常</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;v1第6个元素&quot;&lt;&lt;v1[5]&lt;&lt;endl;  //越界，不检查</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1首个元素&quot;</span>&lt;&lt;v1.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1最后元素&quot;</span>&lt;&lt;v1.<span class="built_in">back</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos=v1.<span class="built_in">begin</span>();</span><br><span class="line">    v1.<span class="built_in">insert</span>(pos,<span class="number">11</span>);</span><br><span class="line">    <span class="comment">//v1.insert(pos,4,55); //如果直接用就是错的，因为迭代器失效了</span></span><br><span class="line">    <span class="comment">//v1.insert(pos,arr,&amp;arr[5]);</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    pos=v1.<span class="built_in">begin</span>(); <span class="comment">//因为直接用迭代器失效，所以重新声明下</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(++pos); <span class="comment">//删除制定位置</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    pos=v1.<span class="built_in">begin</span>(); </span><br><span class="line">    v1.<span class="built_in">erase</span>(pos,pos+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//v1.resize(5); //将元素数量改成5，如果v1变大，则多的按默认走</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">5</span>,<span class="number">9</span>); <span class="comment">//将元素数量改成5，如果v1变大，则多的赋值成9</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">clear</span>(); <span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//几种vector声明</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;        <span class="comment">//定义空的vector,int类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(<span class="number">10</span>);    <span class="comment">//产生大小为10的vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">-1</span>);    <span class="comment">//产生大小为10，并且每个元素都是-1的vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v4</span>(v3);        <span class="comment">//用一个vector产生一个vecotr</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator new_end;<span class="comment">//相当定义了一个变量，上面为数组类型</span></span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">11</span>);<span class="comment">//在尾部添加一个元素1</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>();<span class="comment">//在尾部删除一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置函数命名</span></span><br><span class="line"><span class="comment">//vector&lt;基类型&gt; 变量名;</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fun1</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a><a href="https://blog.csdn.net/qq_40913465/article/details/109604616?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164672644716780265423095%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164672644716780265423095&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-109604616.pc_search_result_cache&amp;utm_term=C%2B%2Bauto&amp;spm=1018.2226.3001.4187">auto</a></h2><ol>
<li>auto的原理就是根据后面的值，来自己推测前面的类型是什么。</li>
<li>auto的作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替</li>
</ol>
<p>注意</p>
<h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p>1.用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）</p>
<p>2.函数和模板参数不能被声明为auto（原因同上）</p>
<p>3.因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid</p>
<p>4.定义在一个auto序列的变量必须始终推导成同一类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="number">3.14</span>;  <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">9</span>);  <span class="comment">//int *</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3 = <span class="string">&#x27;r&#x27;</span>;   <span class="comment">//错误，必须是初始化为同一类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> au_a = a;<span class="comment">//自动类型推断，au_a为int类型</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(au_a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="循环中应用"><a href="#循环中应用" class="headerlink" title="循环中应用"></a>循环中应用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    string a;</span><br><span class="line">	cin&gt;&gt;a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> c:a)&#123;</span><br><span class="line">		cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello,world&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">// for(auto &amp;c:s);//s为字符串，对于s中的每个字符，c是一个引用，赋值语句将会改变s中字符的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可遍历数组和字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="reverse-翻转"><a href="#reverse-翻转" class="headerlink" title="reverse 翻转"></a>reverse 翻转</h2><ul>
<li><p>头文件：#include<algorithm></p>
</li>
<li><p>翻转一个vector：</p>
<p><code>reverse(a.begin(), a.end());</code></p>
</li>
<li><p>翻转一个数组，元素存放在下标1~n：</p>
<p><code>reverse(a + 1, a + 1 + n);</code></p>
</li>
</ul>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>最大值比较max(a,b)</p>
<p>最小值比较min(a,b)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	res=<span class="built_in">min</span>(a,b);</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	r=<span class="built_in">max</span>(a,b);</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl&lt;&lt;r;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><ul>
<li>(默认)查找字符串中子串最开始出现所在的位置下标，没找到就返回-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找最开始出现子串的下标</span></span><br><span class="line">string c=<span class="string">&quot;abcpb&quot;</span></span><br><span class="line"><span class="type">char</span> b=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="type">int</span> a=c.<span class="built_in">find</span>(b);<span class="comment">//下标为1，多个子串也是第一个字符出现的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找指定位置之后最开始出现的下标</span></span><br><span class="line">a=c.<span class="built_in">find</span>(b,<span class="number">4</span>)<span class="comment">//下标为4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他方式</span></span><br><span class="line">a=c.<span class="built_in">rfind</span>(b);</span><br><span class="line">a=c.<span class="built_in">find_first_of</span>(b);</span><br><span class="line">a=c.<span class="built_in">find_first_of</span>(b,<span class="number">3</span>);</span><br><span class="line">a=c.<span class="built_in">find_last_of</span>(b);</span><br><span class="line">a=c.<span class="built_in">find_first_not_of</span>(b);</span><br></pre></td></tr></table></figure>
<p><strong>rfind</strong>()</p>
<ul>
<li>反向查找字符串，即找到最后一个与子串匹配的位置</li>
</ul>
<p><strong>find_first_of()</strong></p>
<ul>
<li>查找子串中的某个字符最先出现的位置。find_first_of()不是全匹配，而find()是全匹配</li>
<li>find_first_of()也可以约定初始查找的位置：s1.find_first_of(s2, 2) ;</li>
</ul>
<p><strong>find_last_of()</strong></p>
<ul>
<li>这个函数与find_first_of()功能差不多，只不过find_first_of()是从字符串的前面往后面搜索，而find_last_of()是<strong>从字符串的后面往前面搜索</strong>。</li>
</ul>
<p><strong>find_first_not_of</strong>()</p>
<ul>
<li>找到第一个不与子串匹配的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string c=<span class="string">&quot;abcpb&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> a=c.<span class="built_in">find</span>(b,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="unique"><a href="#unique" class="headerlink" title="unique()"></a>unique()</h2><ul>
<li>unique函数的去重过程实际上就是<strong>不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置</strong>。</li>
<li>unique函数通常和erase函数一起使用，来达到删除重复元素的目的。(注：此处的删除是真正的删除，即从容器中去除重复的元素，<strong>容器的长度也发生了变换</strong>；</li>
<li>unique(a.begin(),a.end()):<strong>左闭右开</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"><span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h2><ul>
<li>将unique函数返回的值和容器末尾的区间用eraser函数抹除，就完成了去重</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a =&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator new_end;</span><br><span class="line"> </span><br><span class="line">    new_end = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//注意unique的返回值；unique后，数组顺序为：1,3,4,5,6,7,X(代表重复数字，具体哪个不重要）,X。他的返回值就是第一个重复数字的地址，所以，能用erase 实现彻底去重。</span></span><br><span class="line">    a.<span class="built_in">erase</span>(new_end,a.<span class="built_in">end</span>());<span class="comment">//然后将unique函数返回的值和容器末尾的区间用eraser函数抹除，就完成了去重</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;删除重复元素后的 a : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pair"><a href="#pair" class="headerlink" title="pair()"></a><a href="https://blog.csdn.net/sevenjoin/article/details/81937695?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164740820916780264057962%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164740820916780264057962&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81937695.142^v2^pc_search_result_control_group,143^v4^register&amp;utm_term=c%2B%2B%2Bpair&amp;spm=1018.2226.3001.4187">pair()</a></h1><ul>
<li>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</li>
</ul>
<p>创建和初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于vector容器</span></span><br><span class="line">vector&lt; pair &lt;string,<span class="type">int</span>&gt; &gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问第一个元素</span></span><br><span class="line">a.first</span><br><span class="line"><span class="comment">//访问第一个元素</span></span><br><span class="line">a.second</span><br></pre></td></tr></table></figure>
<ol>
<li>用sort()排序说明</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>())<span class="comment">//优先排序第一个元素，第一个元素相同再看第二个元素</span></span><br></pre></td></tr></table></figure>
<p>2.对数组直接添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; a;<span class="comment">//创建</span></span><br><span class="line"><span class="type">int</span> c=<span class="number">1</span>,d=<span class="number">2</span>;</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;c,d&#125;);<span class="comment">//对pair直接后面添加内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vector与pair联用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; ::iterator iter;<span class="comment">//用iter访问</span></span><br><span class="line"><span class="keyword">for</span>(iter=Q.<span class="built_in">begin</span>();iter!=Q.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">	a[iter-&gt;second]=iter-&gt;first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><ul>
<li><h4 id="所有元素都会根据元素的减值自动被排序。"><a href="#所有元素都会根据元素的减值自动被排序。" class="headerlink" title="所有元素都会根据元素的减值自动被排序。"></a>所有元素都会根据元素的减值自动被排序。</h4></li>
<li><h4 id="map的所有元素都是pair，同时拥有实值-value-和键值-key-。"><a href="#map的所有元素都是pair，同时拥有实值-value-和键值-key-。" class="headerlink" title="map的所有元素都是pair，同时拥有实值(value)和键值(key)。"></a>map的所有元素都是pair，同时拥有实值(value)和键值(key)。</h4></li>
<li><h4 id="pair的第一个元素会被视为键值，第二个元素会被视为实值。"><a href="#pair的第一个元素会被视为键值，第二个元素会被视为实值。" class="headerlink" title="pair的第一个元素会被视为键值，第二个元素会被视为实值。"></a>pair的第一个元素会被视为键值，第二个元素会被视为实值。</h4></li>
<li><h4 id="map不允许两个元素拥有相同的键值。"><a href="#map不允许两个元素拥有相同的键值。" class="headerlink" title="map不允许两个元素拥有相同的键值。"></a>map不允许两个元素拥有相同的键值。</h4></li>
<li><p>键值对与python类似</p>
</li>
</ul>
<p><strong>与pair()区别：</strong>map()不允许有相同键值</p>
<p><strong>构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt; map &gt;</span><span class="comment">//头文件</span></span></span><br><span class="line">map&lt;string , <span class="type">int</span> &gt;strMap;</span><br><span class="line"> map&lt;<span class="type">int</span> ,string &gt;intMap;</span><br><span class="line"> map&lt;sring, <span class="type">char</span>&gt;strMap;</span><br><span class="line"> map&lt; <span class="type">char</span> ,string&gt;charMap;</span><br><span class="line"> map&lt;<span class="type">char</span> ,<span class="type">int</span>&gt;charMap;</span><br><span class="line"> map&lt;<span class="type">int</span> ,<span class="type">char</span> &gt;intMap；</span><br></pre></td></tr></table></figure>
<p>基本操作函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>()     <span class="comment">//返回指向map头部的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>()    <span class="comment">//删除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()     <span class="comment">//返回指定元素出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()     <span class="comment">//如果map为空则返回true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>()      <span class="comment">//返回指向map末尾的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">equal_range</span>()  <span class="comment">//返回特殊条目的迭代器对</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()     <span class="comment">//删除一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>()      <span class="comment">//查找一个元素。查的是 健</span></span><br><span class="line"><span class="comment">//当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end()函数的值相同。</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="built_in">get_allocator</span>() <span class="comment">//返回map的配置器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>()     <span class="comment">//插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">key_comp</span>()    <span class="comment">//返回比较元素key的函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>()  <span class="comment">//返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max_size</span>()    <span class="comment">//返回可以容纳的最大元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rbegin</span>()     <span class="comment">//返回一个指向map尾部的逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rend</span>()      <span class="comment">//返回一个指向map头部的逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()      <span class="comment">//返回map中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>()      <span class="comment">//交换两个map</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">upper_bound</span>()   <span class="comment">//返回键值&gt;给定元素的第一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">value_comp</span>()   <span class="comment">//返回比较元素value的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span> ,string&gt; maplive;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,string&gt; <span class="title">value</span><span class="params">(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>)</span></span>;</span><br><span class="line">maplive.<span class="built_in">insert</span>(value);</span><br><span class="line"><span class="comment">//等价于maplive.insert(pair&lt;int,string&gt;(1,&quot;a&quot;));</span></span><br><span class="line"></span><br><span class="line">maplive.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>));</span><br><span class="line">maplive[<span class="number">1</span>]=<span class="string">&quot;a&quot;</span>;<span class="comment">//map中最简单最常用的插入添加！</span></span><br><span class="line"></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; id=&#123;</span><br><span class="line">    &#123;<span class="string">&quot;long&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;ox&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=id[<span class="string">&quot;long&quot;</span>];<span class="comment">//赋键的值1</span></span><br></pre></td></tr></table></figure>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="1-建立基本数据类型的哈希表"><a href="#1-建立基本数据类型的哈希表" class="headerlink" title="1.建立基本数据类型的哈希表"></a>1.建立基本数据类型的<a href="https://so.csdn.net/so/search?q=哈希表&amp;spm=1001.2101.3001.7020">哈希表</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m; <span class="comment">//&lt;string,string&gt;,&lt;char,char&gt;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="2-向哈希表中添加元素"><a href="#2-向哈希表中添加元素" class="headerlink" title="2.向哈希表中添加元素"></a>2.向哈希表中添加元素</h2><h3 id="1）-insert-函数"><a href="#1）-insert-函数" class="headerlink" title="1）.insert 函数"></a>1）.<a href="https://so.csdn.net/so/search?q=insert&amp;spm=1001.2101.3001.7020">insert</a> 函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="2）-用数组方法直接添加"><a href="#2）-用数组方法直接添加" class="headerlink" title="2）.用数组方法直接添加"></a>2）.用数组方法直接添加</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m[<span class="number">3</span>]=<span class="number">30</span>;</span><br><span class="line">m[<span class="number">4</span>]=<span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h2 id="3-成员函数"><a href="#3-成员函数" class="headerlink" title="3.成员函数"></a>3.成员函数</h2><h3 id="begin-end-函数"><a href="#begin-end-函数" class="headerlink" title="begin(),end()函数"></a>begin(),end()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">begin</span>() <span class="comment">//指向哈希表的第一个容器</span></span><br><span class="line">m.<span class="built_in">end</span>()  <span class="comment">//指向哈希表的最后一个容器，实则超出了哈希表的范围，为空</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="find-查找函数"><a href="#find-查找函数" class="headerlink" title="find()查找函数"></a>find()查找函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">find</span>(<span class="number">2</span>)  <span class="comment">//查找key为2的键值对是否存在 ,若没找到则返回m.end()</span></span><br><span class="line"><span class="keyword">if</span>(m.<span class="built_in">find</span>(<span class="number">2</span>)!=m.<span class="built_in">end</span>()) <span class="comment">//判断找到了key为2的键值对</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="count-查找函数"><a href="#count-查找函数" class="headerlink" title="count() 查找函数"></a>count() 查找函数</h3><p>查找哈希表中key为3的键值对，返回其数量，为1，则找到，若没找到则返回0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">count</span>(<span class="number">3</span>)  <span class="comment">//返回 1</span></span><br><span class="line">m.<span class="built_in">count</span>(<span class="number">5</span>)   <span class="comment">//返回0</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="size-函数"><a href="#size-函数" class="headerlink" title="size()函数"></a>size()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">size</span>()   <span class="comment">//返回哈希表的大小</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="empty-函数"><a href="#empty-函数" class="headerlink" title="empty()函数"></a>empty()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">empty</span>()  <span class="comment">//判断哈希表是否为空，返回值为true/false</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="clear-函数"><a href="#clear-函数" class="headerlink" title="clear()函数"></a>clear()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">clear</span>()  <span class="comment">//清空哈希表</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="swap-函数"><a href="#swap-函数" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>交换两个哈希表中的元素,整个哈希表的键值对全部都交换过去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m1;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m2;</span><br><span class="line">m1.<span class="built_in">swap</span>(m2);</span><br><span class="line"><span class="built_in">swap</span>(m1,m2);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h2 id="哈希表的遍历"><a href="#哈希表的遍历" class="headerlink" title="哈希表的遍历"></a>哈希表的<a href="https://so.csdn.net/so/search?q=遍历&amp;spm=1001.2101.3001.7020">遍历</a></h2><h3 id="第一种遍历"><a href="#第一种遍历" class="headerlink" title="第一种遍历"></a>第一种遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : count) &#123;</span><br><span class="line">	<span class="type">int</span> front = p.first;   <span class="comment">//key</span></span><br><span class="line">    <span class="type">int</span> end = p.second;   <span class="comment">//value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<h3 id="第二种遍历"><a href="#第二种遍历" class="headerlink" title="第二种遍历"></a>第二种遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> front = it-&gt;first;   <span class="comment">//key</span></span><br><span class="line">    <span class="type">int</span> end = it-&gt;second;   <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-中map与unordered-map的区别"><a href="#c-中map与unordered-map的区别" class="headerlink" title="c++中map与unordered_map的区别"></a><a href="https://blog.csdn.net/luolaihua2018/article/details/109412566?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164956749716780261913745%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164956749716780261913745&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-109412566.142^v7^pc_search_result_control_group,157^v4^control&amp;utm_term=c%2B%2B%E5%93%88%E5%B8%8C%E8%A1%A8unordered_map%E4%B8%8Emap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%90%97&amp;spm=1018.2226.3001.4187">c++中map与unordered_map的区别</a></h2><ul>
<li>map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</li>
<li>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</li>
</ul>
]]></content>
      <tags>
        <tag>c++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing 语法基础课</title>
    <url>/blot.github.io/2022/04/03/AcWing%20%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="AcWing-语法基础课-笔记"><a href="#AcWing-语法基础课-笔记" class="headerlink" title="AcWing 语法基础课 笔记"></a>AcWing 语法基础课 笔记</h1><hr>
<h2 id="第一讲-变量、输入输出、表达式与顺序语句"><a href="#第一讲-变量、输入输出、表达式与顺序语句" class="headerlink" title="第一讲 变量、输入输出、表达式与顺序语句"></a>第一讲 变量、输入输出、表达式与顺序语句</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 框架</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		结构</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>头文件：</em></strong></p>
<ul>
<li><code>#include &lt;iostream&gt;</code>包括cin / cout / scanf / printf</li>
<li><code>#inlcude &lt;cstdio&gt;</code>包括scanf / printf</li>
<li>其中，<code>cstdio</code>编译速度比<code>iostream</code>快</li>
<li><code>#include &lt;cmath&gt;</code>包括常用数学公式，如</li>
</ul>
<blockquote>
<p>double sqrt(double x);</p>
<p>double pow(double x, double y);</p>
<p>long int abs(long int x);</p>
<p>double fabs(double x);</p>
</blockquote>
<ul>
<li>万能头文件 -&gt; <code>#include &lt;bits/stdc++.h&gt;</code></li>
</ul>
<p><strong><em>变量：</em></strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>字节（byte）</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>单引号</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-231 ~ 231-1</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>6~7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>15~16位有效数字</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>-263 ~ 263-1</td>
</tr>
<tr>
<td>long double</td>
<td>大多16</td>
<td>18~19位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p>浮点数进行比较时，可能出现不准确的情况。原因是，精度不够。一般情况下，会给一个可以接受的误差范围，如：|x-y| &lt;= 10-6。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 2.99999999999999955591</span></span><br><span class="line"><span class="comment">// !=</span></span><br><span class="line"><span class="comment">// equals!</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.20lf\n&quot;</span>,<span class="built_in">sqrt</span>(x) * <span class="built_in">sqrt</span>(x));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sqrt</span>(x) * <span class="built_in">sqrt</span>(x) != x) <span class="built_in">puts</span>(<span class="string">&quot;!=&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(<span class="built_in">sqrt</span>(x) * <span class="built_in">sqrt</span>(x) - x) &lt;= eps)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;equals!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等/小于/大于</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(x - b) &lt;= eps) <span class="built_in">puts</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x &lt; b - eps) <span class="built_in">puts</span>(<span class="string">&quot;小于&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x &gt; b + eps) <span class="built_in">puts</span>(<span class="string">&quot;大于&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong><em>输入输出：</em></strong></p>
<p>scanf / printf</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>scanf / printf</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>%d</td>
</tr>
<tr>
<td>float</td>
<td>%f</td>
</tr>
<tr>
<td>double</td>
<td>%lf</td>
</tr>
<tr>
<td>char</td>
<td>%c 不过滤空格</td>
</tr>
<tr>
<td>long long</td>
<td>%lld</td>
</tr>
</tbody>
</table>
</div>
<p>cin / cout</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>——</th>
<th>————</th>
</tr>
</thead>
<tbody>
<tr>
<td>cin</td>
<td>&gt;&gt; 会忽略中间的空格</td>
</tr>
<tr>
<td>cout</td>
<td>&lt;&lt;</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>自增/自减：</em></strong></p>
<ul>
<li>a = ++x：先加1后赋值</li>
<li>b = x++：先赋值后加1</li>
</ul>
<hr>
<h2 id="第二讲-判断语句"><a href="#第二讲-判断语句" class="headerlink" title="第二讲 判断语句"></a>第二讲 判断语句</h2><p><strong><em>printf格式化输出：</em></strong></p>
<ul>
<li>%5d：最少占用5的宽度，居右，左边加空格</li>
<li>%-5d：居左，右边加空格</li>
<li>%05d：居右，左边补0</li>
<li>%5.1f：宽5，保留1位小数</li>
</ul>
<p><strong><em>if-else语句：</em></strong> 可嵌套，else可省略</p>
<p><strong><em>比较运算符：</em></strong> &gt; / &lt; / == / &gt;= / &lt;= / !=</p>
<p><strong><em>条件表达式：</em></strong> &amp;&amp;(与) / ||(或) / !(非)</p>
<hr>
<h2 id="第三讲-循环语句"><a href="#第三讲-循环语句" class="headerlink" title="第三讲 循环语句"></a>第三讲 循环语句</h2><p><strong><em>while循环：</em></strong> 先判断后执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连续输入n次</span></span><br><span class="line"><span class="keyword">while</span>(n -- )&#123; &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="comment">// 输入0，则结束输入不做处理</span></span><br><span class="line"><span class="comment">// 大多数情况下其返回值为cin本身（非0值），只有当遇到EOF输入时，返回值为0。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; x &amp;&amp; x)&#123; &#125; <span class="comment">//判断两个条件</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; x , x)&#123; &#125; <span class="comment">//忽略逗号前，判断逗号后面的x值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) &amp;&amp; x &gt; <span class="number">0</span>) &#123; &#125;	<span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x &gt; <span class="number">0</span>)  &#125;	<span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x)) &#123; &#125;		    <span class="comment">// 判断是否非法输入（EOF），用于文件读取</span></span><br><span class="line"><span class="comment">// 逗号运算符</span></span><br><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>, 表达式<span class="number">2</span>, 表达式<span class="number">3</span>) &#123;...&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">表达式<span class="number">1</span>;</span><br><span class="line">表达式<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (表达式<span class="number">3</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>do-while循环：</em></strong></p>
<blockquote>
<p>do while语句与while语句非常相似。唯一的区别是，do while语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。</p>
</blockquote>
<p><strong><em>for循环：</em></strong></p>
<p>基本思想：把控制循环次数的变量从循环体中剥离。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//init-statement可以是声明语句、表达式、空语句，一般用来初始化循环变量；</span></span><br><span class="line"><span class="comment">//condition 是条件表达式，和while中的条件表达式作用一样；可以为空，空语句表示true；</span></span><br><span class="line"><span class="comment">//expression 一般负责修改循环变量，可以为空；</span></span><br><span class="line"><span class="keyword">for</span> (init-statement : condition: expression)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>欧几里得距离 / 曼哈顿距离 / 切比雪夫距离：</em></strong></p>
<p>1.欧几里得距离</p>
<p>计算公式（n维空间下）</p>
<p>二维：dis=sqrt( (x1-x2)2 + (y1-y2)2)</p>
<p>三维：dis=sqrt((x1-x2)2 + (y1-y2)2 + (z1-z2)2)</p>
<p>2.曼哈顿距离：两个点在标准坐标系上的绝对轴距总和</p>
<p>dis=abs(x1-x2)+abs(y1-y2) =&gt; 菱形[AcWing 727]</p>
<p>3.切比雪夫距离：各坐标数值差的最大值</p>
<p>dis=max(abs(x1-x2), abs(y1-y2))</p>
<p><strong><em>跳转语句：</em></strong></p>
<ul>
<li>break 可以提前从循环中退出，一般与if语句搭配。</li>
<li>continue 可以直接跳到当前循环体的结尾。作用与if语句类似。</li>
</ul>
<hr>
<h2 id="第四讲-数组"><a href="#第四讲-数组" class="headerlink" title="第四讲 数组"></a>第四讲 数组</h2><p><em>定义&amp;初始化：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量的值全为0</span></span><br><span class="line"><span class="comment">//全局变量存在堆空间，无长度限制</span></span><br><span class="line"><span class="comment">//堆里虚拟分配，使用再开内存，没开的时候标记全部指向0，零页</span></span><br><span class="line"><span class="comment">//堆 数据 / 栈 指令</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量的值是随机的</span></span><br><span class="line">    <span class="comment">// 局部变量存在栈空间，1M左右</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//含有3个元素的数组</span></span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">//长度是3的数组</span></span><br><span class="line">    <span class="type">int</span> c[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//等价于c[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br><span class="line">    <span class="type">char</span> d[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符串数组的初始化</span></span><br><span class="line">    <span class="type">int</span> e[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125; <span class="comment">//将数组全部初始化为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>输入一个n，再输入n个整数。将这个数组顺时针旋转k(k &lt;= n)次，最后将结果输出：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">法一：存a[n]的值，整体后移，将存的值赋给a[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">法二：使用<span class="built_in">reverse</span>()（在algorithm头文件里）；翻转a[]；翻转前半部分；翻转后半部分</span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">=&gt;</span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><em>memset()初始化：</em> -&gt; 比循环赋值效率高</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// memset(数组名， 将每个字节初始化成什么值， 初始多长（单位是Byte）)</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); <span class="comment">//将数组a赋为全0</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">-1</span>, <span class="keyword">sizeof</span> a); <span class="comment">//将数组a赋为全-1</span></span><br><span class="line"><span class="comment">// 如果memset(a, 1, 40)，是将每一个Byte赋为1，而一个int为4Byte</span></span><br><span class="line"><span class="comment">// 此时初始化后的数组值写作二进制为0000 0001 0000 0001 0000 0001 0000 0001</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p><em>memcpy()复制：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>], b[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// memcpy(目标数组名， 源数组名， 源数组Byte长度)</span></span><br><span class="line"><span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span> a);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><em>高精度运算2n：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[N] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> m =<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 低位放0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//判断进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            t += a[j] * <span class="number">2</span>;</span><br><span class="line">            a[j] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t) a[m++] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout &lt;&lt; a[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>多维数组：</em></strong> 数组的数组</p>
<p><em>回形矩阵：</em></p>
<ul>
<li>每一个格子到上下左右四条边的距离最小值</li>
</ul>
<p><em>蛇形矩阵：</em></p>
<ul>
<li>偏移量思想 =&gt; left / right / top / bottom =&gt; 模拟移动过程</li>
<li>撞墙 =&gt; 出界 / 重复</li>
<li>移动 =&gt; 向右走，横坐标不变，纵坐标+1，即(0, 1)；同理，向下走(1, 0)，向左走(0, -1)，向上走(-1, 0)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：yxc</span></span><br><span class="line"><span class="comment">链接：https://www.acwing.com/activity/content/code/content/245992/</span></span><br><span class="line"><span class="comment">来源：AcWing</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n * m; k ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        res[x][y] = k;</span><br><span class="line">        <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || res[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            a = x + dx[d], b = y + dy[d];</span><br><span class="line">        &#125;</span><br><span class="line">        x = a, y = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ ) cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第五讲-字符串"><a href="#第五讲-字符串" class="headerlink" title="第五讲 字符串"></a>第五讲 字符串</h2><p><strong><em>ASCII码：</em></strong></p>
<ul>
<li>48 ~ 57 ： 0 ~ 9</li>
<li>65 ~ 90 ： A ~ Z</li>
<li>97 ~ 127 ： a ~ z</li>
</ul>
<p><strong><em>字符数组：</em></strong></p>
<ul>
<li>字符串是字符数组加上结束符”\0”，字符数组长度至少比字符串多1。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"> <span class="type">char</span> a2[] = <span class="string">&quot;C++&quot;</span>;</span><br><span class="line"> cout &lt;&lt; <span class="keyword">sizeof</span> a2 &lt;&lt; endl; <span class="comment">// 4 </span></span><br><span class="line"> </span><br><span class="line"> <span class="type">char</span> a1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"> cout &lt;&lt; a1 &lt;&lt; endl; <span class="comment">// 从a开始输出</span></span><br><span class="line"> cout &lt;&lt; a1 + <span class="number">1</span> &lt;&lt; endl; <span class="comment">// 从b开始输出</span></span><br><span class="line"> cout &lt;&lt; a1 + <span class="number">2</span> &lt;&lt; endl; <span class="comment">// 从c开始输出 </span></span><br><span class="line"><span class="comment">// 三个函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="built_in">strcmp</span>(a, b); <span class="comment">// a&lt;b 返回-1; a==b 返回0; a&gt;b 返回1</span></span><br><span class="line"><span class="built_in">strcpy</span>(a, b); <span class="comment">// 把b赋给a</span></span><br></pre></td></tr></table></figure>
<p><strong><em>字符串输入/输出：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符数组</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 读到空格或回车为止</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="comment">// 读入空格    </span></span><br><span class="line"><span class="built_in">fgets</span>(s, <span class="number">10000000</span>, stdin);</span><br><span class="line">cin.<span class="built_in">getline</span>(s, <span class="number">100</span>); <span class="comment">// 一行最多</span></span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"><span class="comment">// string型</span></span><br><span class="line">string s;</span><br><span class="line"><span class="comment">// 读入空格</span></span><br><span class="line"><span class="built_in">getlin</span>(cin, s);</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="built_in">puts</span>(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong><em>标准库类型string：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">string s1; <span class="comment">// 默认空字符串</span></span><br><span class="line">string s2 = s1; <span class="comment">// s2是s1的一个副本</span></span><br><span class="line">string s2 = <span class="string">&quot;hiya&quot;</span>; <span class="comment">// s3是该字符串字面值的一个副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">// s4的内容是cccccccccc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读入/输出</span></span><br><span class="line"><span class="comment">//不能用scanf读入，但可以用printf输出</span></span><br><span class="line">cin &gt;&gt; s1;</span><br><span class="line"><span class="built_in">getline</span>(cin, s1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s1.<span class="built_in">c_str</span>()); <span class="comment">// 返回存储s1的字符数组的首地址，用printf输出</span></span><br><span class="line"><span class="built_in">puts</span>(s1);</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">empty</span>(); <span class="comment">// 判断是否为空字符串</span></span><br><span class="line">s1.<span class="built_in">size</span>(); <span class="comment">// 效果如s1.length(), O(1)</span></span><br><span class="line">s1.pop_back; <span class="comment">// 删掉最后一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按字典序比较</span></span><br><span class="line"><span class="comment">// 加法拼接时，要保证加号两边至少有一个string变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> c : s) cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// 顺次遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> &amp;c : s) c = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 可以改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> s; <span class="comment">// 可以自动判别类型</span></span><br></pre></td></tr></table></figure>
<p><strong><em>第一类双指针算法：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">从前向后遍历整个字符串</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//用j把和s[i]相等的这一整段全部找到</span></span><br><span class="line">	<span class="type">int</span> j = i；</span><br><span class="line">	<span class="keyword">while</span>(j&lt;len&amp;&amp;s[j]==s[i]) j++;</span><br><span class="line">	<span class="comment">//j是不等于i的第一个字符</span></span><br><span class="line">	i = j<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>stringstream：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="comment">//123 xxx 321 123.1</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ssin</span><span class="params">(s)</span></span>; <span class="comment">//把字符串初始化为字符串流，类似cin的一个东西，把ssin当成cin即可，从s中提取出任意需要的格式的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line"></span><br><span class="line">    ssin &gt;&gt; a &gt;&gt; str &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="comment">//123/xxx/321/123.1</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第六讲-函数"><a href="#第六讲-函数" class="headerlink" title="第六讲 函数"></a>第六讲 函数</h2><p>组成部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明（不需要写函数体)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 函数定义（需要写函数体）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//返回类型 函数名（参数列表）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	函数体;</span><br><span class="line">	<span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>static：</em></strong></p>
<ul>
<li>开到堆空间里，等于在函数内部声明了一个仅由该函数使用的全部变量</li>
</ul>
<p><strong><em>sizeof：</em></strong></p>
<ul>
<li>int main()里是a[n]数组指针，sizeof a返回整个数组的长度</li>
<li>自定义函数(例如：int foo(int a[]))，a[]是数组的指针，sizeof a只是指针的大小。</li>
</ul>
<p><strong><em>内联函数inline：</em></strong></p>
<ul>
<li><code>inline void foo(int b[])</code>编译器不调用，出现该函数的地方替换成函数体内容，可以提高运行速度</li>
</ul>
<blockquote>
<p>解空间为树状结构时，考虑递推/递归</p>
</blockquote>
<hr>
<h2 id="第七讲-结构体、类、指针、引用"><a href="#第七讲-结构体、类、指针、引用" class="headerlink" title="第七讲 结构体、类、指针、引用"></a>第七讲 结构体、类、指针、引用</h2><p><strong><em>结构体、类：</em></strong></p>
<ul>
<li>在C++中，类似于class，在其中既可以定义数据成员，又可以定义成员函数。</li>
<li>在C++中，struct与class基本是通用的，唯一不同的是如果使用class关键字，类中定义的成员变量或成员函数默认都是private属性的，而采用struct关键字，结构体中定义的成员变量或成员函数默认都是public属性的。</li>
<li>通常，和数据相关的用struct，复杂抽象的用class。</li>
<li>C++构造函数的函数名必须和类名相同。与类构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。</li>
</ul>
<p><strong><em>指针：</em></strong></p>
<p>每一个程序都是一个进程，不同进程间是相互独立的，每个程序相当于一个大数组，所有的变量、代码、调用都是在这个数组里操作的，定义的变量是数组里的值，指针是数组的下标</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//这个*表示定义的p是个指针类型，但变量的名字是p，可以理解为(int*) p</span></span><br><span class="line"><span class="type">int</span> *p = a; <span class="comment">//表示p是int类型变量的指针，让p的值等于a的地址</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//这个*取地址中存放的值，*p表示取到a的值</span></span><br><span class="line">*p = <span class="number">12</span>; <span class="comment">//相当于通过下标修改数组值</span></span><br><span class="line"><span class="comment">//指针的指针是存放指针的地址</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//b 数组指针，存数组开始位置</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;<span class="comment">//c 默认字符串，（void*）c 输出地址</span></span><br></pre></td></tr></table></figure>
<p><strong><em>引用：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;p = a; <span class="comment">//int&amp; p = a</span></span><br><span class="line">p = <span class="number">12</span>; <span class="comment">//a=12</span></span><br><span class="line"><span class="comment">//引用相当于给变量起了个别名</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>作者：xmqv<br>链接：<a href="https://www.zhihu.com/question/37608201/answer/72766337">https://www.zhihu.com/question/37608201/answer/72766337</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>C++primer中对 <strong>对象</strong>的定义：<strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间。<br>一个<strong>对象</strong>a，它有<strong>值</strong>和<strong>地址&amp;a</strong>，运行程序时，计算机会为该对象分配存储空间，来存储该对象的值，我们通过该对象的地址，来访问存储空间中的值</p>
<p><strong>指针</strong>p也是<strong>对象</strong>，它同样有地址&amp;p和存储的值p，只不过，<strong>p存储的数据类型是数据的地址</strong>。如果我们要以p中存储的数据为地址，来访问对象的值，则要在p前加解引用操作符”<em>“,即</em>p。</p>
<p>对象有常量（const）和变量之分，既然指针本身是对象，那么指针所存储的地址也有常量和变量之分，指针常量是指，指针这个对象所存储的地址是不可以改变的，而指向常量的指针的意思是，不能通过该指针来改变这个指针所指向的对象。</p>
<p>我们可以把引用理解成变量的别名。定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。计算机必须<strong>在声明r的同时就要对它初始化</strong>，并且，<strong>r一经声明，就不可以再和其它对象绑定在一起了。</strong></p>
<p>实际上，你也可以把引用看做是通过一个常量指针来实现的，它只能绑定到初始化它的对象上。</p>
<p>关于指针和引用的对比，可以参看&lt;<more effective C++>&gt;中的第一条条款，引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率</p>
<p>比如下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b,*p,&amp;r=a;<span class="comment">//正确</span></span><br><span class="line">r=<span class="number">3</span>;<span class="comment">//正确：等价于a=3</span></span><br><span class="line"><span class="type">int</span> &amp;rr;<span class="comment">//出错：引用必须初始化</span></span><br><span class="line">p=&amp;a;<span class="comment">//正确：p中存储a的地址，即p指向a</span></span><br><span class="line">*p=<span class="number">4</span>;<span class="comment">//正确：p中存的是a的地址，对a所对应的存储空间存入值4</span></span><br><span class="line">p=&amp;b<span class="comment">//正确：p可以多次赋值，p存储b的地址</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong><em>链表：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	Node *next;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node a = <span class="built_in">Node</span>(<span class="number">1</span>); <span class="comment">// 返回的是值</span></span><br><span class="line">	Node* p = &amp;a;</span><br><span class="line">    <span class="comment">// a.val p-&gt;next</span></span><br><span class="line">	Node* p = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>); <span class="comment">// 返回的是地址，动态开辟一段空间，把空间的地址赋给p</span></span><br><span class="line">    Node* q = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    Node* o = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    q-&gt;next = o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p>头结点存放第一个结点的地址。<br><img src="https://img-blog.csdnimg.cn/20210130213831131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1B4eHh4Tg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>链表的删除是指在原链表遍历过程中跳过，不遍历这个点。</p>
<hr>
<h2 id="第八讲-STL容器、位运算与常用库函数"><a href="#第八讲-STL容器、位运算与常用库函数" class="headerlink" title="第八讲 STL容器、位运算与常用库函数"></a>第八讲 STL容器、位运算与常用库函数</h2><p><strong><em>vector：(倍增)</em></strong></p>
<ul>
<li><code>#include &lt;vector&gt;</code></li>
<li>在数组末尾插入删除O ( 1 ) O(1)<em>O</em>(1)，在开头插入删除O ( n ) O(n)<em>O</em>(<em>n</em>)。</li>
<li>迭代器类似数组下标或指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Rec&gt; b;</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">// 随机迭代器 </span></span><br><span class="line">a.<span class="built_in">begin</span>(); <span class="comment">// a的第一个元素的迭代器/地址</span></span><br><span class="line">a.<span class="built_in">end</span>(); <span class="comment">// a的最后一个元素的下个位置的地址</span></span><br><span class="line">it 访问 a[<span class="number">0</span>];</span><br><span class="line">it + <span class="number">2</span> 访问 a[<span class="number">2</span>];</span><br><span class="line">想取到迭代器的值，则加*;</span><br><span class="line">*a.<span class="built_in">begin</span>()等价于a[<span class="number">0</span>]等价于a.<span class="built_in">front</span>();</span><br><span class="line">a.<span class="built_in">back</span>()等价于a[a.<span class="built_in">size</span>()<span class="number">-1</span>], a.<span class="built_in">end</span>()指向a的最后一个元素后一个地址;</span><br><span class="line">a.<span class="built_in">push_back</span>(); <span class="comment">// 把元素x插入到vector a的尾部。</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">// 删除vector a的最后一个元素。</span></span><br><span class="line"><span class="comment">// 三种遍历方法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator i=a.<span class="built_in">begin</span>();i!=a.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x : a) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong><em>queue：先进先出</em></strong></p>
<ul>
<li><code>#include &lt;queue&gt;</code>主要包括循环队列queue和优先队列priority_queue(堆)两个容器。</li>
<li>队列：先进先出，<code>queue&lt;int&gt; a</code></li>
<li>优先队列：又称大根堆，优先出最大值，<code>priority_queue&lt;int&gt; b;</code></li>
<li>小根堆：优先出最小值，<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; m; <span class="comment">// pair二元组</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义结构体类型的大根堆必须重载小于号&lt;。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Rec&amp; t) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a &lt; t.a; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; d;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义结构体类型的小根堆必须重载大于号&gt;。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Rec&amp; t) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; t.a; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; d;</span><br></pre></td></tr></table></figure>
<ul>
<li>queue操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">//在队尾插入一个元素</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">//弹出队头元素</span></span><br><span class="line">q.<span class="built_in">front</span>(); <span class="comment">//返回队头元素</span></span><br><span class="line">q.<span class="built_in">back</span>(); <span class="comment">//返回队尾元素</span></span><br><span class="line">q = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//初始化即可清空</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大根堆操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(); <span class="comment">//把元素插入堆</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">//删除堆顶元素</span></span><br><span class="line">q.<span class="built_in">top</span>(); <span class="comment">//查询堆顶元素（最大值）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>除了队列、优先队列、栈之外，其他所有STL容器均有clear()函数</li>
</ul>
<p><strong><em>stack：先进后出</em></strong></p>
<ul>
<li><code>#include &lt;stack&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">stk.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">//向栈顶插入</span></span><br><span class="line">stk.<span class="built_in">top</span>(); <span class="comment">//得到栈顶元素值</span></span><br><span class="line">stk.<span class="built_in">pop</span>(); <span class="comment">//弹出栈顶元素（最后一个插入的元素）</span></span><br></pre></td></tr></table></figure>
<p><strong><em>deque双端队列：随机存储</em></strong></p>
<ul>
<li>扩展版vector，deque在数组开头/结尾插入删除都是O ( 1 ) O(1)<em>O</em>(1)的。</li>
<li><code>#include &lt;deque&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">begin</span>();a.<span class="built_in">end</span>(); <span class="comment">//返回deque的头/尾迭代器</span></span><br><span class="line">a.<span class="built_in">front</span>();a.<span class="built_in">badk</span>(); <span class="comment">//队头/队尾元素</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//从队尾入队</span></span><br><span class="line">a.<span class="built_in">push_front</span>(<span class="number">2</span>); <span class="comment">//从队头入队</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">//从队尾出队</span></span><br><span class="line">a.<span class="built_in">pop_front</span>(); <span class="comment">//从队头出队</span></span><br><span class="line">a.<span class="built_in">clear</span>(); <span class="comment">//清空队列</span></span><br><span class="line">a[<span class="number">0</span>]; <span class="comment">//随机访问</span></span><br></pre></td></tr></table></figure>
<p><strong><em>set：维护有序序列</em></strong></p>
<ul>
<li><code>#include &lt;set&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; a; <span class="comment">//元素不能重复</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; b; <span class="comment">//元素可以重复</span></span><br></pre></td></tr></table></figure>
<ul>
<li>重载小于号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为set中间会做比较，所以结构体中需要重载小于号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Rec&amp; t) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x &lt; t.x; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; Rec;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); <span class="comment">//仅支持”++”和--“两个与算术相关的操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>set/multiset操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(x); <span class="comment">//把一个元素x插入到集合s中，时间复杂度为O(logn)。</span></span><br><span class="line">s.<span class="built_in">find</span>(x); <span class="comment">//在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。</span></span><br><span class="line">s.<span class="built_in">lower_bound</span>(x); <span class="comment">//查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>(x); <span class="comment">//查找大于x的元素中最小的一个，并返回指向该元素的迭代器。</span></span><br><span class="line">s.<span class="built_in">erase</span>(); <span class="comment">//删除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O(logn).</span></span><br><span class="line"><span class="comment">    设x是一个元素，s.erase(x) 从s中删除所有等于x的元素，时间复杂度为O(k+logn)，其中k是被删除的元素个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.<span class="built_in">count</span>(x); <span class="comment">//返回集合s中等于x的元素个数，时间复杂度为O(k +logn)，其中k为元素x的个数。</span></span><br></pre></td></tr></table></figure>
<p><strong><em>unordered_set：无序set 底层实现哈希表</em></strong></p>
<ul>
<li><code>#inlcude &lt;unordered_set&gt;</code>，其中没有lower_bound()和upper_bound()</li>
<li><code>#inlcude &lt;unordered_multiset&gt;</code></li>
</ul>
<p><strong><em>map：</em></strong></p>
<ul>
<li><code>#include &lt;map&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a; <span class="comment">//和数组类似</span></span><br><span class="line"><span class="comment">//Map的key和value可以是任意类型，其中key必须定义小于号运算符。</span></span><br><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; b;</span><br><span class="line">a[<span class="string">&quot;test&quot;</span>] = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">cout &lt;&lt; a[<span class="string">&quot;test&quot;</span>][<span class="number">2</span>] &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">cout &lt;&lt; a[<span class="string">&quot;test&quot;</span>].<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">size/empty/clear/begin/end均与set类似。</span><br><span class="line">Insert/erase与set类似，但其参数均是pair&lt;key_type, value_type&gt;。</span><br><span class="line">h.<span class="built_in">find</span>(x) 在变量名为h的map中查找key为x的二元组。</span><br><span class="line">[]操作符</span><br><span class="line">h[key] 返回key映射的value的引用，时间复杂度为<span class="built_in">O</span>(logn)。</span><br><span class="line">[]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。</span><br></pre></td></tr></table></figure>
<p><strong><em>bitset：位运算 很长的二进制01串</em></strong></p>
<ul>
<li><code>#include &lt;bitset&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;1000&gt; a;</span><br><span class="line">a.<span class="built_in">set</span>(); <span class="comment">//全部设为1</span></span><br><span class="line">a.<span class="built_in">reset</span>(); <span class="comment">//全部设为0</span></span><br></pre></td></tr></table></figure>
<p><strong><em>pair：</em></strong></p>
<ul>
<li><code>a.first()</code>和<code>a.second</code>分别输出第一个和第二个值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, string&gt; a;</span><br><span class="line">a = &#123;<span class="number">3</span>, <span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">a = <span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="string">&quot;check&quot;</span>); <span class="comment">//c++99的赋值</span></span><br></pre></td></tr></table></figure>
<p><strong><em>位运算：</em></strong></p>
<ul>
<li><p>与 &amp; 或 | 取反 ~ 异或 ^</p>
</li>
<li><p>左移&lt;&lt;：a&lt;<k => a*2k</p>
</li>
<li><p>右移&gt;&gt;：a&gt;&gt;k =&gt; a/2k</p>
</li>
<li><p>常用操作：</p>
<p>(1) 求x的第k位数字 x &gt;&gt; k &amp; 1</p>
<p>(2) lowbit(x) = x &amp; -x，返回x的最后一位1 ( x &amp; (~x + 1))</p>
</li>
</ul>
<p><strong><em>常用库函数：</em></strong></p>
<p>(1) reverse 翻转</p>
<ul>
<li><p>翻转一个vector：</p>
<p><code>reverse(a.begin(), a.end());</code></p>
</li>
<li><p>翻转一个数组，元素存放在下标1~n：</p>
<p><code>reverse(a + 1, a + 1 + n);</code></p>
</li>
</ul>
<p>(2) unique 去重</p>
<ul>
<li><p>返回去重之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。</p>
</li>
<li><p>把一个vector去重：</p>
<p><code>int m = unique(a.begin(), a.end()) – a.begin();</code></p>
</li>
<li><p>把一个数组去重，元素存放在下标1~n：</p>
<p><code>int m = unique(a + 1, a + 1 + n) – (a + 1);</code></p>
</li>
<li><p><code>a.erase(unique(a.begin(), a.end()), a.end()) //输出去重后的数组</code></p>
</li>
</ul>
<p>(3) random_shuffle 随机打乱</p>
<ul>
<li>用法与reverse相同</li>
</ul>
<p>(4) sort</p>
<ul>
<li>对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。</li>
<li>把一个int数组（元素存放在下标1~n）从大到小排序，传入比较函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[MAX_SIZE];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b; &#125; a是否应该排在b的前面，<span class="literal">true</span>应该，<span class="literal">false</span>不应该</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br></pre></td></tr></table></figure>
<ul>
<li>把自定义的结构体vector排序，重载“小于号”运算符：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123; <span class="type">int</span> id, x, y; &#125;</span><br><span class="line">vector&lt;rec&gt; a;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> rec &amp;a, <span class="type">const</span> rec &amp;b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>(5) lower_bound/upper_bound 二分</p>
<ul>
<li><p>lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。</p>
</li>
<li><p>upper_bound 的用法和lower_bound大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p>
</li>
<li><p>在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标：</p>
<p><code>int I = lower_bound(a + 1, a + 1 + n,. x) – a;</code></p>
</li>
<li><p>在有序<code>vector&lt;int&gt;</code> 中查找小于等于x的最大整数（假设一定存在）：</p>
<p>`int y = *–upper_bound(a.begin(), a.end(), x);</p>
</li>
</ul>
]]></content>
      <categories>
        <category>acwing基础算法</category>
      </categories>
      <tags>
        <tag>acwing</tag>
      </tags>
  </entry>
  <entry>
    <title>1.acwing基础算法</title>
    <url>/blot.github.io/2022/06/03/acwing%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h1><ul>
<li>上课学习主要思想</li>
<li>下课背模板，一个类型的题目做3到5遍</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>———<strong>分治</strong></p>
<p><strong>主要思想</strong></p>
<ol>
<li>确定分界点：q[l],q[(l+r)/2],q[r],随机</li>
<li>调整区间（区间一分为2）：在一个区间小于x,另一个区间大于x</li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202232023965.jpg" alt=""></p>
<p>  3.递归处理左右两端</p>
<h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203022010325.jpg" alt=""></p>
<ol>
<li>第一步，先v判断v&lt;x,满足则一直判断下一个位置</li>
<li>第二，若v&gt;=x,则判断r&gt;x,满足则判断下一个位置</li>
<li>第三，若r&lt;=x，交换对应的数值大小</li>
<li>然后递归处理两端</li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203012314248.gif" alt=""></p>
<p><strong>时间复杂度</strong></p>
<ul>
<li>最好时间复杂度:  $O(nlog_2n)$</li>
<li>最坏时间复杂度:  $O(n^2)$</li>
<li>平均时间复杂度:  $O(nlog_2n)$</li>
</ul>
<p><a href="https://www.acwing.com/problem/content/submission/code_detail/11404073/">题目</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//l为最左端，r为最右端，x为判断值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//最终条件,左遇右,回归</span></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l+r&gt;&gt;<span class="number">1</span>];;<span class="comment">//初始化，l+r的值右移1位，相当l+r的值除以2取整</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)<span class="comment">//判断相遇，则退出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);<span class="comment">//判断左端数据，小于x</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);<span class="comment">//判断右端数据,小于y</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);<span class="comment">//交换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);<span class="comment">//左递归</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);<span class="comment">//右递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><ul>
<li>开辟2个新空间，判断大小并存于相应空间内，最后再将新空间分别个原空间</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202232023340.jpg" alt=""></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><a href="https://blog.csdn.net/ww753951/article/details/118510821?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164622666416780255287758%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164622666416780255287758&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118510821.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3&amp;spm=1018.2226.3001.4187">归并排序</a></h2><p><strong>思想</strong></p>
<ol>
<li>确定分界点：mid=(l+r)/2</li>
<li>归并排序left,right</li>
<li>归并（合二为一）—难点</li>
</ol>
<p><a href="https://blog.csdn.net/u010711495/article/details/116891262?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164622666416780255279046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164622666416780255279046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-116891262.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3&amp;spm=1018.2226.3001.4187">图解过程</a></p>
<p>图解</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203022114282.png" alt=""></p>
<p><strong>稳定性好</strong></p>
<ul>
<li>在排序对比时，遇到相同位置的数字，不发生交换，就比较稳定；可能发生交换不稳定</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205162334188.gif" style="zoom:200%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//回归条件</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//取中间值，</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);<span class="comment">//左端递归排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);<span class="comment">//右端递归排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并合一，两个有序序列合成一个有序序列</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;<span class="comment">//i指向左半边,j指向右半边</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两边都没有循环完，判断大小</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左右其中一边没有循环完的接到序列后面</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将tem付给q数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong></p>
<ul>
<li>最好/平均/最坏时间复杂度:  $O(nlog_2n)$</li>
</ul>
<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a><strong>核心</strong></h3><ol>
<li>如果有单调性，一定可以二分，但是可以二分的题目，不一定有单调性。</li>
<li>二分的本质，<strong>问题一半满足，一半不满足，可以寻找到边界</strong>，这个边界可以将数组分为两个部分。因为整数边界必须做出选择，代码将有两个模板。而浮点数不是</li>
</ol>
<p>对于整数二分而言，“求分界点”也就是求左侧部分（满足性质A AA）的最后一个数，或者求右侧部分（不满足性质A AA）的第一个数。</p>
<p><strong>感觉就是区间找边界</strong></p>
<p><a href="https://www.acwing.com/problem/content/791/">题目</a></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204022250225.jpg" alt=""></p>
<p><strong>条件</strong>:一般都含有等于</p>
<p><strong>满足左侧最后一个数</strong></p>
<ul>
<li>满足条件mid&lt;=7，说明mid在（目标值的）左边，所以要更新将mid更新为新的左边界（靠近目标值）</li>
<li>mid=l+r+1&gt;&gt;1;</li>
</ul>
<p><strong>满足(条件)右侧第一个数</strong></p>
<ul>
<li>满足条件mid&gt;=7,说明mid在（目标值）右边，所以要更新mid作为新的右边界</li>
<li>而求左侧部分（满足性质A AA）的最后一个数，或者求右侧部分（不满足性质A AA）的第一个数<ul>
<li>理解：比如说mid&lt;=7：满足性质的最后一个数；第一个数7就是不满足mid&lt;7的第一个数</li>
</ul>
</li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><strong>思想</strong></h3><ol>
<li>首先保证数组有序，二分一定有解，但题目可能无解</li>
<li>首先找到<a href="https://so.csdn.net/so/search?q=数组&amp;spm=1001.2101.3001.7020">数组</a>的中间值，mid=(left+right)&gt;&gt;1，区间[left, right]被划分成[left, mid]和[mid + 1, right]；如果是mid = l + r + 1 &gt;&gt; 1，区间[left, right]被划分成[left, mid - 1]和[mid, right]。</li>
<li>然后通过check(mid)判断中间值是不是满足这个性质,check是根据不同的题型编写的。</li>
<li>最后就能使用折半，缩小<a href="https://so.csdn.net/so/search?q=区间&amp;spm=1001.2101.3001.7020">区间</a>了，如果区间缩到了1，那么那个也就是答案。</li>
</ol>
<h3 id="模板例子解释"><a href="#模板例子解释" class="headerlink" title="模板例子解释"></a>模板例子解释</h3><p>求左侧最后一个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="comment">//边界在mid的右边</span></span><br><span class="line"><span class="comment">//找满足左侧性质的最后一个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//+1防止死循环，防止mid=l,l=l</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求右侧第一个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最开始的区分时</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="comment">//边界在mid的左边</span></span><br><span class="line"><span class="comment">//求右侧部分（不满足性质A AA）的第一个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//左边界;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质；左侧满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;<span class="comment">//右侧不满足性质</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a><a href="https://www.acwing.com/problem/content/792/">浮点数二分</a></h2><ul>
<li>时刻要保证答案在要寻找区间</li>
<li>无边界问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">double</span> eps=<span class="number">1e-8</span>,l=<span class="number">-100</span>,r=<span class="number">100</span>;<span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//一直二分</span></span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid&gt;=n) r=mid;<span class="comment">//边界在mid的左边</span></span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++<a href="https://www.acwing.com/problem/content/description/793/">代码</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    <span class="comment">//保证A的位数比B多</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);<span class="comment">//取余数,当前</span></span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//进位数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);<span class="comment">//最高位的进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203062148103.jpg" alt=""></p>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a><a href="https://www.acwing.com/problem/content/794/">高精度减法</a></h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;<span class="comment">//t为借位,c[i]=a[i]-b[i]-t</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);<span class="comment">//保证c[i]为正</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">//借位只有0,1,小于0借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//003情况,去除0返回3</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断A是否大于B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//从最高位判断</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p><a href="https://www.acwing.com/problem/content/description/795/">题目</a></p>
<ul>
<li>注意返回要去除最高位0</li>
<li>进位可能很能很大</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203081644298.jpg" alt=""></p>
<p>注意：代码主要是<strong>高精度</strong>乘以有限大（）</p>
<p><strong>高精度乘低精度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C=A*b;A为已经逆序的整数数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        t += A[i] * b;       <span class="comment">// t + A[i] * b = 7218</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>); <span class="comment">// 只取个位 8</span></span><br><span class="line">        t /= <span class="number">10</span>;             <span class="comment">// 721 看作 进位,可能有很多位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t) &#123;            <span class="comment">// 处理最后进位,处理最后剩余的 t</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//去除最高位0，可能b=0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>高精度除以低精度</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203081719844.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		r=r*<span class="number">10</span>+A[i];<span class="comment">//余数乘10加当前位</span></span><br><span class="line">		C.<span class="built_in">push_back</span>(r/b);<span class="comment">//r/b作为该位的商 (0~9)</span></span><br><span class="line">		r%=b;<span class="comment">//作为余数</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//算出的商(1在最高位)123，reverse反转321,主函数逆序输出123</span></span><br><span class="line">	<span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());<span class="comment">//数组反转;因为开始的商在最高位，为了与主函数对应</span></span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();<span class="comment">//去前导0</span></span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a><a href="https://www.acwing.com/problem/content/797/">一维前缀和</a></h2><ul>
<li>主要思想先算出存储前i项的前缀和，则l到r的前缀和如下图</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]<span class="comment">//s[i]存储下标为1到i的和</span></span><br><span class="line">    </span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]<span class="comment">//l到r的前缀和，s[l-1]不包括a[l]</span></span><br></pre></td></tr></table></figure>
<h2 id="二位前缀和"><a href="#二位前缀和" class="headerlink" title="二位前缀和"></a><a href="https://www.acwing.com/problem/content/798/">二位前缀和</a></h2><p>计算s[i,j]</p>
<p><strong>跟子矩阵有关系</strong></p>
<ul>
<li>求前缀和</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203091314706.png" alt="image-20220309131412428"></p>
<ul>
<li>求子矩阵</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203091314948.png" alt="image-20220309131350008"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i, j] <span class="comment">//为第i行j列格子左上部分所有元素的和</span></span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];<span class="comment">//计算s[i][j]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为</span></span><br><span class="line">s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a><a href="https://www.acwing.com/problem/content/description/799/">一维差分</a></h2><p><strong>差分数组：</strong></p>
<p>首先给定一个原数组<code>a</code>：<code>a[1], a[2], a[3],,,,,, a[n];</code></p>
<p>然后我们构造一个数组<code>b</code> ： <code>b[1] ,b[2] , b[3],,,,,, b[i];</code></p>
<p>使得 <code>a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]</code></p>
<p>也就是说，<code>a</code>数组是<code>b</code>数组的前缀和数组，反过来我们把<code>b</code>数组叫做<code>a</code>数组的<strong>差分数组</strong>。换句话说，每一个<code>a[i]</code>都是<code>b</code>数组中从头开始的一段区间和。</p>
<p>考虑如何构造差分<code>b</code>数组？</p>
<p>最为直接的方法</p>
<p><strong>如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span> ]= <span class="number">0</span>;</span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">1</span>] - a[<span class="number">0</span>];</span><br><span class="line">b[<span class="number">2</span>] = a[<span class="number">2</span>] - a[<span class="number">1</span>];</span><br><span class="line">b[<span class="number">3</span>] =a [<span class="number">3</span>] - a[<span class="number">2</span>];</span><br><span class="line">........</span><br><span class="line">b[n] = a[n] - a[n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>
<p><strong>图示:</strong><br><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203101253916.png" alt="&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215214337143.png&quot;   width=&quot;80%&quot;&gt;"></p>
<p>我们只要有<code>b</code>数组，通过前缀和运算，就可以在<code>O(n)</code> 的时间内得到<code>a</code>数组 。</p>
<p><strong>知道了差分数组有什么用呢？</strong> 别着急，慢慢往下看。</p>
<p><strong>话说有这么一个问题：</strong></p>
<p>给定区间<code>[l ,r ]</code>，让我们把<code>a</code>数组中的<code>[ l, r]</code>区间中的每一个数都加上<code>c</code>,即 <code>a[l] + c , a[l+1] + c , a[l+2] + c ,,,,,, a[r] + c</code>;</p>
<p>暴力做法是<code>for</code>循环<code>l</code>到<code>r</code>区间，时间复杂度<code>O(n)</code>，如果我们需要对原数组执行<code>m</code>次这样的操作，时间复杂度就会变成<code>O(n*m)</code>。有没有更高效的做法吗? <strong>考虑差分做法</strong>。</p>
<p><strong>始终要记得，a数组是b数组的前缀和数组</strong>，比如对<code>b</code>数组的<code>b[i]</code>的修改，会影响到<code>a</code>数组中从<code>a[i]</code>及往后的每一个数。</p>
<p>首先让差分<code>b</code>数组中的 <code>b[l] + c</code> ,<code>a</code>数组变成 <code>a[l] + c ,a[l+1] + c,,,,,, a[n] + c</code>;</p>
<p>然后我们打个补丁，<code>b[r+1] - c</code>, <code>a</code>数组变成 <code>a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c</code>;</p>
<p><strong>为啥还要打个补丁</strong>？</p>
<p><strong>我们画个图理解一下这个公式的由来:</strong><br><img src="https://img-blog.csdnimg.cn/20201215163431253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>b[l] + c</code>，效果使得<code>a</code>数组中 <code>a[l]</code>及以后的数都加上了<code>c</code>(红色部分)，但我们只要求<code>l</code>到<code>r</code>区间加上<code>c</code>, 因此还需要执行 <code>b[r+1] - c</code>,让<code>a</code>数组中<code>a[r+1]</code>及往后的区间再减去<code>c</code>(绿色部分)，这样对于<code>a[r]</code> 以后区间的数相当于没有发生改变。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>因此我们得出<strong>一维差分结论</strong>：给<code>a</code>数组中的<code>[ l, r]</code>区间中的每一个数都加上<code>c</code>,只需对差分数组<code>b</code>做 <code>b[l] + = c</code>, <code>b[r+1] - = c</code>。时间复杂度为<code>O(1)</code>, 大大提高了效率。</p>
<p><img src="https://img-blog.csdnimg.cn/20201217172005485.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//差分公式，最后求前缀和</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	b[l] += c;</span><br><span class="line">	b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a><a href="https://www.acwing.com/problem/content/800/">二维差分</a></h2><p>跟一维差分思想差不多</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203102019216.jpg" alt=""></p>
<p>关系如上图，求其中子矩阵的二维差分矩阵</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204072236908.png" alt="image-20220407223606425"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s[i][j]为b[i][j]的前缀和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	b[x1][y1]+=c;</span><br><span class="line">	b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">	b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">	b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制中一个数"><a href="#二进制中一个数" class="headerlink" title="二进制中一个数"></a>二进制中一个数</h2><p><strong>n的二进制表示中第k位是几</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203111228807.png" alt="image-20220311122814447"></p>
<ol>
<li>先把第K的右移到最后一位    n&gt;&gt;k，第k位关系如上图（4不是）</li>
<li>x&amp;1：判断最后一位是否为1.</li>
<li>综合：n &gt;&gt; k &amp; 1</li>
</ol>
<p>lowbit()方式原理</p>
<ul>
<li>对x的位运算操作</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203111259056.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line"><span class="comment">//返回n的最后一位1(及后面的0)：lowbit(n) = n &amp; -n</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;   </span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><ul>
<li>快速排序和归并排序都算双指针算法</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203131248684.png" alt="image-20220313124846390"></p>
<ul>
<li>将右边核心思想复杂度为O(n^2),左边为O(n)</li>
<li>先想暴力，找单调性，再根据模板优化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><ul>
<li>主要是对应的坐标和数值，存储好坐标和数值；题目后面要用数值和坐标，所以将这些稀疏的数值重新映射到数组下标从0到n的数组内，找到数值</li>
<li>因为数组存储时，坐标是从小到大存储，不能快速找到存储，所以用piar存储坐标和值，然后寻找就行</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203161953374.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a><a href="https://www.acwing.com/problem/content/805/">区间合并</a></h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203171301673.jpg" alt=""></p>
<p><strong>分析</strong></p>
<ul>
<li>先按左端点排序</li>
<li>比较参考区间a和区间b有三种情况：包含，相交，分离</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());<span class="comment">//对区间的端点排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;<span class="comment">//设置左右初值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)<span class="comment">//维护区间(st,ed)严格在枚举区间右边(seg);即无交集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//判断不为开始初始值,添加信息</span></span><br><span class="line">            st = seg.first, ed = seg.second;<span class="comment">//更新维护区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);<span class="comment">//有交集,更新右端点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//防止空区间,同时添加最后一段区间</span></span><br><span class="line">    segs = res;<span class="comment">//更新segs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7$∼$10^8$ 为最佳。$$</p>
<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>
<blockquote>
<ol>
<li><p>n≤30, 指数级别, dfs+剪枝，状态压缩dp</p>
</li>
<li><p>n≤100 =&gt; O($n^3$)，floyd，dp，高斯消元</p>
</li>
<li><p>n≤1000 =&gt; O($n^2$)，O($n^3logn$)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</p>
</li>
<li><p>n≤10000 =&gt; O($n*\sqrt{n}$)，块状链表、分块、莫队</p>
</li>
<li><p>n≤100000&gt; O($nlogn$) =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</p>
</li>
<li><p>n≤1000000=&gt; O($n^2$), 以及常数较小的 O($nlogn$) 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa</p>
</li>
<li><p>n≤10000000=&gt; O($n$)，双指针扫描、kmp、AC自动机、线性筛素数</p>
</li>
<li><p>n≤$10^9$ =&gt; O($\sqrt{n}$)，判断质数</p>
</li>
<li><p>n≤$10^{18}$=&gt; O($nlogn$) ，最大公约数，快速幂，数位DP</p>
</li>
<li><p>n≤$10^{1000}$ =&gt; O($(logn)^2$)，高精度加减乘除</p>
</li>
<li><p>n≤$10^{100000}$ =&gt; O($logk×loglogk$)，k表示位数，高精度加减、FFT/NTT</p>
</li>
</ol>
</blockquote>
<h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><p>用数组模拟链表</p>
<ul>
<li>用new生成链表，容易超时，所以用数组模拟链表</li>
</ul>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203211255359.jpg" alt=""></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203221230609.png" alt="image-20220322123006356"></p>
<ul>
<li>邻接表（n个链表）：常用来存储图和树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，</span></span><br><span class="line"><span class="comment">//e[]存储节点的值</span></span><br><span class="line"><span class="comment">//ne[]存储节点的next指针</span></span><br><span class="line"><span class="comment">//idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//空节点</span></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_head</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a;<span class="comment">//新结点赋值</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//该节点存储头结点指向的下标</span></span><br><span class="line">    head = idx ;<span class="comment">//头结点指向idx所对应的下标</span></span><br><span class="line">    idx++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx]=a;<span class="comment">//新结点赋值</span></span><br><span class="line">    ne[idx]=ne[k];<span class="comment">//该新节点指向下标是k的下一个结点下标</span></span><br><span class="line">    ne[k]=idx;<span class="comment">//下标是k的结点指向当前新节点</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];<span class="comment">//就是下标是k的点指向k后面点指向的坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/problem/content/description/828/">单链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], head, idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对链表进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//最开始的时候，链表的头节点要指向-1，</span></span><br><span class="line">    <span class="comment">//为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。</span></span><br><span class="line"><span class="comment">    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当它在初始化的时候指向-1，来表示链表离没有内容。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找</span></span><br><span class="line">    <span class="comment">//第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下</span></span><br><span class="line">    <span class="comment">//标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插入到头节点上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">int_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//和链表中间插入的区别就在于它有head头节点</span></span><br><span class="line">    e[idx] = x;<span class="comment">//第一步，先将值放进去</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了</span></span><br><span class="line">    <span class="comment">//先在只是做到了第一步，将元素x的指针指向了head原本指向的</span></span><br><span class="line">    head = idx;<span class="comment">//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）</span></span><br><span class="line">    idx ++;<span class="comment">//指针向下移一位，为下一次插入元素做准备。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到下标为k的点的后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//先将元素插进去</span></span><br><span class="line">    ne[idx] = ne[k];<span class="comment">//让元素x配套的指针，指向它要占位的元素的下一个位置</span></span><br><span class="line">    ne[k] = idx;<span class="comment">//让原来元素的指针指向自己</span></span><br><span class="line">    idx ++;<span class="comment">//将idx向后挪</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点个删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];<span class="comment">//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">char</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">int_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) head = ne[head];<span class="comment">//删除头节点，相当新的头结点指向原来头结点指向的下一个结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);<span class="comment">//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k, x;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);<span class="comment">//同样的，第k个数，和下标不同，所以要减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><ul>
<li>常用来优化某些问题</li>
</ul>
<p>用数组模拟</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203241225928.png" alt=""></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203241225653.png" alt=""></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203241225664.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="comment">//l[]表示前指针，r[]表示右端点</span></span><br><span class="line"><span class="comment">//数组下标不代表数组顺序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 规定 0号是最左边的哨兵， 1号是最右边的哨兵，可用的idx从2开始，且n[i]在i=1和0内容，</span></span><br><span class="line">    <span class="comment">//0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//r表示</span></span><br><span class="line">    l[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//相当第一个元素是从下标2开始</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下标是k的点的右边,插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx]=x;<span class="comment">//赋值，idx为当前，k为前面的点</span></span><br><span class="line">    r[idx]=r[k];<span class="comment">//idx的后指针指向k的后指针</span></span><br><span class="line">    l[idx]=k;<span class="comment">//idx前指针指向k</span></span><br><span class="line">    l[r[k]]=idx;<span class="comment">//k的后指针的前指针指向idx</span></span><br><span class="line">    r[k]=idx;<span class="comment">//k的后指针指向idx</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除下标是k的点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];<span class="comment">//k的前指针的后指针指向k的后指针</span></span><br><span class="line">    l[r[k]]=l[k];<span class="comment">//k的后指针的前指针指向k的前指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/problem/content/description/829/">双链表实现</a></p>
<blockquote>
<p>0为第一个插入的数字，数组下标为2，所以传入插入函数为k+1</p>
<p>删除也是同样的道理</p>
</blockquote>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204211645273.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>, r[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//* 初始化 第一个点的右边是 1   第二个点的左边是 0</span></span><br><span class="line">    idx = <span class="number">2</span>;<span class="comment">//! idx 此时已经用掉两个点了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//* 在第 K 个点右边插入一个 X </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k]; <span class="comment">//todo 这边的 k 不加 1 ， 输入的时候 k+1 就好</span></span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;<span class="comment">//! 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*删除第 k个 点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;R&quot;</span>)<span class="comment">//最右边插入元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>], x); <span class="comment">//!   0和 1 只是代表 头和尾  所以   最右边插入 只要在  指向 1的 那个结点的右边插入就可以了</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最左边插入元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;L&quot;</span>)<span class="comment">//! 同理  最左边插入就是 在指向 0的数的左边插入就可以了   也就是可以直接在 0的 有右边插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k + <span class="number">1</span>, x);<span class="comment">//idx从2开始;k表示第k个插入的数,k=1时，在该点右端插入一个数，但这个结点对应的下标为2（k+1）,</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依次输出，从r[0]开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204212054383.gif" alt=""></p>
<ul>
<li>特点：<strong>先进后出</strong>，弹出栈顶元素或者压入栈顶元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶,初始化</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;<span class="comment">//++tt先加一后赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)<span class="comment">//tt&gt;0不为空</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> skt[N],tt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;push&quot;</span>)&#123;  <span class="comment">//压入栈顶元素</span></span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            skt[++tt]=x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;pop&quot;</span>)&#123;   <span class="comment">//删除栈顶元素</span></span><br><span class="line">            tt--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tt&gt;<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;skt[tt]&lt;&lt;endl;  <span class="comment">//输出栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><strong>应用</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203301237717.jpg" alt=""></p>
<ul>
<li>用来返回x的左边最近且比x小(不存在返回-1)</li>
<li>就是将判断大小，如果栈顶元素比当先的数x,则弹出栈元素；直到x比栈顶元素大，并且将x压入栈顶元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;<span class="comment">//插入数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回x左边最近且比x小的数</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203301240124.gif" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;<span class="comment">//如果栈顶元素大于当前待入栈元素，则出栈</span></span><br><span class="line">        <span class="keyword">if</span>(tt) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);<span class="comment">//栈顶元素就是左侧第一个比它小的元素。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);<span class="comment">//如果栈空，则没有比该元素小的值。</span></span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>特点：<strong>先进先出</strong></li>
<li>队头为删除的一端；队尾为插入的一端</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203291250162.jpg" alt=""></p>
<h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)<span class="comment">//tt&gt;=hh不为空</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tt为队尾,hh为队头</span></span><br><span class="line">    <span class="type">int</span> q[N],tt=<span class="number">-1</span>,hh=<span class="number">0</span>,m;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;push&quot;</span>)&#123;  <span class="comment">//队列尾部插入值</span></span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q[++tt]=x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;pop&quot;</span>)&#123;   <span class="comment">//弹出栈顶元素</span></span><br><span class="line">            hh++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;((tt&gt;=hh) ? <span class="string">&quot;NO&quot;</span>:<span class="string">&quot;YES&quot;</span>)&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             cout&lt;&lt;q[hh]&lt;&lt;endl;<span class="comment">//输出队头元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><ul>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;<span class="comment">//判断指针是否超出数组范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><ul>
<li>将队列中的没有用的元素删掉——具有单调性</li>
<li>可以用O(1)的时间从队头/队尾取出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><a href="https://www.acwing.com/problem/content/description/156/">滑动窗口</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//q[N]存储的值是a[]的下标</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="comment">//输出最小值,队头元素最小，队尾最大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;                  <span class="comment">// 判断窗口长度是否大于当前队头的位置，大于，则hh加1，恢复大原来窗口大小</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    <span class="comment">// 第一个条件队列不为空，则t--;第二个条件判断队尾不单调（当前数值x与之前队尾对应的数值y对比，当前的小，则将小的数值作为新的队尾,t--），则tt减1</span></span><br><span class="line">        q[++ tt] = i;                                  <span class="comment">// 下标加到队尾</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);       <span class="comment">// 输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    hh = <span class="number">0</span>; tt = <span class="number">-1</span>; <span class="comment">// 重置！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出最大值，队头元素最大，队尾最小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="KMP匹配算法"><a href="#KMP匹配算法" class="headerlink" title="KMP匹配算法"></a>KMP<a href="https://www.acwing.com/problem/content/discussion/content/1604/">匹配算法</a></h2><ul>
<li>应用环境：有一个文本串S，和一个模式串P，现在要判断S中是否有和P匹配的子串，并查找P在S中的位置，怎么解决呢？</li>
</ul>
<p><strong>暴力算法思路</strong></p>
<blockquote>
<p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p>
<p>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；如果匹配失败（即S[i]! = P[j]），令i = i - j + 1，j = 0，即每次匹配失败时，i 回溯到上次开始匹配的下一个位置，j 被置为0。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[N],p[M];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=p[j])&#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<ul>
<li>next[i]=j:以i为终点后缀和从1开始的前缀相等，且后缀长度最长；</li>
<li>最大前缀数和后缀数要小于字符串本身长度</li>
</ul>
<p>P=“ababf” 的最长公共前后缀：</p>
<ul>
<li>P[0] 前面没有字符串，所以最长公共前后缀长度为 0。</li>
<li>P[1] 前面的字符串为：a，a没有前后缀(前后缀长度要小于字符串长度)。最长公共前后缀长度为 0。</li>
<li>P[2] 前面的字符串为：ab，它的前缀为：a，后缀为b。前缀不等于后缀，所以没有公共前后缀，最长公共前后缀长度为 0。</li>
<li>P[3] 前面的字符串为：aba，aba 的前缀有：a，ab， 后缀有：a，ba。因为 ab 不等于 ba，所以最长公共前后缀为 a，最长公共前后缀长度为 1。</li>
<li>P[4] 前面的字符串为：abab，abab 的前缀有：a，ab，aba，后缀有：a，ab, bab。最长公共前后缀为 ab，长度为 2。</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204271207515.png" alt=""></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204011255031.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p是模式串（子串）</span></span><br><span class="line">p[<span class="number">1</span>,j]=p[i-j+<span class="number">1</span>,i]<span class="comment">//长度相等</span></span><br></pre></td></tr></table></figure>
<p> <strong>KMP主要分两步：求next数组、匹配字符串。</strong></p>
<h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><ul>
<li>就是求P数组自身的最长前缀</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204251333176.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//j大于0才有意义;当p[i] != p[j + 1]说明不匹配，需要重新</span></span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//将上一个位置的值赋给当前位置</span></span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//当前元素匹配，j++</span></span><br><span class="line">        ne[i] = j;<span class="comment">//记录当前数组下标为i的前缀数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204280008641.gif" alt=""></p>
<h3 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204251328676.png" alt=""></p>
<ul>
<li>当匹配过程到上图所示时，</li>
<li><code>s[a,b] = p[1,j] &amp;&amp; s[i] != p[j+1]</code> 此时要移动p串（不是移动1格，而是直接移动到下次能匹配的位置）</li>
<li>其中1串为<code>[1, next[ j ]]</code>，3串为<code>[j-next[j]+1,j]</code>。由匹配可知 1串等于3串，3串等于2串。所以<strong>直接移动p串使1到3的位置</strong>即可。这个操作可由<strong>j = next[ j ]</strong>直接完成。 如此往复下去，当 j == m时匹配成功。</li>
<li>不满足时相等时，相当于移动最长公共前后缀的长度，保证了此时最长前缀是一样的。</li>
</ul>
<h4 id="动画-1"><a href="#动画-1" class="headerlink" title="动画"></a>动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204281710562.gif" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//相当向后移动字符串</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//当最后一个满足是j++就可以与n相等</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="comment">//ne[]为next数组</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span></span><br><span class="line">    <span class="comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//当前元素匹配，j移向p串下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功，进行相关操作</span></span><br><span class="line">        j = next[j];  <span class="comment">//继续匹配下一个子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="Trie字符串统计"><a href="#Trie字符串统计" class="headerlink" title="Trie字符串统计"></a>Trie字符串统计</h3><p><strong>Trie树</strong>：又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构</p>
<p><strong>结构</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205021822917.png" alt=""></p>
<blockquote>
<p>上述字符串中，对于ab字符串的个数为0</p>
<p>返回的字符串个数是指的插入字符串的个数</p>
</blockquote>
<p><strong>数组模拟Trie树</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205021823550.png" alt=""></p>
<p><strong>实际走向</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071524027.jpeg" alt="绘图2.jpg"></p>
<p><strong>插入</strong></p>
<ul>
<li>结点序号代表的存储位置，字母不存在就要开辟新结点，用来存储该字母</li>
<li>son：p可以理解为当前结点的父节点，u就是该结点存储的字符信息，两个一起确定结点的具体位置；存储的信息相当于<strong>下一字符的父节点idx</strong></li>
<li>在cnt[p]：p含义就是该字符的结点序号信息；存储的信息就是该节点出现的次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">//类似指针，指向当前节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)<span class="comment">//字符串以&#x27;/n&#x27;结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">//将字母转化为数字</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        <span class="comment">//该节点不存在，创建节点,其值为下一个节点位置</span></span><br><span class="line">        p = son[p][u];  <span class="comment">//使“p指针”指向下一个节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;  <span class="comment">//结束时的标记，也是记录以此节点结束的字符串个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找</strong></p>
<ul>
<li>通过一直查下一个字符的父节点，直到遍历到最后一个字符</li>
<li>最后返回结点存储的次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//该节点不存在，即该字符串不存在</span></span><br><span class="line">        p = son[p][u]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];  <span class="comment">//返回字符串出现的次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完整</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Trie树快速存储字符集合和快速查询字符集合</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">//son[][]存储子节点的位置，分支最多26条；</span></span><br><span class="line"><span class="comment">//cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）</span></span><br><span class="line"><span class="comment">//idx表示当前要插入的节点是第几个,每创建一个节点值+1</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">//类似指针，指向当前节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">//将字母转化为数字</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;   <span class="comment">//该节点不存在，创建节点</span></span><br><span class="line">        p = son[p][u];  <span class="comment">//使“p指针”指向下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;  <span class="comment">//结束时的标记，也是记录以此节点结束的字符串个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//该节点不存在，即该字符串不存在</span></span><br><span class="line">        p = son[p][u]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];  <span class="comment">//返回字符串出现的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);<span class="comment">//*op为首地址</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="最大异或树"><a href="#最大异或树" class="headerlink" title="最大异或树"></a>最大异或树</h3><p><strong>异或</strong>：a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p>
<ul>
<li>相同为0，不同为1</li>
</ul>
<p>最大异或对</p>
<p>例子</p>
<blockquote>
<p>三个数1，2，3,三种情况；他们的二进制数进行比较</p>
<p>1^2=3    1^3=2   2^3=1</p>
<p>计算：1^3=2</p>
<p>0  1</p>
<p>1  1</p>
<p>——</p>
<p>1   0       所以返回值为2</p>
</blockquote>
<p>暴力</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			res=<span class="built_in">max</span>(res,a[i]^a[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071534347.jpg" alt=""></p>
<p><strong>思路</strong></p>
<ul>
<li>给定一个值，对应的进制数，与另一个数运算时；</li>
<li>从<strong>最高位</strong>开始看，只要保证最开始前面高位运算的<strong>结果为1</strong>，最后就能保证返回最大值</li>
<li>可以用trie树来存储所有的数字对应的二进制数(0或1)，一个数字（有32位，最高位为符号位），int 最高位是第31位（符号位），所以从考虑30~0位</li>
<li>查询返回值：通过在trie树判断，找与该位不同的数，使返回的值最大</li>
</ul>
<p>图形例子</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071556516.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,  M=<span class="number">31</span>*N;</span><br><span class="line"><span class="comment">//M代表一个数字串二进制可以到多长</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开始时,未初始化的s对应值都为0</span></span><br><span class="line">        <span class="type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];<span class="comment">//取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)，将地址赋给s</span></span><br><span class="line">        <span class="keyword">if</span> (!s) s = ++ idx;<span class="comment">//如果插入中发现没有该子节点,开出这条路,地址对应的son[p][u]不为0</span></span><br><span class="line">        p = s;<span class="comment">//指针指向下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最高位开始</span></span><br><span class="line">        <span class="type">int</span> s = x &gt;&gt; i &amp; <span class="number">1</span>;<span class="comment">//&gt;&gt;：向右移动</span></span><br><span class="line">        <span class="keyword">if</span> (son[p][!s])   <span class="comment">//如果当前层有对应的不相同的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//p指针就指到不同数的地址</span></span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;<span class="comment">//记录当前的最大值</span></span><br><span class="line">            p = son[p][!s];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> p = son[p][s]; <span class="comment">//当前层取相同的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res = <span class="built_in">max</span>(res, <span class="built_in">search</span>(a[i]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res += 1 &lt;&lt; i</span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071705415.jpg" alt=""></p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集维护额外信息</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个集合是否在同一个集合中</li>
</ol>
<h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a><a href="https://www.acwing.com/problem/content/838/">合并集合</a></h2><p><strong>基本思想</strong>：每个集合一棵树表示，树根的编号就是整个集合的编号；每个结点存储它的父节点,用p[x]表示x的结点</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205091315956.png" alt="image-20220509131556619"></p>
<ul>
<li>路径压缩：首先形成一个树，当执行完find()后，该树的所有结点都<strong>指向根结点</strong></li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205091310344.png" alt="image-20220509131043086"></p>
<p>递归含义</p>
<blockquote>
<p>递归的含义就相当于你问你爸爸你的祖先是谁，你爸爸也不知道，爸爸就去问爷爷，然后你的爷爷也不知道，爷爷就去问你的太爷爷，你的太爷爷年纪太大了，啥也不记得，就去问你的祖先</p>
<p>这个时候注意，你的祖先是知道自己是谁的，所以x ==p[x]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//返回x的祖宗节点+路径规划</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x]!=x) &#123;</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];<span class="comment">//返回祖宗结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) p[i]=i;  <span class="comment">//初始化根结点</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(*op==<span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//集合合并操作</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a><a href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></h2><ul>
<li>前面两个操作是跟合并操作一致的</li>
<li>第三个操作是记录一个集合中的通块的数量<ul>
<li>通过记录集合树的根结点来记录在一个集合中的通块数量</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//返回x的祖宗节点+路径规划</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x]!=x) &#123;</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];<span class="comment">//返回祖宗结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		p[i]=i;</span><br><span class="line">		cnt[i]=<span class="number">1</span>;    <span class="comment">//每个集合初始个数为1</span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		string op;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;C&quot;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			a=<span class="built_in">find</span>(a);</span><br><span class="line">			b=<span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span>(a!=b)&#123;    <span class="comment">//如果不在同一个集合中</span></span><br><span class="line">				p[a]=b;   <span class="comment">//合并到b集合中</span></span><br><span class="line">				cnt[b]+=cnt[a];    <span class="comment">//记录b集合通快的个数</span></span><br><span class="line">			&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;Q1&quot;</span>)&#123;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cin&gt;&gt;a;</span><br><span class="line">			cout&lt;&lt;cnt[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a><a href="https://www.acwing.com/problem/content/242/">食物链</a></h2><p><strong>核心思想</strong></p>
<ol>
<li>首先判断真话1X和Y是同类<ul>
<li>在同一个集合时，<strong>不满足</strong><code>d[x] - d[y]) % 3 ==0</code>说明是假话</li>
<li>在不同集合，不能证明两个不是同类，所以说他们是同类。将一个集合合并到另一个集合<code>p[px] = py</code>,px对应的集合合并到py。再记录px结点到py结点（根结点）的距离</li>
</ul>
</li>
<li>判断真话 x捕食y<ul>
<li>在同一个集合中时，不满足<code>d[x] - d[y] - 1) % 3 ==0</code>说明时假话</li>
<li>在不同集合中，将一个集合合并到另外一个集合中。同时记录px到py结点距离</li>
</ul>
</li>
</ol>
<p><strong>三个物种关系</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151636872.png" alt=""></p>
<p>2.集合合并</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151658138.png" alt=""></p>
<p><strong>被吃关系合并</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151700887.png" alt=""></p>
<p><strong>d[i]含义</strong></p>
<ol>
<li>d[i]的正确理解，应是第 i 个节点到其父节点距离，而不是像有些同学所讲的，到根节点的距离！！这点大家一定要搞清楚，之所以有这样的误会，是因为find()函数进行了路径压缩，当查询某个节点 i 时，如果 <strong>i 的父节点不为根节点的话，就会进行递归调用</strong>，将 i 节点沿途路径上所有节点均指向父节点，此时的 <strong>d[i] 存放</strong>的是 i 到父节点，也就是<strong>根节点的距离。</strong></li>
<li>d[x]始终代表到父节点的距离，只不过在find之后x的父节点直接变成了祖宗，所以逻辑上成了到祖宗的距离</li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151309395.jpg" alt=""></p>
<p><strong>find()函数</strong></p>
<ul>
<li>.p[x]至根节点之间的节点全部进行路径压缩</li>
<li>p[x]至根节点之间的节点k，其d[k]已经变成节点k到根节点的距离，不再是只到父节点的距离；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//压缩路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);<span class="comment">//循环调用返回根节点</span></span><br><span class="line">        d[x] += d[p[x]];<span class="comment">// x到根节点的距离 = x到父节点的距离 + 父节点到父节点的距离</span></span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>距离关系</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205152021445.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当动物x和动物y的距离%3等于1时,说明x捕食y</span></span><br><span class="line"><span class="comment">//当动物x和动物y的距离%3等于2时,说明y捕食x 也可以说y是x的天敌</span></span><br><span class="line"><span class="comment">//当动物x和动物y的距离%3等于0时,说明x和y是同类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//压缩路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>)  <span class="comment">//真话 x和y是同类</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span> !=<span class="number">0</span>) res ++ ;<span class="comment">//在同一个集合中,不是同类时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)<span class="comment">//不在同一个集合则不能证明不是同类则默认该说法正确,将其合并</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;<span class="comment">//合并到一个集合</span></span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                    <span class="comment">/*因为合并x和y所在集合多出了一段长度</span></span><br><span class="line"><span class="comment">                    这块长度是find(x)到find(y)的距离</span></span><br><span class="line"><span class="comment">                    所以求多出来的这块部分的长度</span></span><br><span class="line"><span class="comment">                    当x和y是同类时,有这样的特性</span></span><br><span class="line"><span class="comment">                    (d[x]+d[find[x]]-d[y])%3==0</span></span><br><span class="line"><span class="comment">                    这里的d[x]是还未合并时,x到find[x]的距离</span></span><br><span class="line"><span class="comment">                    ∴d[find[x]]=d[y]-d[x]</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//真话 x捕食y</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  当x和y在一个集合中时,由题目可知,x捕食y</span></span><br><span class="line"><span class="comment">                  此时有 </span></span><br><span class="line"><span class="comment">                  x到根节点的距离-y到根节点的距离=1+3k k为任意</span></span><br><span class="line"><span class="comment">                  实数</span></span><br><span class="line"><span class="comment">                  ∴当(len[x]-len[y]-1-3k)%3 ==0 时可确认</span></span><br><span class="line"><span class="comment">                  x捕食y</span></span><br><span class="line"><span class="comment">                  反之当(len[x]-len[y]-1-3k)%3 !=0 </span></span><br><span class="line"><span class="comment">                  x不可能捕食y</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span> !=<span class="number">0</span>) res ++ ;<span class="comment">//在同一个集合,不是捕食关系时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)<span class="comment">//不在同一个集合时，将之合并</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    设find(x)到find(y)的距离为d([find(x)])</span></span><br><span class="line"><span class="comment">                    此时有d[x]+d([find(x)])-d[y]=3k+1</span></span><br><span class="line"><span class="comment">                    ∴d[find(x)]=-d[x]+d[y]+1+3k</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a><a href="https://blog.csdn.net/u010452388/article/details/81283998?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165268377916782248514520%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165268377916782248514520&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81283998-null-null.142^v9^control,157^v4^control&amp;utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F&amp;spm=1018.2226.3001.4187">堆</a></h1><p><strong>二叉树：</strong>二叉树(Binary Tree)是每个<strong>结点</strong>最多有<strong>两个子树</strong>的有序树</p>
<p>满二叉树：一棵深度为k且有2^k^ -1个结点的二叉树称为满二叉树。</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161616387.png" alt="image-20220516161637244"></p>
<p>完全二叉树：除了最后一层结点，上面所有结点都是非空的；最后一层结点是从左到右依次排列的</p>
<p><img src="C:/Users/win10/AppData/Roaming/Typora/typora-user-images/image-20220516161919953.png" alt="image-20220516161919953"></p>
<p><strong>堆：</strong>是一个<a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a>；堆的结构可以分为<a href="https://so.csdn.net/so/search?q=大根堆&amp;spm=1001.2101.3001.7020">大根堆</a>和小根堆</p>
<p><strong>小根堆与大根堆</strong>：每个结点的<strong>值</strong>都<strong>大于其左孩子和右孩子</strong>结点的值，称之为大根堆；每个结点的<strong>值</strong>都小于其左孩子和右孩子结点<strong>的值，称之为</strong>小根堆。</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161623312.png" alt=""></p>
<p><strong>存储形式</strong>：映射成一维数组存储</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161628374.png" alt=""></p>
<p>还有一个基本概念：查找数组中某个数的父结点和左右孩子结点，比如已知索引为<strong>i</strong>的数，那么</p>
<p>注意根节点下标从0开始</p>
<p>1.父结点索引：(<em>i</em>-1)/2（这里计算机中的除以2，省略掉小数）</p>
<p>2.左孩子索引：2<em>*i</em>+1</p>
<p>3.右孩子索引：2<em>*i</em>+2</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><a href="https://www.acwing.com/problem/content/840/">堆排序</a></h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161645364.png" alt="image-20220516164534251"></p>
<p>注意根结点是从下标为1开始</p>
<p><strong>两个操作</strong>————<strong>针对小根堆</strong></p>
<ul>
<li><p><strong>down(x)</strong>：往下调整，就是从某个结点一直往下对比操作，三个结点对比，小的在父节点，大的在子节点。直到交换到不能交换为止（大的值往下沉）</p>
<blockquote>
<p>​       20      →父节点                   down操作后              12           </p>
<p>12         8    →左孩子和右孩子  </p>
<p>​                    down操作后       </p>
<p>​          12                 最终结果→             8</p>
<p>  20           8                                    20           12</p>
</blockquote>
</li>
<li><p><strong>up(x)</strong>: 往上调整，就是从某个结点一直上对比操作，三个结点对比，小的在父节点，大的在子节点。（小的值往上压）</p>
</li>
</ul>
<p><strong>手写一个堆操作</strong></p>
<p>size:相当于heap最后一个元素下标，size—:减少一个元素</p>
<ol>
<li>插入一个数 ：<code>heap[++size]=x;up(size);</code>相当于在末尾插入一个元素</li>
<li>求集合中的最小值 ： <code>heap[1]</code></li>
<li>删除最小值： <code>heap[1]=heap[size] ; size--; down(1)</code></li>
<li>删除任意一个元素：  <code>heap[k]=heap[size];size--;down(k);up(k)</code>：相当最后一个元素操作</li>
<li>修改任意一个元素 ： <code>heap[k]=x;down(k);up(k)</code></li>
</ol>
<p><strong>时间复杂度</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205171512399.jpg" alt=""></p>
<p><strong>代码</strong></p>
<p><strong>根结点从1开始</strong>；下标为x的左儿子下标为<strong>2x</strong>,右儿子为<strong>2x+1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;<span class="comment">//t存储三个结点中存在的最小的结点的下标，初始化为当前结点u</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">// 左子节点存在并且小于当前结点，更新t的下标</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//判断右儿子是否较小</span></span><br><span class="line">    <span class="keyword">if</span> (u != t) <span class="comment">//交换位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    cnt = n;<span class="comment">//cnt为数组元素个数</span></span><br><span class="line">    <span class="comment">//把堆初始化成小根堆，从二叉树的倒数第二行开始，把数字大的下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);<span class="comment">//输出堆顶最小值</span></span><br><span class="line">        <span class="comment">//删除最小值</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt -- ];<span class="comment">// 将堆最后一个数放到堆顶，cnt--使得在逻辑上删除这个数</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h2><p><strong>实现上述5个操作</strong></p>
<p>size:相当于heap最后一个元素下标，size—:减少一个元素</p>
<ol>
<li>插入一个数 ：<code>heap[++size]=x;up(size);</code>相当于在末尾插入一个元素</li>
<li>求集合中的最小值 ： <code>heap[1]</code></li>
<li>删除最小值： <code>heap[1]=heap[size] ; size--; down(1)</code></li>
<li>删除任意一个元素：  <code>heap[k]=heap[size];size--;down(k);up(k)</code>：相当最后一个元素操作</li>
<li>修改任意一个元素 ： <code>heap[k]=x;down(k);up(k)</code></li>
</ol>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a><strong>思想</strong></h3><ol>
<li>题目要对第i个插入的数字进行操作，所以不能直接的用堆排序直接交换，要记录元素x是第几个插入的和在堆的位置。所以要用下面两个数组记录</li>
<li><strong>查找元素</strong>时需要知道它在当前<strong>堆中的位置</strong>在哪里，才好进行 down 或 up，所以<strong>需要hp数组</strong>（<strong>第几个插入的数字 对应 目前堆里的位置</strong>），但是单纯swap交换数字，不会改变位置指针，所以需要<strong>ph数组来</strong>用作位置指针(目前<strong>堆里的位置 对应 第几个插入的数字</strong>）</li>
<li>一个堆结点的位置信息：存储数字x，该x是第k个插入，第k个插入对应的位置</li>
</ol>
<p><code>hp[]</code> 和<code>ph[]</code>是互逆的俩个指针，创建这俩个指针用于维护k和idx的映射关系，为任意删除和插入操作做铺垫，如果不删和插入除特定的点 就无需创建</p>
<p>交换前</p>
<blockquote>
<p>a，b为在堆中的具体位置</p>
<p>hp[堆里的位置]=第k个插入</p>
<p>ph[第k个插入]=堆里的位置</p>
<p>hp[a]=k          ph[k]=a                h[a]=4</p>
<p>hp[b]=k+1     ph[k+1]=b            h[b]=3</p>
</blockquote>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205171534237.png" alt=""></p>
<p>交换后</p>
<blockquote>
<p>hp[a]=k+1        ph[k]=b                    h[a]=3</p>
<p>hp[b]=k             ph[k+1]=a               h[a]=4    </p>
</blockquote>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205171534299.png" alt=""></p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt;</span><br><span class="line"><span class="comment">//cnt记录堆元素个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//交换操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将下标为u的结点往上调整  O(log n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span>&gt;<span class="number">0</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])<span class="comment">//up操作中只需要判断up儿子与根的大小就可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//m记录第几个插入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="comment">//strcmp(),对比字符串,完全相同返回0</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))<span class="comment">//相当对尾结点插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            m ++ ;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))<span class="comment">//删除最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))<span class="comment">//删除第k个插入的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);<span class="comment">//相当将第k个结点移到最后一个节点</span></span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//修改第k个结点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>时间复杂度：O(1)——直接查找</p>
<p>本质：<strong>本质是通过映射来压缩存储空间，<a href="https://editor.csdn.net/md/?articleId=114260724">离散化</a>就是一种特殊的哈希表，它特殊在需要数据有序，然后进行对分映射。我们这里的哈希表更加广义和一般，不需要有序</strong></p>
<p><strong>存储结构</strong></p>
<ul>
<li>开放寻址法：就是判断坑位是否为空，为空就复制，不为空就找下一个<ul>
<li>简单地讲，也就是说，一间厕所，来了一个顾客就蹲其对应的位置，如果又来一个顾客，把厕所单间门拉开，一看里面有位童鞋正在用劲，那么怎么办？很自然的，拉另一个单间的门，看看有人不，有的话就继续找坑。当然了，一般来说，这个顾客不会按顺序一个一个地拉厕所门，而是会去拉他认为有可能没有被占用的单间的门，这可以通过闻味道，听声音来辨别，这就是寻址查找算法。</li>
</ul>
</li>
<li>拉链法：利用链表处理冲突。输入x，将x进行mod映射为k，然后h[k]作为链表的头指针，然后就是链表头插法操作：e[idx] = x, ne[idx] = h[k], h[k] = idx ++;这样就把<strong>新元素像拉链一样挂在了h数组</strong>的下面了。寻找也是同理先求x的映射k，然后从h[k]开始链表的遍历<ul>
<li>跟邻接单链表类似</li>
<li>取的模为x，就在h[x]开一个链表存储数，h[x]相当于头结点</li>
</ul>
</li>
</ul>
<p><strong>字符串哈希方式</strong></p>
<p><strong>作用</strong>：将一系列大的数映射到一个范围较小的数组中（离散法是特殊的哈希方式）</p>
<h2 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h2><p><strong>哈希表核心</strong></p>
<ol>
<li><p>哈希函数：常用取模函数，常用比范围大的最小质数进行取模,减小冲突的概率</p>
<blockquote>
<p>构建哈希函数： 除留取余法</p>
<p>p与操作次数有关,也就是大于操作次数的最小质数</p>
<p>f(x) = x mod p 将x映射到 0到p-1 之间的数。</p>
<p>其中：<strong>p要取成一个质数</strong>，而且要离2的整次幂尽可能远。</p>
</blockquote>
</li>
<li><p>解决冲突</p>
<ul>
<li>拉链法： 数组+单链表</li>
<li>开放寻址法： 数组大小通常是数据范围两到三倍</li>
</ul>
</li>
</ol>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p><code>const int N = 200003</code>;</p>
<blockquote>
<p>开放寻址操作过程中会出现冲突的情况，一般会开成两倍的空间，减少数据的冲突</p>
<p>如果使用%来计算索引， 把哈希表的长度设计为素数（质数）可以大大减小哈希冲突<br>比如<br>10%8 = 2      10%7 = 3<br>20%8 = 4      20%7 = 6<br>30%8 = 6      30%7 = 2<br>40%8 = 0      40%7 = 5<br>50%8 = 2      50%7 = 1<br>60%8 = 4      60%7 = 4<br>70%8 = 6      70%7 = 0</p>
<p>这就是为什么要找第一个比空间大的质数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// N为大于2e5最小质数,</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;<span class="comment">//开发寻找，会出现冲突的情况，一般会开成两倍的空间, 同时去下一个质数;null:这是一个大于10^9的数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="comment">//冲突情况:当前位置不为空，并且不为x</span></span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123; </span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="comment">//末尾，从头开始</span></span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);<span class="comment">//0x3f在数组占位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[<span class="built_in">find</span>(x)] = x;<span class="comment">//找到符合条件位置并插入</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//查询</span></span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;<span class="comment">// 大于1e5的最小质数,用于作为哈希函数</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;<span class="comment">// h[N]为拉链法的数组 e[N]为链表值 ne[N]为链表next值</span></span><br><span class="line"><span class="comment">//单链表插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;<span class="comment">// 哈希函数, +N是避免取模运算出现负数</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    <span class="comment">//头结点插入,头结点有很多个</span></span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//memset函数，将数组的每一个元素初始化为-1</span></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串哈希表"><a href="#字符串哈希表" class="headerlink" title="字符串哈希表"></a>字符串哈希表</h2><p><a href="https://www.acwing.com/solution/content/97009/">字符串前缀哈希法</a></p>
<p><strong>核心思想</strong></p>
<ul>
<li><p>就是把一段字符串映射成一个数字，通过查询数字来判断，数字相等，则字符串等价</p>
<blockquote>
<p>注：该方法不存在冲突，因为一一映射不存在冲突</p>
</blockquote>
</li>
<li><p>根据经验，将字符串映射为 P = 131/13331 进制数字, 且用尽可能大的 <code>unsigned long long</code> 类型来存储变量可以尽可能地减少冲突，这是本问题的核心思想</p>
</li>
</ul>
<p><strong>注意点</strong>：</p>
<ul>
<li>由于数字 0 和数字 000 是相等的，所以如果某个字符被映射到了 0，如 <code>′a′→0′a′→0</code>。则 <code>′aaa′→0′aaa′→0</code>, 则 ‘a’ 和 ‘aaa’ 被认为是相等的。</li>
<li>所以不要将字符映射为 0</li>
</ul>
<p><strong>映射方法</strong>：</p>
<ul>
<li>注意到不能将字符映射位 0 的前提下，映射方法可以随意定制</li>
<li>为方便起见，映射方法一般为：字符 →→ 该字符的 ASCII 码</li>
</ul>
<p><strong>核心性质</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205182029320.png" alt="image-20220518202914558"></p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;<span class="comment">//由于前缀值的值会很大 所以应该将数组中的数据定义为ULL型;如果溢出了相当取模</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">//P为权重</span></span><br><span class="line"><span class="comment">//131为经验值 即P=131或13331时 哈希冲突的可能性最小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"><span class="comment">//h[]存放字符串的前缀值</span></span><br><span class="line"><span class="comment">//p[]存放各个位数的相应权值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 最开始的权值必须赋值为1 否则接下来就会出错</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];<span class="comment">//根据性质 1 挨个计算 h[i]</span></span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;<span class="comment">// 用 p 数组存储 p 的幂, p[i] 表示 p 的 i 次幂</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-STL介绍"><a href="#C-STL介绍" class="headerlink" title="C++ STL介绍"></a>C++ STL介绍</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()  返回第一个元素/返回最后一个元素</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()   在vector添加/删除一个元素 </span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()  返回一个当前vector容器中起始元素/末尾元素的迭代器</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line">	<span class="built_in">begin</span>()与<span class="built_in">front</span>()区别：</span><br><span class="line">    <span class="built_in">begin</span>():返回一个当前vector容器中起始元素的迭代器</span><br><span class="line">    <span class="built_in">front</span>():返回当前vector容器中起始元素的引用</span><br><span class="line">    </span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()   判断是否为空</span><br><span class="line">    <span class="built_in">clear</span>()   将字符串的内容清空，让源字符串成为一个空字符串（长度为<span class="number">0</span>个字符）</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()    判断大小</span><br><span class="line">    <span class="built_in">empty</span>()    判断为空</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing基础算法</category>
      </categories>
      <tags>
        <tag>acwing</tag>
      </tags>
  </entry>
  <entry>
    <title>1.c++入门基础</title>
    <url>/blot.github.io/2022/05/01/%E4%B8%80%E3%80%81C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h1><h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p>
<ul>
<li><strong>对象 ——</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>
<li><strong>类 ——-</strong> 类可以定义为描述对象行为/状态的模板/蓝图。</li>
<li><strong>方法 ——-</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>
<li><strong>即时变量 ——-</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  <span class="comment">//头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>using namespace std;</strong> 告诉编译器使用 std 命名空间</li>
<li>cout类似c语言输出printf</li>
</ul>
<h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​    Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271812654.png" alt="1541383178746"></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271812259.png" alt="1541384366413"></p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271812755.png" alt="1541383817248"></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271812616.png" alt="1541384140042"></p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271813233.png" alt="1541384818688"></p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code> <ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，==对该段代码做整体说明==</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code><ul>
<li>==通常在文件上方定义==，表示一个常量</li>
</ul>
</li>
</ol>
<ol>
<li><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code><ul>
<li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
</tr>
</tbody>
</table>
</div>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h3 id="1-7cout输出"><a href="#1-7cout输出" class="headerlink" title="1.7cout输出"></a>1.7cout输出</h3><ul>
<li>类似C语言的输出</li>
<li><strong>&lt;&lt;</strong>:后面加上内容，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;内容&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;内容1&quot;</span>&lt;&lt;<span class="string">&quot;内容2&quot;</span>;<span class="comment">//可以一直多&lt;&lt;个输出</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;内容&quot;</span>&lt;&lt;endl;<span class="comment">//endl类似换行符</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a;<span class="comment">//后面也可以加变量</span></span><br></pre></td></tr></table></figure>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th>取值范围</th>
<th><strong>占用空间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>short(短整型)</td>
<td>(-2^15 ~ 2^15-1)</td>
<td>2字节</td>
</tr>
<tr>
<td>int(整型)</td>
<td>(-2^31 ~ 2^31-1)</td>
<td>4字节</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>(-2^31 ~ 2^31-1)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>(-2^63 ~ 2^63-1)</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以==统计数据类型所占内存大小==</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>整型结论</strong>：short &lt; int &lt;= long &lt;= long long</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于表示小数</p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度float </li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line">	<span class="type">float</span> f3 = <span class="number">3e-2</span>;<span class="comment">//3 * 0.1 ^ 2</span></span><br><span class="line">	<span class="type">float</span> f4 = <span class="number">3e-2</span><span class="number">-1</span>;  <span class="comment">// 3 * 0.1 ^ 2  - 1</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f4 = &quot;</span> &lt;&lt; f4 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只<strong>占用1个字节</strong>。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;char类型字节为&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">98</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASCII码表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
</div>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p>
<p>现阶段我们常用的转义字符有：<code>\n  \\  \t</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\\\\</strong></td>
<td><strong>代表一个反斜线字符”\”</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>\’</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>\”</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0~9，a~f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hah&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li><p><strong>C++风格字符串</strong>：  <strong>string  变量名 = “字符串值”</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string a;</span><br><span class="line">	cin&gt;&gt;a;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include\<string>==</p>
</blockquote>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  —- 真（本质是1）</li>
<li>false —- 假（本质是0）</li>
</ul>
<p><strong>bool类型占==1个字节==大小</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p>
<p>算术运算符包括以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr>
<td>—</td>
<td>前置递减</td>
<td>a=2; b=—a;</td>
<td>a=1; b=1;</td>
</tr>
<tr>
<td>—</td>
<td>后置递减</td>
<td>a=2; b=a—;</td>
<td>a=1; b=2;</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>前置：先加1后赋值</strong></li>
<li><strong>后置：先赋值后加一</strong></li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;------&quot;</span>&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
<p>跟C语言类似</p>
</blockquote>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;<span class="comment">//取余数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1;</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值（<strong>1或者0</strong>）</p>
<p>比较运算符有以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>></td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>>=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。</p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>或</td>
<td>a \</td>
<td>\</td>
<td>b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例1：</strong>逻辑非</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：逻辑与运算符总结： 同真为真，其余为假</p>
</blockquote>
<ul>
<li><strong>同真为真，其余为假</strong></li>
</ul>
<p><strong>示例3：</strong>逻辑或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑或运算符总结： 同假为假，其余为真</strong></p>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li><p>单行格式if语句</p>
</li>
<li><p>多行格式if语句</p>
</li>
<li><p>多条件的if语句</p>
</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271647194.png" alt=""></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol>
<li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271650581.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271651867.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202271652375.jpg" alt="三只小猪"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> A,B,C;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入A,B,C猪的体重&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B&gt;&gt;C;</span><br><span class="line">	<span class="keyword">if</span>(A&gt;B)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A&gt;C)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A猪最重&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C猪最重&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(B&gt;C)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B猪最重&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C猪最重&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code>while(循环条件)&#123; 循环语句 &#125;</code></p>
<p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281242709.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<p><strong>while循环练习案例：</strong>猜数字</p>
<p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281241381.jpg" alt="猜数字"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> <span class="comment">//包含time那个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// unsigned seed;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num,guess;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	guess=<span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">	cout&lt;&lt;guess&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;请输入数字:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;num;</span><br><span class="line">	<span class="keyword">while</span> (num!=guess)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(guess&gt;num)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;猜小了,请重新输入数字:&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(guess&lt;num)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;猜大了,请重新输入数字:&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;猜对了,guess=&quot;</span>&lt;&lt;guess&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281649900.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 = 153</p>
<p>请利用do…while语句，求出所有3位数中的水仙花数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">100</span>,sum;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		a=num/<span class="number">100</span>;<span class="comment">//最高位</span></span><br><span class="line">		b=num%<span class="number">100</span>/<span class="number">10</span>;<span class="comment">//第二位</span></span><br><span class="line">		c=num%<span class="number">10</span>;<span class="comment">//个位</span></span><br><span class="line">		sum=a*a*a+b*b*b+c*c*c;</span><br><span class="line">		<span class="keyword">if</span>(sum==num)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">1000</span>);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code>for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281703410.png" alt="1541673704101"></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
<p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p><strong>练习案例：敲桌子</strong></p>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281703538.gif" alt="timg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a=i/<span class="number">10</span>;</span><br><span class="line">		b=i%<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">7</span> || b==<span class="number">7</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;敲桌子&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281709061.png" alt="1541676003486"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习案例：</strong>乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281710914.jpg" alt="0006018857256120_b"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">			cout&lt;&lt;j&lt;&lt;<span class="string">&quot;×&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;==&quot;</span>&lt;&lt;i*j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出选择结构或者循环结构</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是<strong>跳出当前的循环语句</strong></li>
<li>出现在嵌套循环中，<strong>跳出最近的内层循环语句</strong></li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在循环语句中，<strong>跳过本次循环中余下尚未执行的语句</strong>，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line">	FLAG:</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个数据元素都是相同的数据类型</p>
<p><strong>特点2：</strong>数组是由<strong>连续的内存位置</strong>组成的</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281813834.png" alt="1541748375356"></p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li>
<li>数组定义后，整型数组为数值0</li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">300</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">250</span>&#125;;</span><br><span class="line">	<span class="type">int</span> temp=arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp&lt;arr[i])&#123;</span><br><span class="line">			temp=arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;最重的猪是&quot;</span>&lt;&lt;temp&lt;&lt;<span class="string">&quot;斤&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">300</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">250</span>&#125;;</span><br><span class="line">	<span class="type">int</span> arr1[<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span> temp=arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		arr1[i]=arr[<span class="number">4</span>-i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;逆序后：&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		cout&lt;&lt;arr1[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281825083.png" alt="1541905327273"></p>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202281827704.png" alt="1541905559138"></p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code>数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入和输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> q[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) cin&gt;&gt;q[i];<span class="comment">//等价输入字符串，一维包含字符串数组，二维对应字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) cout&lt;&lt;q[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组<strong>占用的内存空间大小</strong></p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody>
</table>
</div>
<p><strong>参考答案：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型 </p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句 </p>
<p>5、return 表达式</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code>函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，如果形参发生，并不会影响实参</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件  </li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
<p>总结2：利用指针可以记录地址</p>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：所有指针类型在32位操作系统下是<strong>4个字节</strong></p>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   —- 常量指针</li>
<li>const修饰常量   —- 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">	cout&lt;&lt;*p1&lt;&lt;endl;</span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	cout&lt;&lt;*p1&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>技巧</strong>：看<strong>const右侧紧跟着的是指针还是常量</strong>, 是指针就是常量指针，是常量就是指针常量</p>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;值传递&quot;</span>&lt;&lt;endl&lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;地址传递&quot;</span>&lt;&lt;endl&lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>  *arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户<strong>自定义的数据类型</strong>，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
<p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code>struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t1.stu.age = <span class="number">18</span>;</span><br><span class="line">	t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// stu-&gt;age = 10; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p>
<blockquote>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Student</span> sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">	string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.线性表</title>
    <url>/blot.github.io/2022/06/04/%E4%B8%80%EF%BC%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h2><p><strong>注意</strong></p>
<ol>
<li>王道讲课中—SqList &amp;L的意思是传入结构体的地址，</li>
<li>而实际要用以下代码来传参——SqList *L</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;   <span class="comment">//·将所有数据元素设置为默认初始值0,如果没有这一步，内存中会有遗留的“脏数据”</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.Length=<span class="number">0</span>;        <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">                       <span class="comment">//在内存里分配存储顺序表L的空间</span></span><br><span class="line">                       <span class="comment">//包括MaxSize*sizeof(ElemType)和存储length的空间</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><p><strong>malloc函数</strong></p>
<ul>
<li>因为malloc返回的是不确定类型的指针</li>
<li>malloc() 在堆区分配一块指定大小的内存空间，用来存放数据,分配失败则返回NULL</li>
<li><code>L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)</code> 其中<code>(ElemType*)</code>可强制转换数据类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>( <span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">100</span> );<span class="comment">//返回开辟成功内存块的首地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;          <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;       <span class="comment">//最大容量</span></span><br><span class="line">    <span class="type">int</span> length;       <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;              <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *L)</span>&#123;</span><br><span class="line">    <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    L-&gt;MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SqList *L,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=L-&gt;data;   <span class="comment">//地址赋值</span></span><br><span class="line"></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L-&gt;MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i]=p[i];                 <span class="comment">//将旧数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;MaxSize=L-&gt;MaxSize+len;           <span class="comment">//数组最大长度</span></span><br><span class="line">    <span class="built_in">free</span>(p);                           <span class="comment">//释放原来的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(&amp;L);<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="comment">//以下代码对比</span></span><br><span class="line">    IncreaseSize(&amp;L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c-引用"><a href="#c-引用" class="headerlink" title="c++引用"></a>c++引用</h3><h4 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h4><p><strong>作用： </strong>给变量起别名</p>
<p><strong>语法：</strong> <strong>数据类型 &amp;别名 = 原名</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h4><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h4><p><strong>作用：</strong>函数传参时，可以利用引用的技术让<strong>形参修饰实参</strong></p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;值传递&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;地址传递&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;引用传递&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>示意</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——在L的位序i处插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span>&#123;   <span class="comment">//c++引用</span></span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length&gt;MaxSize) <span class="comment">//当前存储空间已满，不能插入  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--)&#123;    <span class="comment">//将第i个元素及其之后的元素后移,从最后一个元素开始</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>]=e;  <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;      <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    ListInsert(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图片动画"><a href="#图片动画" class="headerlink" title="图片动画"></a>图片动画</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192208359.gif" alt=""></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>示意</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">LisDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span>&#123; <span class="comment">// e用引用型参数 </span></span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>]                 <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)&#123;    <span class="comment">//将第i个后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;      <span class="comment">//长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">-1</span>;        <span class="comment">//用变量e把删除的元素“带回来”</span></span><br><span class="line">    <span class="keyword">if</span>(LisDelete(L,<span class="number">3</span>,e))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已删除第三个元素，删除元素值=%d\n&quot;</span>,e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位序i不合法，删除失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图片动画-1"><a href="#图片动画-1" class="headerlink" title="图片动画"></a>图片动画</h3><ul>
<li>删除7</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192218881.gif" alt=""></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><p>静态分配按位查找示意</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="comment">// ElemType *data;  //用动态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                     <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="comment">// ...判断i的值是否合法</span></span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];      <span class="comment">//注意是i-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><p>动态分配示意</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemTyp *data;  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L.length i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)  </span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;     <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;               <span class="comment">//推出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="顺序表做题思路"><a href="#顺序表做题思路" class="headerlink" title="顺序表做题思路"></a>顺序表做题思路</h2><ol>
<li>一般要在开头考虑是否为空表，一般用bool类型命令函数</li>
<li>数据类型用<code>ElemType</code>表示</li>
</ol>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="单链表定义"><a href="#单链表定义" class="headerlink" title="单链表定义"></a>单链表定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            <span class="comment">//定义单链表节点类型  LNode:结点</span></span><br><span class="line">    ElemType data;       <span class="comment">//每个结点存放一个数据元素 data:数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针指向下一个结点 next:指针域</span></span><br><span class="line">    <span class="comment">//struct LNode *next LNode指的是标签名</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Nea</span>&#123;</span>          </span><br><span class="line">    ElemType data;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Nea</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LNode* p = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))<span class="comment">//增加一个新的结点：在内存中申请一个结点所需的空间，并用指针p指向这个结点</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202131622506.png" alt="image-20220213162258317"></p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//上下代码等价</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>           </span><br><span class="line">    ElemType data;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span> <span class="comment">//重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要表示一个单链表时，只需声明一个<strong>头指针L</strong>，<strong>指向</strong>单链表的第一个结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *L;    <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是结点</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">LinkList L;  <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是链表</span></span><br><span class="line"><span class="comment">//注意：LNode *等价于LinkList </span></span><br></pre></td></tr></table></figure>
<h3 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//头指针指向的结点——分配一个头结点（不存储数据）;malloc返回的是指针首地址</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)          <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;       <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//L-&gt;next表示当前指针的下一个指针</span></span><br></pre></td></tr></table></figure>
<h3 id="不带头节点"><a href="#不带头节点" class="headerlink" title="不带头节点"></a>不带头节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;  <span class="comment">//注意用引用 &amp;</span></span><br><span class="line">    L = <span class="literal">NULL</span>; <span class="comment">//空表，暂时还没有任何结点；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带头结点与不带头节点区别</p>
<ol>
<li>不带头结点：写代码麻烦！对第一个数据节点和后续数据节点的处理需要用不同的代码逻辑，对空表和非空表的处理也需要用不同的代码逻辑; <strong>头指针指向的结点用于存放实际数据;</strong></li>
<li>带头结点：<strong>头指针指向的头结点不存放实际数据,头结点指向的下一个结点才存放实际数据;</strong></li>
</ol>
<h2 id="基本操作方法"><a href="#基本操作方法" class="headerlink" title="基本操作方法"></a>基本操作方法</h2><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><h4 id="带头结点-1"><a href="#带头结点-1" class="headerlink" title="带头结点"></a>带头结点</h4><p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后；其中头结点可以看作第0个结点，故i=1时也适用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//在第i个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="comment">//判断i的合法性, i是位序号(从1开始)</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法,i&gt;lengh</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;                   </span><br><span class="line">    s-&gt;next = p-&gt;next;              <span class="comment">//s的下一个指针指向p的下一个指针</span></span><br><span class="line">    p-&gt;next = s;                 <span class="comment">//将结点s连到p后,后两步千万不能交换顺序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="图片动画-2"><a href="#图片动画-2" class="headerlink" title="图片动画"></a>图片动画</h5><ul>
<li>a1为头结点</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192218457.gif" alt=""></p>
<h4 id="不带头节点-1"><a href="#不带头节点-1" class="headerlink" title="不带头节点"></a>不带头节点</h4><p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后; 因为不带头结点，所以不存在“第0个”结点，因此！<strong>i=1 时，需要特殊处理——插入(删除)第1个元素时，需要更改头指针L;</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入到第1个位置时的操作有所不同！</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(size of(LNode));</span><br><span class="line">        s-&gt;data =e;</span><br><span class="line">        s-&gt;next =L;</span><br><span class="line">        L=s;          <span class="comment">//头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i&gt;1的情况与带头结点一样！唯一区别是j的初始值为1</span></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="指定结点的后插操作"><a href="#指定结点的后插操作" class="headerlink" title="指定结点的后插操作"></a>指定结点的后插操作</h4><ul>
<li><p><code>InsertNextNode(LNode *p, ElemType e)</code>: 给定一个结点p，在其之后插入元素e; 根据单链表的链接指针只能往后查找，故给定一个结点p，那么p之后的结点我们都可知，但是p结点之前的结点无法得知;</p>
</li>
<li><p>相当封装好的插入函数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">//某些情况下分配失败，比如内存不足</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;          <span class="comment">//用结点s保存数据元素e </span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          <span class="comment">//将结点s连到p之后</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;                         <span class="comment">//平均时间复杂度 = O(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有了后插操作，那么在第i个位置上插入指定元素e的代码可以改成：</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    </span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> InsertNextNode(p, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="指定结点的前插操作"><a href="#指定结点的前插操作" class="headerlink" title="指定结点的前插操作"></a>指定结点的前插操作</h4><ol>
<li>如何找到p结点的前驱节点？<ul>
<li>传入头指针L！就可以知道整个链表的信息了！</li>
<li>InsertPriorNode(LinkList L, LNode *p, ElemType e)：循环查找p的前驱q，再对q进行后插操作，时间复杂度为O(n);</li>
</ul>
</li>
</ol>
<p>Q: 那如果不传入头指针L呢？</p>
<p><strong>不传入头指针L的代码实现</strong>:创建节点后，交换数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, ElenType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>) <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点来了！</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;       <span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data; <span class="comment">//将p中元素复制到s</span></span><br><span class="line">    p-&gt;data = e;       <span class="comment">//p中元素覆盖为e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>；</span><br><span class="line">&#125;  <span class="comment">//时间复杂度为O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="图片动画-3"><a href="#图片动画-3" class="headerlink" title="图片动画"></a>图片动画</h5><ul>
<li>相当于创建一个数据，然后交换插入数据位置，改变其后指向指针</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192219223.gif" alt=""></p>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h4 id="带头结点-2"><a href="#带头结点-2" class="headerlink" title="带头结点"></a>带头结点</h4><p><code>ListDelete(&amp;L, i, &amp;e)</code>: 删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值;<strong>头结点</strong>视为“<strong>第0个</strong>”结点；</p>
<p>思路：找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点；</p>
<p>先找到第i-1个结点p</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)            <span class="comment">//i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;         <span class="comment">//令q指向被删除的结点</span></span><br><span class="line">    e = q-&gt;data;                <span class="comment">//用e返回被删除元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;          <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q)                     <span class="comment">//释放结点的存储空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192238689.gif" alt=""></p>
<p>时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最坏，平均时间复杂度：O(n)</span><br><span class="line">最好时间复杂度：删除第一个结点 O(1)</span><br></pre></td></tr></table></figure>
<h4 id="指定结点删除"><a href="#指定结点删除" class="headerlink" title="指定结点删除"></a>指定结点删除</h4><p>方法</p>
<ul>
<li>删除指定p结点，将p的后继结点的数据传给p（交换数据）,然后p的next指向p后继结点的后继节点</li>
<li>实际上就是删除p的后继结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *q = p-&gt;next;      <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data; <span class="comment">//让p和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;       <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;                                                     </span><br><span class="line">&#125; <span class="comment">//时间复杂度 = O(1)</span></span><br><span class="line">                                        </span><br></pre></td></tr></table></figure>
<h5 id="图片动画-4"><a href="#图片动画-4" class="headerlink" title="图片动画"></a>图片动画</h5><ul>
<li>将结点p的后继数据给p,然后修改p的后继，释放原来p的后继                                                                                                               </li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082134193.gif" alt=""></p>
<p><strong>但是</strong> 如果p是最后一个结点，那么<code>p-&gt;next = q-&gt;next</code> and <code>p-&gt;data = p-&gt;next-&gt;data</code> 就会出错，只能从表头开始依次寻找o的前驱，时间复杂度为O(n); 这就是单链表的<strong>局限性</strong>——无法逆向检索。</p>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><h4 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h4><ul>
<li><code>GetElem(L, i):</code> 按位查找操作，获取表L中第i个位置的元素的值;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *p;               <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;                <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                  <span class="comment">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;  <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;               <span class="comment">//返回p指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h4><ul>
<li><code>LocateElem(L, e):</code>按值查找操作，在表L中查找具有给定关键字值的元素;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span>&#123;</span><br><span class="line">    LNode *P = L-&gt;next;    <span class="comment">//p指向第一个结点</span></span><br><span class="line">    <span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;           <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单链表的长度"><a href="#单链表的长度" class="headerlink" title="单链表的长度"></a>单链表的长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;       <span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h2><ul>
<li><strong>思路</strong>： 初始化一个单链表 -&gt; 每取一个数据元素，插入到表尾/表头</li>
<li><strong>核心</strong>：初始化操作，指定结点的后插操作</li>
</ul>
<h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="type">int</span> x;                                   <span class="comment">//设ElemType为整型int</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点(初始化空表)</span></span><br><span class="line">    LNode *s, *r = L;                        <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s                                <span class="comment">//r指针指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="图片动画-5"><a href="#图片动画-5" class="headerlink" title="图片动画"></a>图片动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204201234259.gif" alt=""></p>
<h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//初始为空链表,这步不能少！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999,链表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;                         <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="图片动画-6"><a href="#图片动画-6" class="headerlink" title="图片动画"></a>图片动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206061242973.gif" alt=""></p>
<p>在头结点后面插入新的数据</p>
<p><strong>PS: 只要是初始化单链表，都先将头指针指向NULL — <code>L-&gt;next = NULL</code>;</strong></p>
<h4 id="重要应用—链表逆置"><a href="#重要应用—链表逆置" class="headerlink" title="重要应用—链表逆置"></a>重要应用—链表逆置</h4><ul>
<li><a href="https://blog.csdn.net/qq_42322103/article/details/82668765">头插法图解</a></li>
<li><strong>算法思想</strong>：逆置链表初始为空，原表中结点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *<span class="title function_">Inverse</span><span class="params">(LNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *p, *q;</span><br><span class="line">	p = L-&gt;next;     <span class="comment">//p指针指向第一个结点</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指向NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q-&gt;next = L-&gt;next;  </span><br><span class="line">		L-&gt;next = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206071221996.gif" alt=""></p>
<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><p>结点描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure>
<h2 id="双链表初始化（带头结点）"><a href="#双链表初始化（带头结点）" class="headerlink" title="双链表初始化（带头结点）"></a>双链表初始化（带头结点）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(Dlinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));      <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                              <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;   <span class="comment">//头结点的prior指针永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    DLinklist L;         <span class="comment">// 定义指向头结点的指针L</span></span><br><span class="line">    InitDLinkList(L);    <span class="comment">//申请一片空间用于存放头结点，指针L指向这个头结点</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的next指针是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082159971.png" alt="image-20220608215936343"></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132140514.png" alt="image-20220213214025352"></p>
<p>与单链表中一样，<code>DLinklist</code> 强调链表， <code>DNode *</code>强调结点，二者本质上等价;</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><h3 id="后插"><a href="#后插" class="headerlink" title="后插"></a>后插</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; <span class="comment">//将结点 *s 插入到结点 *p之后</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>) <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)   <span class="comment">//p不是最后一个结点=p有后继结点,NULL不会指向p</span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="图片动画-7"><a href="#图片动画-7" class="headerlink" title="图片动画"></a>图片动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204201307984.gif" alt=""></p>
<h3 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h3><ul>
<li>思路：从头结点开始，找到某个位序的<strong>前驱结点</strong>，对该前驱结点执行后插操作；</li>
</ul>
<h3 id="前插"><a href="#前插" class="headerlink" title="前插"></a>前插</h3><ul>
<li>思路：找到给定结点的前驱结点，再对该前驱结点执行后插操作；</li>
</ul>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除p的后继结点q</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<p>如果要删除的结点q是最后一个结点，会出现错误，故增加条件判断以提高代码健壮性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="comment">//三种情况判断：1.p结点为空结点  2、p的没有后继结点  3.p的后继节点是否是最后一个结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeletNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q =p-&gt;next;            <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//p没有后继结点;</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)           <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        DeletNextDNode(L);  <span class="comment">//删除头结点的后继结点</span></span><br><span class="line">    <span class="built_in">free</span>(L); <span class="comment">//释放头结点</span></span><br><span class="line">    L=<span class="literal">NULL</span>;  <span class="comment">//头指针指向NULL</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图片动画-8"><a href="#图片动画-8" class="headerlink" title="图片动画"></a>图片动画</h3><ol>
<li>删除p结点的后继结点</li>
</ol>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204201315741.gif" alt=""></p>
<h2 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h2><h3 id="后项遍历"><a href="#后项遍历" class="headerlink" title="后项遍历"></a>后项遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前项遍历"><a href="#前项遍历" class="headerlink" title="前项遍历"></a>前项遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳过头结点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(p-&gt;prior!=NULL)&#123;</span><br><span class="line">    //对结点p做相应处理</span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 双链表不可随机存取，按位查找和按值查找操作都只能用遍历的方式实现，时间复杂度为<strong>O(n)</strong></p>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><ul>
<li><strong>最后一个结点的指针不是NULL,而是指向头结点</strong></li>
</ul>
<p>初始化</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082209463.png" alt="image-20220608220935407"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *Linklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)             <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;            <span class="comment">//头结点next指针指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L, LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132150443.png" alt=""></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol>
<li>单链表<ul>
<li>从<strong>一个结点出发只能找到该结点后续的各个结点</strong>；对链表的操作大多都在头部或者尾部；设立头指针，从头结点找到尾部的时间复杂度=O(n)，即对表尾进行操作需要O(n)的时间复杂度;</li>
</ul>
</li>
<li>循环单链表<ul>
<li>从一个结点出发，可以<strong>找到其他任何一个结点</strong>；设立尾指针，从尾部找到头部的时间复杂度为O(1)，即对表头和表尾进行操作都只需要O(1)的时间复杂度;</li>
</ul>
</li>
</ol>
<h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><ul>
<li><strong>表头结点的<code>prior</code>指向表尾结点，表尾结点的<code>next</code>指向头结点</strong></li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132151941.png" alt="image-20220213215101834"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>          </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));    <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    L-&gt;prior = L;          <span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;           <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化循环单链表</span></span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环双链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(DLinklist L, DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082210257.png" alt="image-20220608221014694"></p>
<h3 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h3><ul>
<li>对于循环双链表，操作 <code>p-&gt;next-&gt;prior = s</code> 不会出问题辣！因为就算p是最后一个结点，也不会出现空指针现象了(这个问题在双链表里会出现！)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h3><ul>
<li>和插入操作一样！<code>q-&gt;next-&gt;prior</code> 对于循环双链表不会出错了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p的后继结点q</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>用数组的方式实现的链表: 分配一整片连续的内存空间，各个结点集中安置，包括了——数据元素and下一个结点的数组下标(游标)</li>
<li>单链表：各个结点散落在内存中的各个角落，每个结点有指向下一个节点的指针(下一个结点在内存中的地址);</li>
</ul>
<p>注意</p>
<ul>
<li>其中数组下标为0的结点充当”头结点”</li>
<li>游标为-1表示已经到达表尾</li>
<li>若每个数据元素为4B，每个游标为4B，则每个结点共8B；假设起始地址为addr，则数据下标为2的存放地址为：addr+8*2</li>
<li>注意： 数组下标——物理顺序，位序——逻辑顺序；</li>
<li>优点：增、删操作不需要大量移动元素；</li>
<li>缺点：不能随机存取，只能从头结点开始依次往后查找，容量固定不变！</li>
</ul>
<p>定义代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用数组定义多个连续存放的结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//数组a作为静态链表, 每一个数组元素的类型都是struct Node</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价下面的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ELemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span> <span class="comment">//重命名struct Node，用SLinkList定义“一个长度为MaxSize的Node型数组;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PS: <code>SLinkList a</code> 强调a是静态链表；<code>struct Node a</code> 强调a是一个Node型数组；</p>
<h2 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h2><ul>
<li><p>初始化静态链表：把a[0]的next设为-1</p>
</li>
<li><p>查找某个位序（不是数组下标，位序是各个结点在逻辑上的顺序）的结点：从头结点出发挨个往后遍历结点，时间复杂度O=(n)</p>
</li>
</ul>
<ul>
<li>在位序为i上插入结点：① 找到一个空的结点，存入数据元素；② 从头结点出发找到位序为i-1的结点；③修改新结点的next；④ 修改i-1号结点的next；<ul>
<li>插入如下</li>
</ul>
</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132203523.png" alt="image-20220213220301417"></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204212316893.gif" alt=""></p>
<blockquote>
<p>Q：如何判断结点为空？</p>
<p>A：在初始化时，将空闲结点的next设置为某个特殊值，eg：-2；</p>
<p>删除某个结点：</p>
<p>① 从头结点出发找到前驱结点；</p>
<p>② 修改前驱节点的游标；</p>
<p>③ 被删除节点next设为-2；</p>
</blockquote>
<h1 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul>
<li>顺序表和链表都属于线性表，都是线性结构</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>1、顺序表：顺序存储</p>
<ul>
<li>优点：支持随机存取，存储密度高</li>
<li>缺点：大片连续空间分配不方便，改变容量不方便</li>
</ul>
<p>2、链表：链式存储</p>
<ul>
<li>优点：离散的小空间分配方便，改变容量方便</li>
<li>缺点：不可随机存取，存储密度低</li>
</ul>
<h2 id="基本操作-创"><a href="#基本操作-创" class="headerlink" title="基本操作 - 创"></a>基本操作 - 创</h2><h3 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h3><ol>
<li>需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源；</li>
<li>静态分配：静态数组，容量不可改变</li>
<li>动态分配：动态数组，容量可以改变，但是需要移动大量元素，时间代价高（<code>malloc(),free()</code>）</li>
</ol>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>只需要分配一个头结点或者只声明一个头指针</li>
</ul>
<h2 id="基本操作-销毁"><a href="#基本操作-销毁" class="headerlink" title="基本操作 - 销毁"></a>基本操作 - 销毁</h2><h3 id="顺序表-2"><a href="#顺序表-2" class="headerlink" title="顺序表"></a>顺序表</h3><ol>
<li><p>修改 Length = 0</p>
<ul>
<li>静态分配：静态数组——系统自动回收空间</li>
<li>动态分配：动态数组——需要手动free</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创</span></span><br><span class="line">L.data = (ELemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) *InitSize)</span><br><span class="line"><span class="comment">//销</span></span><br><span class="line"><span class="built_in">free</span>(L.data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//！malloc() 和 free() 必须成对出现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>链表</strong></p>
<ul>
<li>依次删除各个结点 <code>free()</code></li>
</ul>
</li>
</ol>
<h2 id="基本操作-增-删"><a href="#基本操作-增-删" class="headerlink" title="基本操作 - 增/删"></a>基本操作 - 增/删</h2><p><strong>顺序表</strong></p>
<ul>
<li>插入/删除元素要将后续元素后移/前移；时间复杂度=O(n)，时间开销主要来自于移动元素；</li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>插入/删除元素只需要修改指针；时间复杂度=O(n)，时间开销主要来自查找目标元素</li>
</ul>
<h2 id="基本操作-查"><a href="#基本操作-查" class="headerlink" title="基本操作 - 查"></a>基本操作 - 查</h2><ul>
<li><p>顺序表</p>
<ul>
<li><p>按位查找：O(1)</p>
</li>
<li><p>按值查找：O(n)，若表内元素有序，可在O($log_2{n}$)时间内找</p>
</li>
</ul>
</li>
<li><p>链表</p>
<ul>
<li>按位查找：O(n)</li>
<li>按值查找：O(n)</li>
</ul>
</li>
</ul>
<p><strong>开放式问题答题思路</strong></p>
<blockquote>
<p>Q: 请描述顺序表和链表的balabalabala…实现线性表时，用顺序表还是链表好？</p>
<p>A: 顺序表和链表的存储结构都是线性结构，都属于线性表；但是二者的存储结构不同，顺序表采用顺序存储…(特点，优缺点)；链表采用链式存储…(特点，优缺点)；由于采用不同的存储方式实现，因此基本操作的实现效率也不同；当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…；</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>3.树与二叉树</title>
    <url>/blot.github.io/2022/07/01/%E4%B8%89%E3%80%81%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ul>
<li>树是n个结点的有限集，空树:结点为0的树</li>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>非空树应满足<ul>
<li>有且只有一个特定的称为根的结点</li>
<li>当n&gt;1是，其余结点可以分为m个互不相交的有限集合，其中每个集合本身又是一棵树，并称为根的子树</li>
</ul>
</li>
<li>非空树特性<ul>
<li>有且只有一个根节点</li>
<li>没有后继的结点称为<strong>叶子结点</strong>（终端结点）</li>
<li>有后继的结点称为<strong>分支结点</strong>（非终端结点）</li>
<li>除了根节点外，任何结点都有且<strong>只有一个前驱</strong></li>
<li>每个结点可以有0个或多个后继</li>
</ul>
</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207012108033.png" alt="image-20220701210802760"></p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="结点之间的关系描述"><a href="#结点之间的关系描述" class="headerlink" title="结点之间的关系描述"></a>结点之间的关系描述</h4><ul>
<li>祖先结点：从根到该节点所经分支上的所有节点（该分支上的其他结点都是）</li>
<li>子孙结点：以某节点为根的子树中任一节点都称为该节点的子孙（该结点分支后面的所有结点）</li>
<li>父节点(双亲结点)：若一个节点含有子节点，则这个节点称为其子节点的父节点（结点的前驱）</li>
<li>子节点：一个节点含有的子树的根节点称为该节点的子节点</li>
<li>兄弟节点：具有<strong>相同父节点</strong>的节点互称为兄弟节点</li>
<li>堂兄弟结点：父节点在同一层的节点互为堂兄弟（就是父亲结点的兄弟结点的子节点），在同一层</li>
<li><strong>路径</strong>：只能从上往下</li>
<li><strong>路径长度</strong>：经过的边数</li>
<li>树的路径长度：从根结点到每个结点的路径长度之和</li>
</ul>
<h4 id="结点、树的属性描述"><a href="#结点、树的属性描述" class="headerlink" title="结点、树的属性描述"></a>结点、树的属性描述</h4><ul>
<li>结点的层次（深度）：从上往下数</li>
<li>结点的高度：从下往上数</li>
<li>树的高度：总共多少层</li>
<li><strong>结点的度</strong>：一个节点含有的<strong>子结点</strong>的个数称为该节点的度</li>
<li><strong>树的度</strong>：一棵树中，<strong>结点最大的度</strong>称为树的度</li>
<li>森林：m棵互不相交的树的集合</li>
<li>有序树：从逻辑上看，树中结点的各子树<strong>从左至右</strong>是<strong>有次序</strong>的，不能互换</li>
<li>无序树：从逻辑上看，树中结点的各子树<strong>从左至右</strong>是<strong>无次序</strong>的，可以互换</li>
</ul>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ol>
<li>树的结点总数 = 所有结点的度数之和 + 1</li>
<li>度为<code>m</code>的树、<code>m</code>叉数的区别</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>度为 <code>m</code> 的树</th>
<th><code>m</code> 叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>树的度：<code>m</code>为各结点的度的最大值</td>
<td><code>m</code>叉树：每个结点最多只能有 <code>m</code> 个孩子的树</td>
</tr>
<tr>
<td>任意结点的度 ≦ m</td>
<td>任意结点的度 ≦ m</td>
</tr>
<tr>
<td>至少有一个结点度 = m</td>
<td>允许所有结点的度 &lt; m</td>
</tr>
<tr>
<td>一定是非空树，至少有m+1个结点</td>
<td>可以是空树</td>
</tr>
<tr>
<td>第i层至多有 $m^{i-1}$个结点</td>
<td>第i层至多有 $m^{i-1}$个结点</td>
</tr>
<tr>
<td>高度为<code>h</code>、度为 <code>m</code> 的树<strong>至少</strong>有<code>h+m-1</code>个结点（允许一层只有一个结点）</td>
<td>高度为<code>h</code>的<code>m</code>叉树至多有$\frac{m^h-1}{m-1}$个结点</td>
</tr>
<tr>
<td></td>
<td>具有<code>n</code>个结点的<code>m</code>叉树，最小高度为$⌈ log_m(n(m-1)+1)⌉$</td>
</tr>
</tbody>
</table>
</div>
<p>⌈  ⌉：向上取整</p>
<p>已知不同度的结点个数，求叶子结点</p>
<ul>
<li>关键，先求出树的结点树，然后判断出不同度的结点个数，相减就是叶子结点</li>
<li>叶子结点的度为0</li>
</ul>
<p>结点度为$0,1,…,m$分别为$n_0,n_1,…n_m$</p>
<ul>
<li>总结点数=$n_0+n_1+…+n_m$</li>
<li>总分支数=$1n_1+2n_2…+mn_m$</li>
<li>总结点数=总分支数+1</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>二叉树是n个结点的有限集合</li>
<li>由一个根节点和两个互不相交的被称为根的<strong>左子树</strong>和<strong>右子树</strong>组成。左子树和右子树分别是一个二叉树</li>
<li>特点<ul>
<li>每个结点至多只有两棵子树</li>
<li>左右子树不能颠倒</li>
<li>二叉树是<strong>有序树</strong></li>
</ul>
</li>
</ul>
<h3 id="几种特殊的二叉树"><a href="#几种特殊的二叉树" class="headerlink" title="几种特殊的二叉树"></a>几种特殊的二叉树</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ul>
<li>一棵树高度为h，且含有 含有$2^h-1$个结点的二叉树，每层满结点</li>
<li>特点<ul>
<li>只有最后一层为叶子结点</li>
<li>不存在度为1的结点（要不度为0，要不度为2）</li>
<li>按层序从1开始编号，结点i的左孩子为<code>2i</code> ，右孩子为<code>2i+1</code>;结点i的父节点为<code>⌊i/2⌋</code> (如果有)。⌊⌋ :向下取整</li>
</ul>
</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022122956.png" alt="image-20220702212156606"></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ul>
<li>当且仅当器每个结点都与高度为h的满二叉树中编号为<code>1~n</code>的结点一一对应时，称为完全二叉树</li>
<li>特点<ul>
<li>只有最后两层可能有叶子节点</li>
<li>最多只有一个度为1的结点（只有左孩子没有右孩子）</li>
<li>按层序从1开始编号，结点i的左孩子为<code>2i</code> ，有孩子为<code>2i+1</code>;结点i的父节点为<code>⌊i/2⌋</code> (如果有)。⌊⌋ :向下取整</li>
<li><code>i&lt;=⌊n/2⌋</code>为分支结点，<code>i&gt;⌊n/2⌋</code>为叶子结点</li>
<li>n为奇数，每个分支结点都有左右孩子</li>
<li>n为偶数，编号为n/2的结点只有左孩子</li>
</ul>
</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022128470.png" alt="image-20220702212826288"></p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><ul>
<li>一棵二叉树有如下性质<ul>
<li><strong>左子树</strong>上的所有结点的关键字均<strong>小于根节点</strong>的关键字</li>
<li><strong>右子树</strong>上的所有结点的关键字<strong>均大于根节点</strong>的关键字</li>
<li>左子树和右子树分别是一棵二叉排序树</li>
</ul>
</li>
<li>该树可用于元素的排序、搜索</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022133497.png" alt="image-20220702213343598"></p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><ul>
<li>树上的任一结点的左子树和右子树的<strong>深度之差不超过1</strong></li>
<li>该树有更高的搜索效率</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022135724.png" alt="image-20220702213514829"></p>
<h3 id="二叉树常见性质"><a href="#二叉树常见性质" class="headerlink" title="二叉树常见性质"></a>二叉树常见性质</h3><ul>
<li>设非空二叉树中度为0，1，2的结点个数分别为$n_0,n_1,n_2$,则$n_0=n_2+1$</li>
<li>二叉树第ｉ层最多$2^{i-1}$个结点</li>
<li>高度为h的二叉树最多$2^h- 1$(满二叉树)</li>
</ul>
<h4 id="完全二叉树性质"><a href="#完全二叉树性质" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h4><ul>
<li>具有n个结点的完全二叉树的高度为$⌈log_2 (n+1)⌉$或者$⌊log_2 n⌋$+1<ul>
<li>通过高度为h-1和高度为h的结点判断</li>
</ul>
</li>
<li>设非空二叉树中度为0，1，2的结点个数分别为$n_0,n_1,n_2$<ul>
<li>完全二叉树中度为1的结点最多一个;$n_0+n_2$一定为奇数</li>
<li>若完全二叉树有2k个结点,则必有$n_1=1,n_0=k,n_2=k-1$</li>
<li>若完全二叉树有2k-1个结点,则必有$n_1=0,n_0=k,n_2=k-1$</li>
</ul>
</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;<span class="comment">//无存储信息设为true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>考点：</strong></p>
<ul>
<li><code>i</code>的左孩子：<code>2i</code></li>
<li><code>i</code>的右孩子：<code>2i + 1</code></li>
<li><code>i</code>的父节点：<code>⌊i/2⌋</code></li>
<li><code>i</code>所在的层次：<code>⌊log2n + 1⌋</code> or <code>⌈ log(2n+1)⌉</code></li>
</ul>
<p><strong>若完全二叉树中共有n个结点</strong>（非完全二叉树不能用）</p>
<ul>
<li>判断<code>i</code>是否有左孩子：<code>2i ≦ n</code></li>
<li>判断<code>i</code>是否有右孩子：<code>2i+1 ≦ n</code></li>
</ul>
<p><strong>最坏情况：</strong> <strong>高度为h且只有h个结点</strong>的单支树（所有结点只有右孩子），也至少需要$2^h-1$个存储单元；</p>
<p><strong>结论：</strong> 二叉树的顺序存储结构，<strong>只适合存储完全二叉树和满二叉树</strong></p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root -&gt; data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p -&gt; data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">p -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; lchild = p; <span class="comment">//作为根节点的左孩子</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207032054999.png" alt="image-20220703205422393"></p>
<ul>
<li>找到指定结点p的左/右孩子；</li>
<li>找到指定节点p的父结点: 只能从根结点开始遍历，也可以使用<strong>三叉链表</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>          <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<ul>
<li>n个结点的二叉链表共有n+1个空链域,(有n-1个变连接，共2n个指针)</li>
</ul>
<h2 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a><a href="https://blog.csdn.net/weixin_45525272/article/details/105837185">二叉树的遍历和线索二叉树</a></h2><p>遍历：按照某种次序把所有的结点访问一遍</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><strong>先序遍历</strong>：根左右</p>
<p><strong>中序遍历</strong>：左根右</p>
<p><strong>后续遍历</strong>：左右根</p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
</li>
</ul>
<p>小仙儿从树根开始绕着整棵树的外围转一圈，经过结点的顺序就是先序遍历的顺序</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071910649.gif" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将访问根节点，遍历左树和右树交换位置,就可以实现中序和后序遍历</span></span><br></pre></td></tr></table></figure>
<p>手算层次遍历</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207032058178.png" alt="image-20220703205803539"></p>
<p><strong>空间复杂度：</strong> O(h)</p>
<p>中序遍历和后序遍历与先序遍历类似</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul>
<li><p>顺序：左根右</p>
</li>
<li><p>中序遍历可以看成，二叉树每个节点，垂直方向投影下来（可以理解为每个节点从最左边开始垂直掉到地上），然后从左往右数，得出的结果便是中序遍历的结果</p>
</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071914581.gif" alt=""></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul>
<li>就是围着树的外围绕一圈，如果发现一剪刀就能剪下的葡萄（必须是一颗葡萄）（也就是葡萄要一个一个掉下来，不能一口气掉超过1个这样），就把它剪下来，组成的就是后序遍历了。</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071917460.gif" alt=""></p>
<p>程序遍历序列</p>
<ul>
<li>先序：第一次路过时访问</li>
<li>中序：第二次路过时访问</li>
<li>后序：第三次路过时访问</li>
</ul>
<h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4><p>层次遍历很好理解，就是从根节点开始，一层一层，从上到下，每层从左到右，依次写值就可以了</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071919769.png" alt=""></p>
<p>算法思想：</p>
<ul>
<li>初始化一个辅助队列</li>
<li>根节点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，依次将其左、右孩子插入队尾（如果有的话）</li>
<li>重复以上操作直至队列为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">   BiTNode * data;</span><br><span class="line">   <span class="keyword">typedef</span> LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   LinkNode *front, *rear;  </span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue (Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结论</strong>:若只给出一棵二叉树得前/中/后/层 序遍历序列中得一种，不能确定一棵二叉树</p>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p><strong>关键</strong>：找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点、</p>
<h4 id="先序序列-中序序列"><a href="#先序序列-中序序列" class="headerlink" title="先序序列 + 中序序列"></a><strong>先序序列 + 中序序列</strong></h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071931027.png" alt="image-20220707193144845"></p>
<p>先序序列的第一个元素一定是根节点</p>
<p>关键：<strong>该方法的核心就是用先序序列元素作即根节点分割中序序列</strong></p>
<p><strong>动图</strong></p>
<blockquote>
<p>先序：1  2  3  4  5  6  7 </p>
<p>中序：4  2  5  1  6  3  7 </p>
<pre><code>      1
    /   \
   2     3
  / \   / \ 
 4   5 6   7
</code></pre></blockquote>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071933398.gif" alt=""></p>
<h4 id="后序序列-中序序列"><a href="#后序序列-中序序列" class="headerlink" title="后序序列 + 中序序列"></a>后序序列 + 中序序列</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071938477.png" alt="image-20220707193808450"></p>
<p><strong>关键</strong>：</p>
<ol>
<li>先确定后序最后一个元素为根节点，</li>
<li>然后用后序序列元素即根节点分割中序序列，</li>
</ol>
<p><strong>动图</strong></p>
<blockquote>
<p>后序：E F A H C I G B D</p>
<p>中序：E A F D H C B G I</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     D</span><br><span class="line">   /   \</span><br><span class="line">  A      B</span><br><span class="line"> / \    / \ </span><br><span class="line">E   F  C   G</span><br><span class="line">       /    \ </span><br><span class="line">      H      I</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072042235.gif" alt=""></p>
<h4 id="层序序列-中序序列"><a href="#层序序列-中序序列" class="headerlink" title="层序序列 + 中序序列"></a>层序序列 + 中序序列</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072044019.png" alt="image-20220707204447135"></p>
<p><strong>动图</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072100311.gif" alt=""></p>
<p><strong>结论</strong>：前序，后序，层序序列的两两组合无法唯一确定一棵二叉树</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><ol>
<li>线索二叉树的概念与作用<ul>
<li>遍历二叉树是以一定规则将二叉树中的结点排列出个成一个线性组合</li>
<li>线索二叉树是为了加快查找结点前驱和后继的速度</li>
</ul>
</li>
<li>线索二叉树的存储结构</li>
</ol>
<ul>
<li>中序线索二叉树——线索指向中序前驱、中序后继</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tag == 0: 指针指向孩子</p>
<p>tag == 1: 指针是“线索”</p>
<p>*lchild：指向前驱结点（前驱线索）或者左孩子</p>
<p>*rchild：指向后继结点（后继线索）或者右孩子</p>
<p>结构：</p>
<p>二叉链表：<em>lchild , data  ,  </em>rchild</p>
<p>线索链表：<em>lchild , ltag , data , rtag , </em>rchild</p>
</blockquote>
<h3 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h3><p><strong>关键</strong>：画出图形，确定好各个结点的顺序，然后根据是否有孩子判断线索化</p>
<h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072124463.png" alt="image-20220707212418284"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);    <span class="comment">//中序遍历左子树</span></span><br><span class="line">        visit(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        InThread(T-&gt;rchild);    <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      InThread(T);            <span class="comment">//中序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125676.png" alt="image-20220707212513691"></p>
<p><em>注意【转圈】问题，当<code>ltag==0</code>时，才能对左子树先序线索化</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);</span><br><span class="line">      <span class="keyword">if</span>(T-&gt;ltag == <span class="number">0</span>)         <span class="comment">//lchild不是前驱线索</span></span><br><span class="line">         PreThread(T-&gt;lchild);</span><br><span class="line">      PreThread(T-&gt;rchild);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PreThread(T);            <span class="comment">//先序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125827.png" alt="image-20220707212547580"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      PostThread(T-&gt;lchild);</span><br><span class="line">      PostThread(T-&gt;rchild);</span><br><span class="line">      visit(T);                  <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PostThread(T);            <span class="comment">//后序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>线索二叉树中找前驱、后继</li>
</ol>
<ul>
<li><p>中序线索二叉树找中序后继：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 则 next = p的右子树中最左下结点;</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最左下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//右子树最左下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p!=<span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 = O(1)</p>
<ul>
<li><p>中序线索二叉树找中序前驱：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序前驱 <code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子, 则 next = p的左子树中最右下结点;</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最右下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;rchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//左子树最右下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//rtag==1，直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p!=<span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>先序线索二叉树找先序后继：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子（左孩子不知道）</p>
<blockquote>
<p>case1: 若p有左孩子 ——— 根 <strong>左</strong> 右 / 根 (<strong>根</strong> 左 右) 右</p>
<p>case2: 若p没有左孩子 ——— 根 <strong>右</strong> / 根 (<em>*根</em> *左 右)</p>
</blockquote>
</blockquote>
</li>
<li><p>先序线索二叉树找先序前驱：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序前驱<code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找p的先序前驱，（除非从头开始遍历/三叉链表</p>
<blockquote>
<p>case1: 如果能够找到p的父节点，且p是左孩子 —— p的父节点就是p的前驱；</p>
<p>case2: 如果能够找到p的父节点，且p是右孩子，且其左兄弟为空 —— p的父节点就是p的前驱；</p>
<p>case3: 如果能够找到p的父节点，且p是右孩子，且其左兄弟非空 —— p的前驱为左兄弟子树中最后一个被先序遍历到的结点（根节点出发，先往右，右没有往左，找到最下一层的结点）；</p>
<p>case4: p没有父节点，即p为根节点，则p没有先序前驱</p>
</blockquote>
</blockquote>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YjVVJjtQ-1623943811481)(先序线索二叉树找先序前驱.PNG)]</p>
</li>
<li><p>后序线索二叉树找后序前驱：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序前驱<code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子（不知道有没有右孩子）</p>
<blockquote>
<p>case1: 若p有右孩子 ——— 左 <strong>右</strong> 根 / 左 (左 右 <strong>根</strong>) 根</p>
<p>case2: 若p没有右孩子 ——— <strong>左</strong> 根 （左子树按后序遍历，最后一个结点，p的左孩子）</p>
</blockquote>
</blockquote>
</li>
<li><p>后序线索二叉树找后序后继：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序后继<code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非从头开始遍历/三叉链表</p>
<blockquote>
<p>case1: 如果能找到p的父节点，且p是右孩子 —— p的父节点即为其后继</p>
<p>case2: 如果能找到p的父节点，且p是左孩子，其右兄弟为空 —— p的父节点即为其后继</p>
<p>case3: 如果能找到p的父节点，且p是左孩子，其右兄弟非空 —— p的后继为其右兄弟子树中第一个被后序遍历的结点；</p>
<p>case4: p没有父节点，即p为根节点，则p没有后序后继；</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>中序线索二叉树</th>
<th>先序线索二叉树</th>
<th>后续线索二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>找前驱</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>找后继</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-4-树、森林"><a href="#5-4-树、森林" class="headerlink" title="5.4 树、森林"></a>5.4 树、森林</h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2.c++核心编程</title>
    <url>/blot.github.io/2022/05/02/%E4%B8%89%E3%80%81C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​    <strong>代码区：</strong></p>
<p>​        存放 CPU 执行的机器指令</p>
<p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​    <strong>全局区：</strong></p>
<p>​        全局变量和静态变量存放在此.</p>
<p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​        ==该区域的数据在程序结束后由操作系统释放==.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203011944044.png" alt="1545017602518"></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p>
<p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>堆区：</strong></p>
<p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​        在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​    C++中利用<strong>new</strong>操作符在堆区开辟数据</p>
<p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <strong>delete</strong></p>
<p>​    语法：<code>new 数据类型</code></p>
<p>​    利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用： </strong>给变量起别名</p>
<p><strong>语法：</strong> <strong>数据类型 &amp;别名 = 原名</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;值传递&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;地址传递&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;引用传递&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：**</strong>常量引用主要用来修饰形参**，防止误操作</p>
<p>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code>返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：<strong>封装、继承、多态</strong></p>
<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​    具有<strong>相同性质的对象</strong>，我们可以抽象称为<strong>类</strong>，人属于人类，车属于车类</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​    在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<p><img src="assets/1545533548532.png" alt="1545533548532"></p>
<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<p><img src="assets/1545533829184.png" alt="1545533829184"></p>
<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​    按参数分为： 有参构造和无参构造</p>
<p>​    按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​    括号法</p>
<p>​    显示法</p>
<p>​    隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li>
</ul>
<ul>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  ==friend==</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img src="assets/1544861202252.png" alt="1544861202252"></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="assets/clip_image002.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用工具查看：</p>
<p><img src="assets/1545881904150.png" alt="1545881904150"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<p><img src="assets/1545882158050.png" alt="1545882158050"></p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​    两个派生类继承同一个基类</p>
<p>​    又有某个类同时继承者两个派生类</p>
<p>​    这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<p><img src="assets/clip_image002.jpg" alt="IMG_256"></p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li><p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>
</li>
<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img src="assets/1545985945198.png" alt="1545985945198"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code>virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​    3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include <fstream\></p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>文件打开方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include <fstream\></p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件 </li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ==ios::binary==</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
]]></content>
      <tags>
        <tag>c++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2.搜索与图论</title>
    <url>/blot.github.io/2022/06/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>全称：<strong>深度优先搜索算法</strong></p>
<ol>
<li>dfs 最重要的是<strong>搜索顺序</strong>。用什么顺序遍历所有方案。</li>
<li>递归加回溯</li>
</ol>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>对于全排列问题，以 n = 3 为例，可以这样进行搜索</p>
<p><strong>dfs递归搜索树</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205191543338.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];<span class="comment">//保存序列</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//数字是否被用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i])&#123;   <span class="comment">//如果数字 i 没有被用过</span></span><br><span class="line">			path[u]=i;<span class="comment">//放入空位</span></span><br><span class="line">			st[i]=<span class="literal">true</span>;<span class="comment">//修改数字状态</span></span><br><span class="line">			<span class="built_in">dfs</span>(u+<span class="number">1</span>);<span class="comment">//填下一个位</span></span><br><span class="line">			st[i]=<span class="literal">false</span>;<span class="comment">//回溯，取出i</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>手动模拟</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205191545074.png" alt=""></p>
<h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n<a href="https://www.acwing.com/problem/content/845/">皇后问题</a></h2><h3 id="第一种搜索方法"><a href="#第一种搜索方法" class="headerlink" title="第一种搜索方法"></a>第一种搜索方法</h3><ul>
<li>每一行必定有一个皇后，对行进行深度遍历。</li>
<li>对于第 r 行的第 i 个位置，判断每个点是否可以放皇后，如果可以，则放皇后，然后处理 r + 1 行。直到 r = n，程序指行完毕</li>
</ul>
<p><strong>对角线下标问题</strong></p>
<ol>
<li>反对角线，<code>y=-x+c,c=x+y,c</code>这里代表截距</li>
<li>正对角线<code>y=x+c，c=y-x</code>,所以这里的c可能是负的，但作为数组下标，不能是负的，所以我们把正对角线加上一个偏移量，<code>c=y-x+n</code>是没影响的，因为截距最大是n，所以我加了n，也可以加比n大的任何数，x就是下面的h也就是行，y就是下面的l 也就是列</li>
<li>理解为<code>xoy</code>平面方程<code>y=kx+b</code>方程，截距问题</li>
</ol>
<p><strong>时间复杂度</strong>：O(n!)</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205211614109.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];<span class="comment">//存储棋盘</span></span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];<span class="comment">//点对应列和两个斜线是否有皇后，dg为对角线,udg为反对角线</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//u相当行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)<span class="comment">//放满了棋盘，输出棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最开始的循环：就是第一行第一个放皇后，递归输出所有满足条件的方案，回溯，下一步就是在第一行第二列放皇后，递归输出所有方案....</span></span><br><span class="line">    <span class="comment">//u行,i列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])<span class="comment">//不冲突，放皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;<span class="comment">//对应的 列， 斜线 状态改变</span></span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);<span class="comment">//递归下一行</span></span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;<span class="comment">//恢复现场</span></span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化,全是空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);<span class="comment">//从第0行递归</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种搜索方法"><a href="#第二种搜索方法" class="headerlink" title="第二种搜索方法"></a>第二种搜索方法</h3><ol>
<li>（DFS按每个元素枚举）时间复杂度O(2的n^2^)</li>
<li>时间复杂度分析：每个位置都有两种情况，总共有 n^2^ 个位置</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同搜索顺序 时间复杂度不同  所以搜索顺序很重要！</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N * <span class="number">2</span>], udg[N * <span class="number">2</span>];<span class="comment">// 因为是一个个搜索，所以加了row</span></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// s表示已经放上去的皇后个数,x行，n列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理超出边界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == n) y = <span class="number">0</span>, x ++ ;<span class="comment">//枚举下一行</span></span><br><span class="line">    <span class="keyword">if</span> (x == n)<span class="comment">// x==n说明已经枚举完n^2个位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)<span class="comment">// s==n说明成功放上去了n个皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两种情况一直递归</span></span><br><span class="line">    <span class="comment">// 分支1：不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分支2：放皇后</span></span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化,全是空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing基础算法</category>
      </categories>
      <tags>
        <tag>acwing</tag>
      </tags>
  </entry>
  <entry>
    <title>2.栈与队列</title>
    <url>/blot.github.io/2022/06/04/%E4%BA%8C%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><ol>
<li>栈是特殊的线性表：只允许在一端进行插入或删除操作， 其逻辑结构与普通线性表相同；</li>
</ol>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul>
<li>栈顶：允许进行插入和删除的一端 （最上面的为栈顶元素）；</li>
<li>栈底：不允许进行插入和删除的一端 （最下面的为栈底元素）；</li>
<li>空栈：不含任何元素的空表；</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202182015068.png" alt="image-20220218201522912"></p>
<ul>
<li>特点：<strong>后进先出</strong>（后进栈的元素先出栈）；</li>
<li>缺点：栈的大小不可变，解决方法——共享栈；</li>
</ul>
<h2 id="栈的基本运算"><a href="#栈的基本运算" class="headerlink" title="栈的基本运算"></a>栈的基本运算</h2><p><strong>“创&amp;销”</strong></p>
<ul>
<li>InitStack(&amp;S) 初始化栈：构造一个空栈S，分配内存空间；</li>
<li>DestroyStack(&amp;S) 销毁栈：销毁并释放栈S所占用的内存空间；</li>
</ul>
<p><strong>“增&amp;删”</strong></p>
<ul>
<li>Push(&amp;S, x) 进栈：若栈S未满，则将x加入使其成为新栈顶；</li>
<li>Pop(&amp;S, &amp;x) 出栈：若栈S非空，则弹出（删除）栈顶元素，并用x返回；、</li>
</ul>
<h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><p>例：进栈顺序为：a -&gt; b -&gt; c -&gt; d -&gt; e</p>
<blockquote>
<p>合法的出栈顺序：e d c b a / b e d c a (出栈 和进栈交替进行) / … </p>
</blockquote>
<h1 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h1><h2 id="顺序栈定义"><a href="#顺序栈定义" class="headerlink" title="顺序栈定义"></a>顺序栈定义</h2><p><strong>栈底</strong>：数组下标为0</p>
<p><strong>栈顶</strong>：top指向的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">                     <span class="comment">//连续的存储空间大小为 MaxSize*sizeof(ElemType)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="顺序栈基本操作"><a href="#顺序栈基本操作" class="headerlink" title="顺序栈基本操作"></a>顺序栈基本操作</h2><p>初始化栈顶元素<code>S.top=-1</code>;栈顶元素<code>S.data[S.top]</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)      <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>                 <span class="comment">//栈不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>)        <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top + <span class="number">1</span>;    <span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    S.data[++S.top] = x;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];       <span class="comment">//先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;       <span class="comment">//栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x = S.data[S.top--];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是逻辑上的删除，数据依然残留在内存里</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];      <span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进栈：每执行一次，top指向的数组下标增1</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202182021684.jpg" alt=""></p>
<p>入栈与出栈</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204212054383.gif" alt=""></p>
<p><strong>PS: 也可以初始化时定义 S.top = 0 ：top指针指向下一个可以插入元素的位置(栈顶元素的后一个位置)；</strong></p>
<ol>
<li>判空：<code>if(S.top == 0)</code></li>
<li>进栈使用：<code>S.data[S.top++] = x</code>;</li>
<li>出栈使用：<code>x = S.data[--S.top]</code>;</li>
<li>判断栈满：<code>s.top == MaxSize</code></li>
</ol>
<h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p>两个顺序栈共享一个一位数组空间，为了更有效的利用存储空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;        <span class="comment">//一个栈顶指针指向-1</span></span><br><span class="line">    S.top1 = MaxSize;   <span class="comment">//一个栈顶指针指向MaxSize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>栈满条件：<code>top1-top0==1</code></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202182024683.png" alt="image-20220218202435535"></p>
<h1 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>进栈和出栈都只能在栈顶一端进行(<strong>链头作为栈顶</strong>)</li>
<li>链表的头部作为栈顶，意味着：<ul>
<li>在实现数据”<strong>入栈</strong>“操作时，需要将数据从链表的<strong>头部插入</strong>；</li>
<li>在实现数据”<strong>出栈</strong>“操作时，需要<strong>删除</strong>链表头部的<strong>首元节点</strong>；</li>
</ul>
</li>
</ul>
<p>因此，链栈实际上就是一个只能<strong>采用头插法插入或删除数据</strong>的链表;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125;*LiStack;                      <span class="comment">//栈类型的定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>初始化</li>
<li>进栈</li>
<li>出栈</li>
<li>获取栈顶元素</li>
<li>判空、判满</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202211945218.png" alt="image-20220221194535365"></p>
<h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;L)</span>&#123;   <span class="comment">//L为头指针</span></span><br><span class="line">    L = new Linknode; <span class="comment">//new是c++中动态分配空间，和malloc功能类似</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 进栈(：链栈基本上不会出现栈满的情况)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = new Linknode;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    Linknode s;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="comment">//栈空不能出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s = L-&gt;next;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L-&gt;next = L-&gt;next-&gt;next;</span><br><span class="line">    delete(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a><a href="https://blog.csdn.net/nyist_zxp/article/details/80810742">new</a></h4><ul>
<li><p>new开辟的动态空间要用delete释放，new出来的空间给的是首地址</p>
</li>
<li><p>new/delete是关键字，效率高于malloc和free。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><p><strong>链栈推荐不带头结点</strong>：链栈不需要在头部附加头结点，因为<strong>栈都是在头部进行操作的</strong>， 如果加了头结点，等于要对头结点之后的结点进行操作，反而使算法更复杂，所以只要有链表的头指针就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        teturn <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = new Linknode;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = L;</span><br><span class="line">    L = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    Linknode s; </span><br><span class="line">    <span class="keyword">if</span>(L = <span class="literal">NULL</span>)     <span class="comment">//栈空不出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s = L;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    delete(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="出栈的合法顺序判断"><a href="#出栈的合法顺序判断" class="headerlink" title="出栈的合法顺序判断"></a>出栈的合法顺序判断</h2><p><strong>方法：</strong>一路向左致死方休</p>
<ul>
<li>从最小数(字母)起，下一个只能在其左侧，直到边上才停止，然后删除继续（记为一组）；删完则合法</li>
<li>最小数指的是从开始入栈的顺序开始数</li>
</ul>
<blockquote>
<p>入栈：abcde</p>
<p>判断：ecbda</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>开始</th>
<th>删除</th>
<th>剩余</th>
</tr>
</thead>
<tbody>
<tr>
<td>ecbda</td>
<td>cba</td>
<td>ed</td>
</tr>
<tr>
<td>ed</td>
<td>e</td>
<td>d</td>
</tr>
<tr>
<td>d</td>
<td>d</td>
<td>无——合法</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>入栈:abc</p>
<p>出栈：cab   不合法——a不在最左边且b在a的右边</p>
<p>出栈：abc   合法——最小在最左边，直接删除合法</p>
<p>如最小在最左边，直接删除</p>
<p>若最小不在最左边，且下一个在其右边则不合法</p>
</blockquote>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="队列定义"><a href="#队列定义" class="headerlink" title="队列定义"></a>队列定义</h3><ul>
<li>队列是操作受限的<strong>线性表</strong>，只允许在一端进行插入 (入队)，另一端进行删除 (出队)</li>
<li>操作特性：<strong>先进先出 FIFO</strong></li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>空队列：不含任何元素的空表</li>
</ul>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><h3 id="“创-amp-销”"><a href="#“创-amp-销”" class="headerlink" title="“创&amp;销”"></a><strong>“创&amp;销”</strong></h3><ul>
<li><code>InitQueue(&amp;Q)</code>: 初始化队列，构造一个空列表Q</li>
<li><code>DestroyQueue(&amp;Q)</code>: 销毁队列，并释放队列Q所占用的内存空间</li>
</ul>
<h3 id="“增-amp-删”"><a href="#“增-amp-删”" class="headerlink" title="“增&amp;删”"></a><strong>“增&amp;删”</strong></h3><ul>
<li><code>EnQueue(&amp;Q, x)</code>: 入队，若队列Q未满，将x加入，使之成为新的队尾</li>
<li><code>DeQueue(&amp;Q, &amp;x)</code>: 出队，若队列Q非空，删除队头元素，并用x返回</li>
</ul>
<h3 id="“查-amp-其他”"><a href="#“查-amp-其他”" class="headerlink" title="“查&amp;其他”"></a><strong>“查&amp;其他”</strong></h3><ul>
<li><code>GetHead(Q,&amp;x)</code>: 读队头元素，若队列Q非空，则将队头元素赋值给x</li>
<li><code>QueueEmpty(Q)</code>: 判队列空，若队列Q为空，则返回true</li>
</ul>
<h2 id="队列的顺序结构"><a href="#队列的顺序结构" class="headerlink" title="队列的顺序结构"></a>队列的顺序结构</h2><ul>
<li>头指针：指向队头元素；</li>
<li>队尾指针：指向队尾元素的后一个位置（下一个应该插入的位置）</li>
</ul>
<h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列的顺序存储类型</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">                              <span class="comment">//连续的存储空间，大小为——MaxSize*sizeof(ElemType)</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> test&#123;</span><br><span class="line">    SqQueue Q;                <span class="comment">//声明一个队列</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue <span class="number">0</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)    <span class="comment">//判空条件后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><ol>
<li>循环队列</li>
</ol>
<blockquote>
<p><strong>Q:</strong> 能否用 <code>Q.rear == MaxSize</code> 作为队列满的条件？</p>
<p><strong>A:</strong>不能！会有假溢出, 所以需要用 <strong>模运算</strong> 将存储空间 {0,1,2,…,MaxSize} 在逻辑上变成“环状”——<strong>循环队列！</strong></p>
<p>a%b == a除以b的余数</p>
<p>初始：Q.front = Q.rear = 0;</p>
<p>队首指针进1：Q.front = (Q.front + 1) % MaxSize</p>
<p>队尾指针进1：Q.rear = (Q.rear + 1) % MaxSize —— 队尾指针后移，当移到最后一个后，下次移动会到第一个位置</p>
<p>队列长度：(Q.rear + MaxSize - Q.front) % MaxSize</p>
</blockquote>
<h3 id="循环队列判满"><a href="#循环队列判满" class="headerlink" title="循环队列判满"></a>循环队列判满</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><ul>
<li>牺牲一个单元来区分队空和队满</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202211952764.png" alt="image-20220221195244607"></p>
<p>本方案的<strong>尾指针指向最后一个元素的下一个位置</strong></p>
<h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><ul>
<li>只能从队尾插入</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front)        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;                      <span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;         <span class="comment">//队尾指针加1取模</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队尾插入操作</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131543334.gif" alt=""></p>
<h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><ul>
<li>只能让队头元素出列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队，删除一个队头元素，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针后移动</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131540395.gif" alt=""></p>
<h5 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：队列的尾指针是指向最后一个元素还是最后一个元素的下一个位置</p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><ul>
<li>不牺牲存储空间，设置size</li>
<li>size记录队列长度</li>
<li>队满条件<code>size=MaxSize</code></li>
<li>队空条件<code>size=0</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">//队列当前长度</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p> 不牺牲存储空间，设置tag</p>
<ul>
<li>定义一个变量 <code>tag</code>，<code>tag = 0</code> —最近进行的是删除操作；<code>tag = 1</code> —最近进行的是插入操作；</li>
<li>每次删除操作成功时，都令<code>tag = 0</code>；只有删除操作，才可能导致队空；</li>
<li>每次插入操作成功时，都令<code>tag = 1</code>；只有插入操作，才可能导致队满；</li>
</ul>
<ol>
<li>队满条件：<code>Q.front == Q.rear &amp;&amp; tag == 1</code></li>
<li>队空条件：<code>Q.front == Q.rear &amp;&amp; tag == 0</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> tag;               <span class="comment">//最近进行的是删除or插入</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>其他出题方式</p>
<ul>
<li>注意front和rear指向的位置，特别是rear,可能指向队尾元素，也可能指向队尾的下一个元素</li>
</ul>
<h2 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h2><p><strong>队列的链式存储</strong>:注意是两个定义一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个存放数据和next指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>      <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="comment">//一个存放队列的队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>               <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<h3 id="基本操作—带头结点"><a href="#基本操作—带头结点" class="headerlink" title="基本操作—带头结点"></a>基本操作—带头结点</h3><h4 id="初始化判空"><a href="#初始化判空" class="headerlink" title="初始化判空"></a>初始化判空</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131607595.png" alt="image-20220613160707170"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)     <span class="comment">//也可用 Q.front -&gt; next == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><ul>
<li>入队：在链表尾部插入</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//s作为最后一个结点，指针域指向NULL</span></span><br><span class="line">    Q.rear-&gt;next = s;   <span class="comment">//新结点插入到当前的rear之后</span></span><br><span class="line">    Q.rear = s;         <span class="comment">//表尾指针指向新的表尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131621527.gif" alt=""></p>
<h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><ul>
<li>对头结点指向的结点进行删除操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                    <span class="comment">//空队</span></span><br><span class="line">    </span><br><span class="line">    LinkNode *p = Q.front-&gt;next;         <span class="comment">//p指针指向即将删除的结点 (头结点所指向的结点)</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;             <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)                      <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear = Q.front;                <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                             <span class="comment">//释放结点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131633545.gif" alt=""></p>
<ul>
<li>队列满的条件</li>
</ul>
<p>顺序存储：预分配存储空间</p>
<p>链式存储：一般不会队满，除非内存不足</p>
<ul>
<li>计算链队长度 (遍历链队)</li>
</ul>
<p>设置一个<code>int length</code> 记录链式队列长度</p>
<h3 id="基本操作—不带头结点"><a href="#基本操作—不带头结点" class="headerlink" title="基本操作—不带头结点"></a>基本操作—不带头结点</h3><h4 id="初始化判空-1"><a href="#初始化判空-1" class="headerlink" title="初始化判空"></a>初始化判空</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)     <span class="comment">//也可以用 Q.rear == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="入队-2"><a href="#入队-2" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素入队时需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front = <span class="literal">NULL</span>)&#123;            <span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;               <span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;           <span class="comment">//新结点插入到rear结点之后</span></span><br><span class="line">        Q.rear = s;                 <span class="comment">//修改rear指针指向新的表尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131648902.gif" alt=""></p>
<h4 id="出队-2"><a href="#出队-2" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队————不带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front; <span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x=p-&gt;data;           <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front=p-&gt;next;     <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)&#123;       <span class="comment">//如果是最后一个结点出队</span></span><br><span class="line">        Q.front=<span class="literal">NULL</span>;    <span class="comment">//front指向NULL</span></span><br><span class="line">        Q.rear=<span class="literal">NULL</span>;     <span class="comment">//rear指向NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);            <span class="comment">//释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131653536.gif" alt=""></p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>双端队列允许从<strong>两端插入</strong>、<strong>两端删除</strong>的线性表；</li>
<li>如果只使用其中一端的插入、删除操作，则等同于栈；</li>
<li>输入受限的双端队列：允许<strong>一端插入</strong>，<strong>两端删除</strong>的线性表；</li>
<li>输出受限的双端队列：允许<strong>两端插入</strong>，<strong>一端删除</strong>的线性表；</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202261600690.png" alt="image-20220226160014797"></p>
<h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><blockquote>
<p><strong>例</strong>: 数据元素输入序列为 <code>1,2,3,4</code>，判断 4!=24 个输出序列的合法性</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈</th>
<th>输入受限的双端队列</th>
<th>输出受限的双端队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>14个合法(卡特兰数)</td>
<td>验证在栈中不合法的序列</td>
<td>验证在栈中不合法的序列</td>
</tr>
<tr>
<td></td>
<td>只有 4213 和 4231 不合法</td>
<td>只有 4132 和 4231 不合法</td>
</tr>
</tbody>
</table>
</div>
<p><strong>PS: 栈中合法的序列，双端队列中一定也合法</strong></p>
<h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="栈在括号匹配的应用"><a href="#栈在括号匹配的应用" class="headerlink" title="栈在括号匹配的应用"></a>栈在括号匹配的应用</h2><p>用栈实现括号匹配</p>
<ul>
<li><code>((()))</code> 最后出现的左括号最先被匹配 (栈的特性—LIFO)——<strong>后进先出</strong></li>
<li>遇到左括号就入栈;</li>
<li>遇到右括号，就“消耗”一个左括号 (出栈);</li>
</ul>
<p>匹配失败情况：</p>
<ul>
<li>扫描到右括号且栈空，则该右括号单身;</li>
<li>扫描完所有括号后，栈非空，则该左括号单身;</li>
<li>左右括号不匹配;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">InitStack(SqStack &amp;S)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, <span class="type">char</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶元素出栈，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, <span class="type">char</span> &amp;x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack S;      <span class="comment">//声明</span></span><br><span class="line">    InitStack(S);   <span class="comment">//初始化栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            Push(S, str[i]);       <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))      <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//匹配失败</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> topElem;          <span class="comment">//存储栈顶元素</span></span><br><span class="line">            Pop(S, topElem);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断左右括号是否匹配</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StackEmpty(S);                <span class="comment">//栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>需要界限符，运算符在两个操作数中间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① a + b</span><br><span class="line">② a + b - c</span><br><span class="line">③ a + b - c*d</span><br><span class="line">④ ((15 ÷ (7-(1+1)))×3)-(2+(1+1))</span><br><span class="line">⑤ A + B × (C - D) - E ÷ F</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="中缀表达式的计算-用栈实现"><a href="#中缀表达式的计算-用栈实现" class="headerlink" title="中缀表达式的计算(用栈实现)"></a><strong>中缀表达式的计算(用栈实现)</strong></h4><p>两个算法的结合： 中缀转后缀 + 后缀表达式的求值</p>
<ul>
<li>初始化两个栈，<strong>操作数栈</strong> 和<strong>运算符栈</strong></li>
<li>若扫描到操作数，压人操作数栈</li>
<li>若扫描到运算符或界限符，则按照“<strong>中缀转后缀</strong>”相同的逻辑压入运算符栈 (期间也会弹出运算符，<strong>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈项元素并执行相应运算，运算结果再压回操作数栈</strong>)</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206212129740.gif" alt=""></p>
<h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① a b +</span><br><span class="line">② ab+ c - / a bc- +</span><br><span class="line">③ ab+ cd* -</span><br><span class="line">④ 15 7 1 1 + - ÷ 3 × 2 1 1 + + -</span><br><span class="line">⑤ A B C D - × + E F ÷ - (机算结果)</span><br><span class="line">  A B C D - × E F ÷ - + (不选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="中缀表达式转后缀表达式-手算"><a href="#中缀表达式转后缀表达式-手算" class="headerlink" title="中缀表达式转后缀表达式-手算"></a><strong>中缀表达式转后缀表达式-手算</strong></h4><p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p>
<p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[左操作数 右操作数 运算符]</code>的方式组合成一个新的操作数</p>
<p><strong>步骤3：</strong> 如果还有运算符没被处理，继续步骤2</p>
<p><strong>“左优先”原则:</strong> 只要左边的运算符能先计算，就优先算左边的 (保证运算顺序唯一)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中缀：A + B - C * D / E + F</span><br><span class="line">       ①   ④   ②   ③   ⑤     </span><br><span class="line">后缀：A B + C D * E / - F +</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203021115998.png" alt="image-20220302111528996"></p>
<h4 id="中缀表达式转后缀表达式-机算—-重点"><a href="#中缀表达式转后缀表达式-机算—-重点" class="headerlink" title="中缀表达式转后缀表达式-机算—-重点"></a><strong>中缀表达式转后缀表达式-机算—-重点</strong></h4><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<strong>从左到右</strong>处理各个元素，直到末尾。可能遇到三种情况:</p>
<ul>
<li>遇到<strong>操作数</strong>: 直接加入后缀表达式。</li>
<li>遇到<strong>界限符</strong>: 遇到 <code>&#39;(&#39;</code> 直接入栈; 遇到 <code>&#39;)&#39;</code> 则依次弹出栈内运算符并加入后缀表达式，直到弹出 <code>&#39;(&#39;</code> 为止。注意: <code>&#39;(&#39;</code> 不加入后缀表达式。</li>
<li>遇到<strong>运算符</strong>: 依次弹出栈中优先级<strong>高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式，若碰到 <code>&#39;(&#39;</code> 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206201249680.gif" alt="image-20220302111528996"></p>
<h4 id="后缀表达式的计算—手算"><a href="#后缀表达式的计算—手算" class="headerlink" title="后缀表达式的计算—手算:"></a><strong>后缀表达式的计算—手算:</strong></h4><ul>
<li><p>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应的运算，合体为一个操作数；</p>
<p><strong>注意：</strong> 两个操作数的左右顺序</p>
</li>
</ul>
<h4 id="后缀表达式的计算—机算"><a href="#后缀表达式的计算—机算" class="headerlink" title="后缀表达式的计算—机算"></a><strong>后缀表达式的计算—机算</strong></h4><p>用栈实现后缀表达式的计算（栈用来存放当前暂时不能确定运算次序的操作数）</p>
<p><strong>步骤1:</strong> 从左往后扫描下一个元素，直到处理完所有元素;</p>
<p><strong>步骤2:</strong> 若扫描到操作数，则压入栈，并回到<code>步骤1</code>;否则执行<code>步骤3</code>;</p>
<p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压回栈顶，回到<code>步骤1</code>;</p>
<p><strong>注意:</strong> 先出栈的是“<strong>右操作数</strong>”</p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206201316904.gif" alt="image-20220302111528996"></p>
<h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">运算符在两个操作数前面:</span><br><span class="line">① + a b</span><br><span class="line">② - +ab  c</span><br><span class="line">③ - +ab *cd</span><br></pre></td></tr></table></figure>
<h4 id="中缀表达式转前缀表达式—手算"><a href="#中缀表达式转前缀表达式—手算" class="headerlink" title="中缀表达式转前缀表达式—手算"></a><strong>中缀表达式转前缀表达式—手算</strong></h4><p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p>
<p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[运算符 左操作数 右操作数]</code>的方式组合成一个新的操作数</p>
<p><strong>步骤3：</strong> 如果还有运算符没被处理，就继续执行<code>步骤2</code></p>
<p><strong>“右优先”原则:</strong> 只要右边的运算符能先计算，就优先算<strong>右边</strong>的;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中缀：A + B * (C - D) - E / F</span><br><span class="line">       ⑤   ③    ②    ④   ①</span><br><span class="line">前缀：+ A - * B - C D / E F</span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203021114766.jpg" alt=""></p>
<h4 id="前缀表达式的计算—机算"><a href="#前缀表达式的计算—机算" class="headerlink" title="前缀表达式的计算—机算"></a><strong>前缀表达式的计算—机算</strong></h4><p>用栈实现前缀表达式的计算</p>
<p><strong>步骤1:</strong> 从<strong>右往左扫</strong>描下一个元素，直到处理完所有元素；</p>
<p><strong>步骤2:</strong> 若扫描到操作数则压入栈，并回到<code>步骤1</code>，否则执行<code>步骤3</code></p>
<p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到<code>步骤1</code>；</p>
<p><strong>注意:</strong> 先出栈的是“<strong>左操作数</strong>”</p>
<h2 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h2><p>函数调用的特点：<strong>最后被调用</strong>的函数<strong>最先执行</strong>结束(LIFO)</p>
<p>函数调用时，需要用一个栈存储：</p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
<p>递归调用时，函数调用栈称为 “递归工作栈”:</p>
<ul>
<li>每进入一层递归，就将递归调用所需信息压入栈顶；</li>
<li>每退出一层递归，就从栈顶弹出相应信息；</li>
</ul>
<p><strong>缺点</strong>：太多层递归可能回导致栈溢出；</p>
<p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题；</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h2><p><strong>一维数组存储</strong></p>
<ul>
<li>起始地址为<code>LOC</code>,且物理存放位置连续</li>
<li>下标取值范围叫数组的维界</li>
<li>数组下标默认0开始，除非题目特别说明</li>
<li>数组元素a[i]的存放地址=$LOC+i*sizeof(ElemType)$</li>
</ul>
<p><strong>二维数组存储</strong></p>
<ul>
<li>描述矩阵元素时，行、列号通常从<code>1</code>开始；</li>
<li>描述数组时，通常下标从 <code>0</code> 开始；</li>
<li>二维数组存储方式为<strong>行优先存储和列优先存储</strong></li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241226721.png" alt="image-20220624122648285"></p>
<p><strong>行优先存储</strong></p>
<ul>
<li>M行N列的二维数组<code>b[M][N]</code></li>
<li><code>b[i][j]</code>的存储位置=<code>LOC+(j*N+i)*sizeof(ElemType)</code></li>
</ul>
<p><strong>列优先存储</strong></p>
<ul>
<li>M行N列的二维数组<code>b[M][N]</code></li>
<li><code>b[i][j]</code>的存储位置=<code>LOC+(j*M+i)*sizeof(ElemType)</code></li>
</ul>
<h2 id="特殊矩阵的存储"><a href="#特殊矩阵的存储" class="headerlink" title="特殊矩阵的存储"></a><a href="https://blog.csdn.net/weixin_44480968/article/details/104664874?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165604643116781818713471%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165604643116781818713471&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104664874-null-null.142^v21^huaweicloudv1,157^v15^new_3&amp;utm_term=%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8&amp;spm=1018.2226.3001.4187">特殊矩阵的存储</a></h2><p><strong>压缩矩阵</strong>：指多个值相同的元素只分配一个存储空间，对0元素不分配存储空间，目的是节省存储空间</p>
<h3 id="对称矩阵-方阵"><a href="#对称矩阵-方阵" class="headerlink" title="对称矩阵(方阵)"></a>对称矩阵(方阵)</h3><ul>
<li>若n阶方阵中任意一个元素$a_{ij}$都有$a_{ij}=a_{ji}$,则该矩阵为对称矩阵</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241240915.png" alt="image-20220624124026422"></p>
<h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p><strong>只存储主对角线和下三角元素</strong></p>
<ul>
<li>按行优先将各个元素存在一维数组，一维数组大小为$\frac{(1+n)*n}{2}$，将实现一个映射函数将数组下标映射成数组下标。</li>
<li>数组下标$k=\frac{(i-1)*i}{2}+j-1$；数组下标从0开始</li>
</ul>
<p><code>a[i][j]</code>数组下标一般这么考虑：若是按行优先存储，先考虑第i-1行的元素个数，再考虑第i行的元素个数，计算总的个数，其他类似</p>
<h3 id="三角矩阵-方阵"><a href="#三角矩阵-方阵" class="headerlink" title="三角矩阵(方阵)"></a>三角矩阵(方阵)</h3><ul>
<li>下三角矩阵：除了主对角线和下三角区，其他元素都相同</li>
<li>上三角矩阵：除了主对角线和上三角区，其他元素都相同</li>
</ul>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241251863.png" alt="image-20220624125058154"></p>
<p><strong>上三角存储压缩策略</strong></p>
<ul>
<li>按行优先存储将绿色区元素存入一维数组，并在最后一个位置存储常数c</li>
</ul>
<p>数组下标$k=\left\{\begin{aligned}\frac{(i-1)(2n-i+2)}{2}+j-i,上三角和主对角线元素\\\frac{n(n+1)}{2}，下三角元素\end{aligned}\right.$</p>
<p><strong>下三角存储</strong></p>
<p>$k=\left\{\begin{aligned}\frac{(i-1)i}{2}+j-1,下三角和主对角线元素\\\frac{n(n+1)}{2}，上三角元素\end{aligned}\right.$</p>
<h3 id="三对角矩阵-方阵"><a href="#三对角矩阵-方阵" class="headerlink" title="三对角矩阵(方阵)"></a>三对角矩阵(方阵)</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241304890.png" alt="image-20220624130420525"></p>
<ul>
<li>三对角矩阵又叫带状矩阵：当$|i-j|&gt;1$时，有$a_{ij}=0$</li>
</ul>
<p>压缩策略：行优先（或者列优先）原则，只存储带状部分</p>
<p>数组下标$k=2i+j-3$</p>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><ul>
<li>定义：非零元素远远小于矩阵的个数的矩阵</li>
</ul>
<h4 id="存储策略-1"><a href="#存储策略-1" class="headerlink" title="存储策略"></a>存储策略</h4><p><strong>顺序存储——三元组</strong>{行，列，值}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//行</span></span><br><span class="line">    <span class="type">int</span> j;<span class="comment">//列</span></span><br><span class="line">    <span class="type">int</span> v;<span class="comment">//值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>链式存储——十字链表法</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241313484.jpg" alt=""></p>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="串的定义和实现"><a href="#串的定义和实现" class="headerlink" title="串的定义和实现"></a>串的定义和实现</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><ol>
<li><p>串: 零个或多个字符组成的有限序列，如 <code>S = &#39;iPhone 11 Pro Max?&#39;</code>；</p>
</li>
<li><p>串名：S是串名；</p>
</li>
<li><p>串的长度：串中字符的个数n；</p>
</li>
<li><p>空串：n=0时的串；</p>
</li>
<li><p>子串：串中任意多个连续的字符组成的<strong>子序列</strong>称为该串的子串；</p>
</li>
<li><p>主串：包含子串的串；</p>
</li>
<li><p>字符在主串中的位置：某个字符在串中的序号（从1开始）；</p>
</li>
<li><p>子串在主串中的位置：子串的<strong>第一个字符</strong>在主串中的位置；</p>
</li>
<li><p>空串 V.S 空格串：</p>
<ul>
<li><code>M = &#39;&#39;</code> 是空串；</li>
<li><code>N = &#39; &#39;</code> 是空格串；</li>
</ul>
</li>
<li><p>串 V.S 线性表：</p>
<ul>
<li><p>串是特殊的线性表，数据元素之间呈线性关系（逻辑结构相似）；</p>
</li>
<li><p>串的数据对象<strong>限定</strong>为字符集：中文字符、英文字符、数字字符、标点字符…</p>
</li>
<li>串的基本操作，如增删改除通常以<strong>子串</strong>为操作对象</li>
</ul>
</li>
</ol>
<h3 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h3><p>假设有串 <code>T = &#39;&#39;</code>, <code>S = &#39;iPhone 11 Pro Max?&#39;</code>, <code>W = &#39;Pro&#39;</code></p>
<ul>
<li><p><code>StrAssign(&amp;T, chars)</code>: 赋值操作，把串T赋值为chars；</p>
</li>
<li><p><code>StrCopy(&amp;T, S)</code>: 复制操作，把串S复制得到串T；</p>
</li>
<li><p><code>StrEmpty(S)</code>: 判空操作，若S为空串，则返回true，否则返回false；</p>
</li>
<li><p><code>StrLength(S)</code>: 求串长，返回串S的元素个数；</p>
<blockquote>
<p>返回<code>length</code>值</p>
</blockquote>
</li>
<li><p><code>ClearString(&amp;S)</code>: 清空操作，将S清为空串；</p>
<blockquote>
<p>将<code>length = 0</code>，逻辑上清空，但是内存中还有</p>
</blockquote>
</li>
<li><p><code>DestroyString(&amp;S)</code>: 销毁串，将串S销毁——<strong>回收存储空间</strong>；</p>
</li>
<li><p><code>Concat(&amp;T, S1, S2)</code>: 串联联接，用T返回由S1和S2联接而成的新串———可能会导致存储空间的扩展；</p>
</li>
<li><p><code>SubString(&amp;Sub, S, pos, len)</code>: 求子串，用Sub返回串S的第pos个字符起长度为len的子串；</p>
</li>
<li><p><code>Index(S, T)</code>: 定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中<strong>第一次出现的位置</strong>，否则函数值为0；</p>
</li>
<li><p><code>StrCompare(S, T)</code>: 串的比较操作，参照英文词典排序方式；若S &gt; T,返回值&gt;0; S = T,返回值=0 <strong>(需要两个串完全相同)</strong> ; S &lt; T,返回值&lt;0;</p>
</li>
</ul>
<p><strong>拓展：字符集编码</strong></p>
<ol>
<li>字符集————y=f(x)<ul>
<li>字符集理解为函数定义域x</li>
<li>编码:将函数映射成规则f</li>
<li>f:计算机对应的二进制数</li>
</ul>
</li>
<li>乱码问题:编码方式不同</li>
</ol>
<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><ol>
<li>定长顺序存储表示</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255   <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line">                       <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">                       <span class="comment">//每个char字符占1B</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<p>串长的两种表示法：</p>
<ul>
<li><p>方案一：用一个额外的变量<code>length</code>来存放串的长度（保留<code>ch[0]</code>）；</p>
</li>
<li><p>方案二：用<code>ch[0]</code>充当<code>length</code>；</p>
<ul>
<li>优点：字符的位序和数组下标相同；</li>
</ul>
</li>
<li><p>方案三：没有<code>length</code>变量，以字符<code>&#39;\0&#39;</code>表示结尾（对应ASCII码的0）；</p>
<ul>
<li>缺点：需要从头到尾遍历；</li>
</ul>
</li>
<li><p><strong>方案四——最终使用方案：</strong><code>ch[0]</code>废弃不用，声明int型变量<code>length</code>来存放串的长度（方案一与方案二的结合）</p>
</li>
<li><p>基本操作实现（基于方案四）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   </span><br><span class="line">    <span class="type">int</span> length;       </span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 一直起始位置和长度，求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos+len<span class="number">-1</span> &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=pos; i&lt;pos+len; i++)</span><br><span class="line">        Sub.cn[i-pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">    </span><br><span class="line">    Sub.length = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 比较两个串的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i; i&lt;S.length &amp;&amp; i&lt;T.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定位操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    n = StrLength(S);</span><br><span class="line">    m = StrLength(T);</span><br><span class="line">    SString sub;        <span class="comment">//用于暂存子串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(Sub,S,i,m);<span class="comment">//求子串</span></span><br><span class="line">        <span class="keyword">if</span>(StrCompare(Sub,T)!=<span class="number">0</span>)<span class="comment">//判断字串是否相同</span></span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> i;    <span class="comment">// 返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;            <span class="comment">//S中不存在与T相等的子串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>ps:结合顺序表思考优缺点</em></p>
<ol>
<li>堆分配存储表示</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;           <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S；</span><br><span class="line">S.ch = (<span class="type">char</span> *) <span class="built_in">malloc</span>(MAXLINE * <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">//基地址指针指向连续空间的起始位置</span></span><br><span class="line">                                                <span class="comment">//malloc()需要手动free()</span></span><br><span class="line">S.length;</span><br></pre></td></tr></table></figure>
<ol>
<li>串的链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;           <span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br></pre></td></tr></table></figure>
<p>问题：存储密度低，每个字符1B，每个指针4B；<br>解决方案：每一个链表的结点存储多个字符——每个结点称为块——<strong>块链结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];           <span class="comment">//每个结点存多个个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br></pre></td></tr></table></figure>
<p><em>ps:结合链表思考优缺点</em></p>
<ul>
<li>存储分配角度：链式存储的字符串无需占用连续空间，存储空间分配更灵活；</li>
<li>操作角度：若要在字符串中插入或删除某些字符，则顺序存储方式需要移动大量字符，而链式存储不用；</li>
<li>若要按位序查找字符，则顺序存储支持随机访问，而链式存储只支持顺序访问；</li>
</ul>
<h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><p>串的匹配模式：在主串中找到与模式串中找到相同的字串，并返回位置</p>
<h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><p><strong>模式串</strong>：尝试在主串中找到的串，未必存在</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;                <span class="comment">//扫描主串S</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;                <span class="comment">//扫描模式串T</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;             <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k++;            <span class="comment">//检查下一个子串</span></span><br><span class="line">            i=k;</span><br><span class="line">            j=<span class="number">1</span>;             <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206282210475.gif" alt=""></p>
<p><strong>时间复杂度分析：</strong></p>
<ul>
<li>主串长度为n，模式串长度为m</li>
<li>最多比较<code>n-m+1</code>个子串</li>
<li><p>最坏时间复杂度 =<code>O(nm)</code></p>
<ul>
<li>每个子串都要对比m个字符(对比到最后一个字符才匹配不上)，共要对比n-m+1个子串，复杂度 = <code>O((n-m+1)m) = O(nm - m^2 + m) = O(nm)</code></li>
<li><em>PS:大多数时候，n&gt;&gt;m</em></li>
</ul>
</li>
<li><p>最好时间复杂度 </p>
<ul>
<li>匹配成功：<code>O(m)</code></li>
</ul>
</li>
<li>匹配失败：每个子串的第一个字符就匹配失败，共要对比n-m+1个子串，复杂度 = <code>O(n-m+1) ≈ O(n)</code></li>
</ul>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><strong>与朴素算法对比就是i指针不用回溯</strong></p>
<p><strong>串的前缀</strong>：包含第一个字符，且不包含最后一个字符的字串</p>
<p><strong>串的后缀</strong>：包含最后一个字符，且不包含第一个字符的字串</p>
<ul>
<li><p>不匹配的字符之前，一定是和模式串一致的；</p>
</li>
<li><p>根据模式串T，求出<code>next数组</code></p>
<ul>
<li>（只与模式串有关，与主串无关），利用<code>next数组</code>进行匹配，</li>
<li>当匹配失败时，主串的指针 <code>i</code> 不再回溯！</li>
</ul>
</li>
</ul>
<h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>当j个字符匹配失败，由前<code>1~j-1</code>个字符组成的串为S</p>
<ul>
<li>则：<code>next[j]=S</code>的最长相等前后缀长度+1</li>
<li>与acwing平台的不同，acwing的next数组记录的是最长相等后缀长度</li>
</ul>
<p>例：对于串 <code>T = &#39;abaabc&#39;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>next[0]</th>
<th>next[1]</th>
<th>next[2]</th>
<th>next[3]</th>
<th>next[4]</th>
<th>next[5]</th>
<th>next[6]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>s串</td>
<td></td>
<td>a</td>
<td>ab</td>
<td><font color=Crimson>a</font>b<font color=Crimson>a</font></td>
<td><font color=Crimson>a</font>ba<font color=Crimson>a</font></td>
<td><font color=Crimson>ab</font>a<font color=Crimson>ab</font></td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206302139265.gif" alt=""></p>
<ol>
<li>利用<code>next数组</code>进行模式匹配</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;     <span class="comment">//主串</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;     <span class="comment">//模式串</span></span><br><span class="line">    <span class="keyword">while</span>（i&lt;S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j])&#123;     </span><br><span class="line">            ++j;</span><br><span class="line">            ++i;         <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j]   <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length; <span class="comment">//匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匹配字符串</strong></p>
<p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204251328676.png" alt=""></p>
<ul>
<li><code>s[a,b] = p[1,j] &amp;&amp; s[i] != p[j+1]</code> 此时要移动p串（不是移动1格，而是直接移动到下次能匹配的位置）</li>
<li>其中1串为<code>[1, next[ j ]]</code>，3串为<code>[j-next[j]+1,j]</code>。由匹配可知 1串等于3串，3串等于2串。所以<strong>直接移动p串使1到3的位置</strong>即可。这个操作可由<strong>j = next[ j ]</strong>直接完成。 如此往复下去，当 j == m时匹配成功。</li>
</ul>
<p><strong>3. 时间复杂度分析：</strong></p>
<ul>
<li>求next数组时间复杂度 = <code>O(m)</code></li>
<li>模式匹配过程最坏时间复杂度 = <code>O(n)</code></li>
<li>KMP算法的最坏时间复杂度 = <code>O(m+n)</code></li>
</ul>
<h2 id="KMP算法进一步优化"><a href="#KMP算法进一步优化" class="headerlink" title="KMP算法进一步优化"></a>KMP算法进一步优化</h2><p><strong>原因</strong>:第4个字符g匹配失败后，然后又和第一个字符g匹配，重复与g匹配了两次</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>模式串</td>
<td>g</td>
<td>0</td>
<td>0</td>
<td>g</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>对<code>next</code>数组的优化——<code>nextval</code>数组</p>
<p><strong>nextval数组的手算</strong></p>
<ul>
<li><p>先算出next数组</p>
</li>
<li><p>先令<code>nextval[1]=0</code>，也就是对比第j个位置和第next[j]个位置的字符，字符相同则nextval数组存储第next[j]位置的next数组大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=T.length;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])<span class="comment">//串字符相等</span></span><br><span class="line">        nextval[j]=nextval[next[j]];<span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextval[j]=next[j];<span class="comment">//字符不相等，为原来的next大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMP算法优化：当子串和模式串不匹配时<code>j=nextval[j]</code></p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>模式串</strong></th>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>A</strong></th>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>j</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
</tr>
<tr>
<td><strong>next[j]</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td><strong>nextval[j]</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>4</strong></td>
<td><strong>1</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="next数组问题"><a href="#next数组问题" class="headerlink" title="next数组问题"></a>next<a href="https://blog.csdn.net/Martin0316/article/details/116517065?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165659754816782391882104%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=165659754816782391882104&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-2-116517065-null-null.142^v29^pc_rank_34,157^v15^new_3&amp;utm_term=kmp%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88next%5B0%5D%E4%B8%BA0%E6%88%96%E8%80%85-1&amp;spm=1018.2226.3001.4187">数组问题</a></h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td>开始下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>next[]_ac</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>next[]_cur</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>开始下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next[]_wd</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>next[]_ac:存储的是字符串最长前后缀字符串（与acwing平台一样）</li>
<li>next[]_cur:将<code>next[]_ac</code>整体右移动，<code>next[0]=-1</code></li>
<li>next[]_wd:与王道书上一致,，在<code>next[]_cur</code>整体加1</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>首先我们可以将串的next数组按照王道的写出来</li>
<li>如果<strong>串的位序从1</strong>开始，就按照王道的规则写；</li>
<li>如果<strong>串的位序从0</strong>开始，就按照第二个next[]_cur写，也就是将王道规则整体减1；</li>
<li>注意计算王道规则时，j指向的字符q，计算q之前的字符不包含字符q</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>王道数据结构</title>
    <url>/blot.github.io/2022/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB/</url>
    <content><![CDATA[<h5 id="王道考研数据结构笔记"><a href="#王道考研数据结构笔记" class="headerlink" title="王道考研数据结构笔记"></a>王道考研<a href="https://so.csdn.net/so/search?q=数据结构&amp;spm=1001.2101.3001.7020">数据结构</a>笔记</h5><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h2><p>要点：</p>
<ol>
<li>线性表的基本操作——创销、增删、改查</li>
<li>传入参数时，何时要用引用 <code>&amp;</code></li>
</ol>
<h2 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的<a href="https://so.csdn.net/so/search?q=顺序表&amp;spm=1001.2101.3001.7020">顺序表</a>示</h2><h3 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h3><ol>
<li>顺序表的实现———<strong>静态分配</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;   <span class="comment">//将所有数据元素设置为默认初始值0,如果没有这一步，内存中会有遗留的“脏数据”</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.Length=<span class="number">0</span>;        <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">                       <span class="comment">//在内存里分配存储顺序表L的空间</span></span><br><span class="line">                       <span class="comment">//包括MaxSize*sizeof(ElemType)和存储length的空间</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>
<ol>
<li>顺序表的实现——<strong>动态分配</strong></li>
</ol>
<p><code>malloc</code>函数:</p>
<p><code>L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)</code> 其中<code>(ElemType*)</code>可强制转换数据类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;          <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;       <span class="comment">//最大容量</span></span><br><span class="line">    <span class="type">int</span> length;       <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;              <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *L)</span>&#123;</span><br><span class="line">    <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    L-&gt;MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SqList *L,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=L-&gt;data;   <span class="comment">//地址赋值</span></span><br><span class="line"></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L-&gt;MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i]=p[i];                 <span class="comment">//将旧数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;MaxSize=L-&gt;MaxSize+len;           <span class="comment">//数组最大长度</span></span><br><span class="line">    <span class="built_in">free</span>(p);                           <span class="comment">//释放原来的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(&amp;L);<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="comment">//以下代码对比</span></span><br><span class="line">    IncreaseSize(&amp;L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-顺序表上基本操作的实现-插入和删除"><a href="#2-2-2-顺序表上基本操作的实现-插入和删除" class="headerlink" title="2.2.2 顺序表上基本操作的实现 (插入和删除)"></a>2.2.2 顺序表上基本操作的实现 (插入和删除)</h3><ol>
<li>顺序表基本操作——插入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListInsert(&amp;L,i,e)</span><br></pre></td></tr></table></figure>
<p><strong>基于静态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——在L的位序i处插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span>&#123; </span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length&gt;MaxSize) <span class="comment">//当前存储空间已满，不能插入  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--)&#123;    <span class="comment">//将第i个元素及其之后的元素后移</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>]=e;  <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;      <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    ListInsert(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>关注最深层循环语句——<code>L.data[j]=L.data[j-1]</code>的执行次数与问题规模n——<code>L.length</code>的关系;</li>
<li>最好情况：插入表尾，不需要移动元素，i=n+1，循环0次；最好时间复杂度 = O(1)</li>
<li>最坏情况：插入表头，需要将原有的n个元素全都向后移动，i=1，循环n次；最坏时间复杂度 = O(n)</li>
<li>平均情况：假设新元素插入到任何一个位置的概率p(=1/n+1)相同</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>插入到第i个位置</th>
<th>循环次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>n</td>
</tr>
<tr>
<td>2</td>
<td>n-1</td>
</tr>
<tr>
<td>3</td>
<td>n-2</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n+1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>平均循环次数</strong> = np + (n-1)p + (n-2)p + … + 1×p = [ n(n+1)/2 ]×[ 1/(n+1) ] = n/2</p>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<ol>
<li>顺序表基本操作——删除</li>
</ol>
<p><code>ListDelete(&amp;L,i,e)</code>:删除表L中的第i个位置的元素，并用e返回删除元素的值<br><strong>基于静态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">LisDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span>&#123; <span class="comment">// e用引用型参数 </span></span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    e = L.data[i<span class="number">-1</span>]    <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--)&#123;    <span class="comment">//将第i个后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;      <span class="comment">//长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">-1</span>;        <span class="comment">//用变量e把删除的元素“带回来”</span></span><br><span class="line">    <span class="keyword">if</span>(LisDelete(L,<span class="number">3</span>,e))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已删除第三个元素，删除元素值=%d\n&quot;</span>,e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位序i不合法，删除失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>关注最深层循环语句——<code>L.data[j-1]=L.data[j]</code>的执行次数与问题规模n——<code>L.length</code>的关系;</li>
<li>最好情况：删除表尾元素，不需要移动元素，i=n，循环0次；最好时间复杂度 = O(1);</li>
<li>最坏情况：删除表头元素，需要将后续的n-1个元素全都向前移动，i=1，循环n-1次；最坏时间复杂度 = O(n);</li>
<li>平均情况：假设删除任何一个元素(1,2,3,…,length)的概率相同 p=1/n</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>删除第i个元素</th>
<th>循环次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>n-1</td>
</tr>
<tr>
<td>2</td>
<td>n-2</td>
</tr>
<tr>
<td>3</td>
<td>n-3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>平均循环次数</strong> = (n-1)p + (n-2)p + … + 1×p = [ n(n-1)/2 ]×[ 1/(n) ] = n-1/2</p>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<ol>
<li>顺序表基本操作——按位查找(顺序表)</li>
</ol>
<p><code>GetElem(L,i)</code> : 按位查找操作——获取表L中第i个位置元素的值</p>
<p><strong>基于静态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                     <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="comment">// ...判断i的值是否合法</span></span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];      <span class="comment">//注意是i-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p><strong>基于动态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;     <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;      <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="comment">// ...判断i的值是否合法</span></span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>]; <span class="comment">//就算是指针也能用数组下标哦!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<p><strong>O(1)</strong><br>由于顺序表的各个数据元素在内存中连续存放，因此可以根据<strong>起始地址</strong>和<strong>数据元素大小</strong>立即找到第i个元素———“随机存取”特性；</p>
<ol>
<li>顺序表基本操作——按值查找</li>
</ol>
<p><code>LocateElem(L, e)</code>: 按值查找操作，在表L中查找具有给定关键字值的元素；</p>
<p><strong>基于动态分配的代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemTyp *data;  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L.lengthl i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)  </span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;     <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;               <span class="comment">//推出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>Q:</strong> 如果顺序表里存放的是结构类型的数据元素，可不可以用 <code>==</code> 进行比较？</p>
<p><strong>A:</strong> 不能！结构类型的比较，需要依次对比各个分量来判断两个结构体是否相等；</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> people;</span><br><span class="line">&#125;Customer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    Customer a;</span><br><span class="line">    Customer b;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people == b.people)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不相等&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>最深处循环语句: <code>if(L.data[i] == e)</code> 与问题规模n=<code>L.length(表长)</code>的关系；</li>
<li>最好情况：查找目标元素在表头，循环1次，最好时间复杂度=O(1)</li>
<li>最坏情况：查找目标元素在表尾，循环n次，最好时间复杂度=O(n)</li>
<li>平均情况：假设目标元素出现在任何一个位置的概率相同，p=1/n</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>目标元素所在位置i</th>
<th>循环次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n</td>
<td>n</td>
</tr>
</tbody>
</table>
</div>
<p><strong>平均循环次数</strong> = 1×1/n + 2×1/n +…+ n×1/n = [ n(n+1)/2 ] × 1/n = (n+1)/2</p>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<p><img src="https://img-blog.csdnimg.cn/20210422220005304.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxNjQzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h2><h3 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h3><ol>
<li>何为单链表？</li>
</ol>
<ul>
<li>链式存储</li>
<li>每个结点存储：数据元素自身信息 &amp; 指向下一个结点(后继)的指针</li>
<li>优点：不要求大片连续空间，改变容量方便</li>
<li>缺点：不可随机存取，要耗费一定空间存放指针</li>
</ul>
<ol>
<li>代码定义单链表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            <span class="comment">//定义单链表节点类型  LNode:结点</span></span><br><span class="line">    ElemType data;       <span class="comment">//每个结点存放一个数据元素 data:数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针指向下一个结点 next:指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>增加一个新的结点：在内存中申请一个结点所需的空间，并用指针p指向这个结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><em>如果每次都要写struct很麻烦，所以可以利用typedef关键字——数据类型重命名：<code>type&lt;数据类型&gt;&lt;别名&gt;</code></em></p>
<p>Eg:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> zhengshu;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *zhengshuzhizhen;  <span class="comment">//指向int型的指针</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>上面操作可以化简为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span></span><br><span class="line"></span><br><span class="line">LNode* p = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p><strong>最简洁代码实现:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>以上代码等同于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>           </span><br><span class="line">    ElemType data;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span> <span class="comment">//重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span> </span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>要表示一个单链表时，只需声明一个<strong>头指针L</strong>，指向单链表的第一个结点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *L;    <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是结点</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">LinkList L;  <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是链表</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>两种实现方法</li>
</ol>
<ul>
<li>不带头结点的单链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;  <span class="comment">//注意用引用 &amp;</span></span><br><span class="line">    L = <span class="literal">NULL</span>; <span class="comment">//空表，暂时还没有任何结点；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>
<ul>
<li>带头结点的单链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//头指针指向的结点——分配一个头结点（不存储数据）</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)          <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;       <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>
<p><strong>不带头结点 V.S. 带头结点</strong></p>
<ul>
<li>不带头结点：写代码麻烦！对第一个数据节点和后续数据节点的处理需要用不同的代码逻辑，对空表和非空表的处理也需要用不同的代码逻辑; <strong>头指针指向的结点用于存放实际数据;</strong></li>
<li>带头结点：<strong>头指针指向的头结点不存放实际数据,头结点指向的下一个结点才存放实际数据;</strong></li>
</ul>
<h3 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h3><p><strong>1. 单链表的插入</strong></p>
<ul>
<li><strong>按位序插入 (带头结点)</strong></li>
</ul>
<p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后；其中头结点可以看作第0个结点，故i=1时也适用。</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="comment">//判断i的合法性, i是位序号(从1开始)</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    </span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                 <span class="comment">//将结点s连到p后,后两步千万不能颠倒qwq</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析</p>
<blockquote>
<p>最好情况：插入第1个位置 O(1)</p>
<p>最坏情况：插入表尾 O(n)</p>
<p>平均时间复杂度 = O(n)</p>
</blockquote>
<ul>
<li><strong>按位序插入 (不带头结点)</strong></li>
</ul>
<p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后; 因为不带头结点，所以不存在“第0个”结点，因此！<strong>i=1 时，需要特殊处理——插入(删除)第1个元素时，需要更改头指针L;</strong></p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入到第1个位置时的操作有所不同！</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(size of(LNode));</span><br><span class="line">        s-&gt;data =e;</span><br><span class="line">        s-&gt;next =L;</span><br><span class="line">        L=s;          <span class="comment">//头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i&gt;1的情况与带头结点一样！唯一区别是j的初始值为1</span></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>
<p><em>除非特别声明，否则之后的代码都默认为带头结点哦，做题注意审题</em></p>
<ul>
<li><strong>指定结点的后插操作</strong></li>
</ul>
<p><code>InsertNextNode(LNode *p, ElemType e)</code>: 给定一个结点p，在其之后插入元素e; 根据单链表的链接指针只能往后查找，故给定一个结点p，那么p之后的结点我们都可知，但是p结点之前的结点无法得知;</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">//某些情况下分配失败，比如内存不足</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;          <span class="comment">//用结点s保存数据元素e </span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          <span class="comment">//将结点s连到p之后</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;                         <span class="comment">//平均时间复杂度 = O(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有了后插操作，那么在第i个位置上插入指定元素e的代码可以改成：</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    </span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> InsertNextNode(p, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>指定结点的前插操作</strong></li>
</ul>
<p><strong>Q:</strong> 如何找到p结点的前驱节点？</p>
<p><strong>A:</strong> 传入头指针L！就可以知道整个链表的信息了！</p>
<p><code>InsertPriorNode(LinkList L, LNode *p, ElemType e)</code>：循环查找p的前驱q，再对q进行后插操作，时间复杂度为O(n);</p>
<p><strong>Q:</strong> 那如果不传入头指针L呢？</p>
<p>不传入头指针L的代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, ElenType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>) <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点来了！</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;       <span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data; <span class="comment">//将p中元素复制到s</span></span><br><span class="line">    p-&gt;data = e;       <span class="comment">//p中元素覆盖为e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>；</span><br><span class="line">&#125;  <span class="comment">//时间复杂度为O(1)</span></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>
<p>王道书版本代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, LNode *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;  <span class="comment">///s连接到p</span></span><br><span class="line">    ELemType temp = p-&gt;data;  <span class="comment">//交换数据域部分</span></span><br><span class="line">    p-&gt;data = s-&gt;data;</span><br><span class="line">    s-&gt;data = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 单链表的删除</strong></p>
<ul>
<li><strong>按位序删除(带头结点)</strong></li>
</ul>
<p><code>ListDelete(&amp;L, i, &amp;e)</code>: 删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值;头结点视为“第0个”结点；</p>
<p><em>思路：找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点；</em></p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElenType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;         <span class="comment">//令q指向被删除的结点</span></span><br><span class="line">    e = q-&gt;data;                <span class="comment">//用e返回被删除元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;          <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q)                     <span class="comment">//释放结点的存储空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：</p>
<blockquote>
<p>最坏，平均时间复杂度：O(n)</p>
<p>最好时间复杂度：删除第一个结点 O(1)</p>
</blockquote>
<ul>
<li><strong>指定结点的删除</strong></li>
</ul>
<p>删除结点p，需要修改其前驱结点的next指针(两个方法)；</p>
<p>“偷天换日”代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *q = p-&gt;next;      <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data; <span class="comment">//让p和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;       <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//时间复杂度 = O(1)</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p><strong>但是</strong> 如果p是最后一个结点，那么<code>p-&gt;next = q-&gt;next</code> and <code>p-&gt;data = p-&gt;next-&gt;data</code> 就会出错，只能从表头开始依次寻找o的前驱，时间复杂度为O(n); 这就是单链表的<strong>局限性</strong>——无法逆向检索。</p>
<p><strong>3. 单链表的查找</strong></p>
<p><em>探讨带头结点！</em></p>
<ul>
<li><strong>按位查找</strong></li>
</ul>
<p><code>GetElem(L, i):</code> 按位查找操作，获取表L中第i个位置的元素的值;</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *p;               <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;                <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                  <span class="comment">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;  <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;               <span class="comment">//返回p指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>平均时间复杂度</strong> = O(n)</p>
<p>王道书版本代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;                <span class="comment">//从第一个结点开始</span></span><br><span class="line">    LNode *p = L-&gt;next      <span class="comment">//p先指向第一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;  <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;               <span class="comment">//返回p指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>那么上一节的按位插入和按位删除就可以封装了！<br><img src="https://img-blog.csdnimg.cn/20210422215801163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxNjQzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>按值查找</strong></li>
</ul>
<p><code>LocateElem(L, e):</code>按值查找操作，在表L中查找具有给定关键字值的元素;</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span>&#123;</span><br><span class="line">    LNode *P = L-&gt;next;    <span class="comment">//p指向第一个结点</span></span><br><span class="line">    <span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;           <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p><strong>注意当ElemType是结构体时的操作</strong></p>
<p><strong>4. 求单链表的长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Length(LinkList L)</span><br></pre></td></tr></table></figure>
<p>代码实现 (带头结点)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;       <span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>平均时间复杂度=</strong> O(n)</p>
<p><strong>5. 单链表的建立</strong></p>
<p><strong>思路：</strong> 初始化一个单链表 -&gt; 每取一个数据元素，插入到表尾/表头</p>
<p><strong>核心：</strong> 初始化操作 and 指定结点的后插操作</p>
<p><em>探讨带头结点！</em></p>
<ul>
<li>尾插法建立单链表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化单链表</span><br><span class="line"></span><br><span class="line">设置变量length记录链表当前的长度</span><br><span class="line"></span><br><span class="line">while循环&#123;</span><br><span class="line">    每次取一个数据元素e;</span><br><span class="line">    ListInsert(L, length+1, e)插到尾部;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>
<p><strong>但是</strong>,因为每次都要执行↓,就是每次都要从头开始遍历，时间复杂度为O(n²)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(p!=NULL &amp;&amp; j&lt;i-1)&#123;     </span><br><span class="line">    p = p-&gt;next;             </span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>：设置一个表尾指针r，对r这个结点进行后插操作<code>InsertNextNode()</code></p>
<p>最终代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="type">int</span> x;                                   <span class="comment">//设ElemType为整型int</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点(初始化空表)</span></span><br><span class="line">    LNode *s, *r = L;                        <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s                                <span class="comment">//r指针指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p><strong>平均时间复杂度</strong>：O(n)</p>
<ul>
<li>头插法建立单链表</li>
</ul>
<p>对头结点进行后插操作<code>InsertNextNode()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化单链表</span><br><span class="line"></span><br><span class="line">while循环&#123;</span><br><span class="line">    每次取一个数据元素e;</span><br><span class="line">    InsertNextNode(L, e);</span><br><span class="line">&#125;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>最终代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//初始为空链表,这步不能少！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;                         <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>
<p><strong>PS: 只要是初始化单链表，都先将头指针指向NULL — <code>L-&gt;next = NULL</code>;</strong></p>
<h2 id="重要应用：链表的逆置"><a href="#重要应用：链表的逆置" class="headerlink" title="重要应用：链表的逆置"></a><strong>重要应用</strong>：链表的逆置</h2><p><a href="https://blog.csdn.net/qq_42322103/article/details/82668765">详细见CSDN:单链表逆置—头插法图解</a></p>
<ul>
<li>算法思想：逆置链表初始为空，原表中结点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *<span class="title function_">Inverse</span><span class="params">(LNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *p, *q;</span><br><span class="line">	p = L-&gt;next;     <span class="comment">//p指针指向第一个结点</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指向NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q-&gt;next = L-&gt;next;  </span><br><span class="line">		L-&gt;next = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h3><p>双链表中节点类型的描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<ol>
<li>双链表的初始化 (带头结点)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(Dlinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));      <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                              <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;   <span class="comment">//头结点的prior指针永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    DLinklist L;         <span class="comment">// 定义指向头结点的指针L</span></span><br><span class="line">    InitDLinkList(L);    <span class="comment">//申请一片空间用于存放头结点，指针L指向这个头结点</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的next指针是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>
<p>与单链表中一样，<code>DLinklist</code> 强调链表， <code>DNode *</code>强调结点，二者本质上等价;</p>
<ol>
<li>双链表的插入操作</li>
</ol>
<ul>
<li>后插操作</li>
</ul>
<p><code>InsertNextDNode(p, s)</code>: 在p结点后插入s结点</p>
<p>代码实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; <span class="comment">//将结点 *s 插入到结点 *p之后</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>) <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)   <span class="comment">//p不是最后一个结点=p有后继结点  </span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<ul>
<li>按位序插入操作</li>
</ul>
<p>思路：从头结点开始，找到某个位序的前驱结点，对该前驱结点执行后插操作；</p>
<ul>
<li>前插操作</li>
</ul>
<p>思路：找到给定结点的前驱结点，再对该前驱结点执行后插操作；</p>
<ol>
<li>双链表的删除操作</li>
</ol>
<p>删除p的后继结点q</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>如果要删除的结点q是最后一个结点，会出现错误，故增加条件判断以提高代码健壮性</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeletNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q =p-&gt;next;            <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//p没有后继结点;</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)           <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        DeletNextDNode(L);  <span class="comment">//删除头结点的后继结点</span></span><br><span class="line">    <span class="built_in">free</span>(L); <span class="comment">//释放头结点</span></span><br><span class="line">    L=<span class="literal">NULL</span>;  <span class="comment">//头指针指向NULL</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>
<ol>
<li>双链表的遍历操作<br><strong>后向遍历</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><strong>前向遍历</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>如果我们不想处理头结点，那就跳过头结点！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 双链表不可随机存取，按位查找和按值查找操作都只能用遍历的方式实现，时间复杂度为<strong>O(n)</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210422215943132.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxNjQzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-3-4-循环链表"><a href="#2-3-4-循环链表" class="headerlink" title="2.3.4 循环链表"></a>2.3.4 循环链表</h3><p><strong>1. 循环单链表</strong></p>
<p><strong>最后一个结点的指针不是NULL,而是指向头结点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *Linklist;</span><br><span class="line"></span><br><span class="line">/初始化一个循环单链表</span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)             <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;            <span class="comment">//头结点next指针指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L, LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>
<h2 id="单链表-amp-循环单链表"><a href="#单链表-amp-循环单链表" class="headerlink" title="单链表 &amp; 循环单链表"></a>单链表 &amp; 循环单链表</h2><ul>
<li><strong>单链表</strong>：从一个结点出发只能找到该结点后续的各个结点；对链表的操作大多都在头部或者尾部；设立头指针，从头结点找到尾部的时间复杂度=O(n)，即对表尾进行操作需要O(n)的时间复杂度;</li>
<li><strong>循环单链表</strong>：从一个结点出发，可以找到其他任何一个结点；设立尾指针，从尾部找到头部的时间复杂度为O(1)，即对表头和表尾进行操作都只需要O(1)的时间复杂度;</li>
</ul>
<blockquote>
<p>可以让L指向表尾元素(插入，删除时可能需要修改L)</p>
</blockquote>
<p><strong>2. 循环双链表</strong></p>
<p><strong>表头结点的<code>prior</code>指向表尾结点，表尾结点的<code>next</code>指向头结点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>          </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));    <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    L-&gt;prior = L;          <span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;           <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化循环单链表</span></span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环双链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(DLinklist L, DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536</span></span><br></pre></td></tr></table></figure>
<h2 id="双链表-amp-循环双链表"><a href="#双链表-amp-循环双链表" class="headerlink" title="双链表 &amp; 循环双链表"></a>双链表 &amp; 循环双链表</h2><ul>
<li><strong>插入操作</strong></li>
</ul>
<p>对于循环双链表，操作 <code>p-&gt;next-&gt;prior = s</code> 不会出问题辣！因为就算p是最后一个结点，也不会出现空指针现象了(这个问题在双链表里会出现！)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>删除操作</strong></li>
</ul>
<p>和插入操作一样！<code>q-&gt;next-&gt;prior</code> 对于循环双链表不会出错了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p的后继结点q</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-静态链表"><a href="#2-3-5-静态链表" class="headerlink" title="2.3.5 静态链表"></a>2.3.5 静态链表</h3><ol>
<li>何为静态链表</li>
</ol>
<ul>
<li>单链表: 各个结点散落在内存中的各个角落，每个结点有指向下一个节点的指针(下一个结点在内存中的地址);</li>
<li>静态链表——用<a href="https://so.csdn.net/so/search?q=数组&amp;spm=1001.2101.3001.7020">数组</a>的方式实现的链表: 分配一整片连续的内存空间，各个结点集中安置，包括了——数据元素and下一个结点的数组下标(游标)<ul>
<li>其中数组下标为0的结点充当”头结点”</li>
<li>游标为-1表示已经到达表尾</li>
<li>若每个数据元素为4B，每个游标为4B，则每个结点共8B；假设起始地址为<code>addr</code>，则数据下标为2的存放地址为：<code>addr</code>+8*2</li>
<li><strong>注意</strong>： 数组下标——物理顺序，位序——逻辑顺序；</li>
<li>优点：增、删操作不需要大量移动元素；</li>
<li>缺点：不能随机存取，只能从头结点开始依次往后查找，<strong>容量固定不变！</strong></li>
</ul>
</li>
</ul>
<ol>
<li>代码定义一个静态链表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组定义多个连续存放的结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//数组a作为静态链表, 每一个数组元素的类型都是struct Node</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ELemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>上面这个代码等同于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span> <span class="comment">//重命名struct Node，用SLinkList定义“一个长度为MaxSize的Node型数组;</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>PS: <code>SLinkList a</code> 强调a是静态链表；<code>struct Node a</code> 强调a是一个Node型数组；</p>
<ol>
<li>静态链表基本操作的实现</li>
</ol>
<ul>
<li>初始化静态链表：把<code>a[0]</code>的<code>next</code>设为-1</li>
<li>查找某个位序（不是数组下标，位序是各个结点在逻辑上的顺序）的结点：从头结点出发挨个往后遍历结点，时间复杂度O=(n)</li>
<li>在位序为i上插入结点：① 找到一个空的结点，存入数据元素；② 从头结点出发找到位序为i-1的结点；③修改新结点的next；④ 修改i-1号结点的next；</li>
</ul>
<blockquote>
<p>Q：如何判断结点为空？</p>
<p>A：在初始化时，将空闲结点的next设置为某个特殊值，eg：-2；</p>
</blockquote>
<ul>
<li>删除某个结点：① 从头结点出发找到前驱结点；② 修改前驱节点的游标；③ 被删除节点next设为-2；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ELemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-顺序表和链表的比较"><a href="#2-3-6-顺序表和链表的比较" class="headerlink" title="2.3.6 顺序表和链表的比较"></a>2.3.6 顺序表和链表的比较</h3><p><strong>1. 逻辑结构</strong></p>
<ul>
<li>顺序表和链表都属于线性表，都是线性结构</li>
</ul>
<p><strong>2. 存储结构</strong></p>
<ul>
<li>顺序表：顺序存储<ul>
<li>优点：支持随机存取，存储密度高</li>
<li>缺点：大片连续空间分配不方便，改变容量不方便</li>
</ul>
</li>
<li>链表：链式存储<ul>
<li>优点：离散的小空间分配方便，改变容量方便</li>
<li>缺点：不可随机存取，存储密度低</li>
</ul>
</li>
</ul>
<p><strong>3. 基本操作 - 创</strong></p>
<ul>
<li>顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源；<ul>
<li>静态分配：静态数组，容量不可改变</li>
<li>动态分配：动态数组，容量可以改变，但是需要移动大量元素，时间代价高（<code>malloc()</code>,<code>free()</code>）</li>
</ul>
</li>
<li>链表：只需要分配一个头结点或者只声明一个头指针</li>
</ul>
<p><strong>4. 基本操作 - 销毁</strong></p>
<ul>
<li><p>顺序表：修改 <code>Length</code> = 0</p>
<ul>
<li><p>静态分配：静态数组——系统自动回收空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态分配：动态数组——需要手动free</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创</span></span><br><span class="line">L.data = (ELemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) *InitSize)</span><br><span class="line"><span class="comment">//销</span></span><br><span class="line"><span class="built_in">free</span>(L.data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//！malloc() 和 free() 必须成对出现</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>链表：依次删除各个结点 <code>free()</code></p>
</li>
</ul>
<p><strong>5. 基本操作 - 增/删</strong></p>
<ul>
<li>顺序表：插入/删除元素要将后续元素后移/前移；时间复杂度=O(n)，时间开销主要来自于移动元素；</li>
<li>链表：插入/删除元素只需要修改指针；时间复杂度=O(n)，时间开销主要来自查找目标元素</li>
</ul>
<p><strong>6. 基本操作 - 查</strong></p>
<ul>
<li>顺序表<ul>
<li>按位查找：O(1)</li>
<li>按值查找：O(n)，若表内元素有序，可在O(log2n)时间内找到</li>
</ul>
</li>
<li>链表：<ul>
<li>按位查找：O(n)</li>
<li>按值查找：O(n)</li>
</ul>
</li>
</ul>
<p><strong>7. 开放式问题答题思路</strong></p>
<p><strong>Q:</strong> 请描述顺序表和链表的balabalabala…实现线性表时，用顺序表还是链表好？</p>
<p><strong>A:</strong> 顺序表和链表的<strong>存储结构</strong>都是线性结构，都属于线性表；但是二者的<strong>存储结构</strong>不同，顺序表采用顺序存储…(特点，优缺点)；链表采用链式存储…(特点，优缺点)；由于采用不同的存储方式实现，因此<strong>基本操作</strong>的实现效率也不同；当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…；</p>
<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1-栈-stack"><a href="#3-1-栈-stack" class="headerlink" title="3.1 栈 (stack)"></a>3.1 栈 (stack)</h2><h3 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h3><ol>
<li>栈的定义</li>
</ol>
<ul>
<li>栈是特殊的线性表：<strong>只允许在一端进行插入或删除操作，</strong> 其逻辑结构与普通线性表相同；</li>
<li>栈顶：允许进行插入和删除的一端 （最上面的为<strong>栈顶元素</strong>）；</li>
<li>栈底：不允许进行插入和删除的一端 （最下面的为<strong>栈底元素</strong>）；</li>
<li>空栈：不含任何元素的空表；</li>
<li>特点：后进先出（后进栈的元素先出栈）；</li>
<li>缺点：栈的大小不可变，解决方法——共享栈；</li>
</ul>
<ol>
<li>栈的基本操作 （运算）</li>
</ol>
<h3 id="“创-amp-销”"><a href="#“创-amp-销”" class="headerlink" title="“创&amp;销”"></a><strong>“创&amp;销”</strong></h3><ul>
<li><code>InitStack(&amp;S)</code> <strong>初始化栈</strong>：构造一个空栈S，分配内存空间；</li>
<li><code>DestroyStack(&amp;S)</code> <strong>销毁栈</strong>：销毁并释放栈S所占用的内存空间；</li>
</ul>
<h3 id="“增-amp-删”"><a href="#“增-amp-删”" class="headerlink" title="“增&amp;删”"></a><strong>“增&amp;删”</strong></h3><ul>
<li><code>Push(&amp;S, x)</code> <strong>进栈</strong>：若栈S未满，则将x加入使其成为新栈顶；</li>
<li><code>Pop(&amp;S, &amp;x)</code> <strong>出栈</strong>：若栈S非空，则弹出（删除）栈顶元素，并用x返回；</li>
</ul>
<h3 id="“查-amp-其他”"><a href="#“查-amp-其他”" class="headerlink" title="“查&amp;其他”"></a><strong>“查&amp;其他”</strong></h3><ul>
<li><code>GetTop(S, &amp;x)</code> <strong>读取栈顶元素</strong>：若栈S非空，则用x返回栈顶元素；（栈的使用场景大多只访问栈顶元素）；</li>
<li><code>StackEmpty(S)</code> <strong>判空</strong>： 断一个栈S是否为空，若S为空，则返回<code>true</code>,否则返回<code>false</code>；</li>
</ul>
<ol>
<li>栈的常见题型</li>
</ol>
<ul>
<li>给个进栈顺序，判断有哪些合法的出栈顺序；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：进栈顺序为：a -&gt; b -&gt; c -&gt; d -&gt; e</span><br><span class="line">    </span><br><span class="line">    合法的出栈顺序：e d c b a / b e d c a (出栈和进栈交替进行) / ... </span><br><span class="line">    </span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-栈的顺序存储"><a href="#3-1-2-栈的顺序存储" class="headerlink" title="3.1.2 栈的顺序存储"></a>3.1.2 栈的顺序存储</h3><ol>
<li>顺序栈的定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶元素</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">                     <span class="comment">//连续的存储空间大小为 MaxSize*sizeof(ElemType)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<ol>
<li>顺序栈的基本操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶元素</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)      <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>                 <span class="comment">//栈不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>)        <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    S.top = S.top + <span class="number">1</span>;    <span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;    <span class="comment">//新元素入栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    S.data[++S.top] = x;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;x, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];       <span class="comment">//先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;       <span class="comment">//栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x = S.data[S.top--];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是逻辑上的删除，数据依然残留在内存里</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];      <span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566</span></span><br></pre></td></tr></table></figure>
<p><strong>PS:</strong> 也可以初始化时定义 <code>S.top = 0</code> ：top指针指向下一个可以插入元素的位置(栈顶元素的后一个位置)；</p>
<ul>
<li>判空：<code>if(S.top == 0)</code></li>
<li>进栈使用：<code>S.data[S.top++] = x;</code></li>
<li>出栈使用：<code>x = S.data[--S.top];</code></li>
<li>判断栈满：<code>s.top == MaxSize</code></li>
</ul>
<ol>
<li>共享栈</li>
</ol>
<p>两个栈共享同一片空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;        <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1 = MaxSize;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>栈满条件：<code>top0 + 1 == top1</code></p>
<h3 id="3-1-3-栈的链式存储结构"><a href="#3-1-3-栈的链式存储结构" class="headerlink" title="3.1.3 栈的链式存储结构"></a>3.1.3 栈的链式存储结构</h3><ol>
<li>用链式存储方式实现的栈</li>
</ol>
<ul>
<li>进栈和出栈都只能在栈顶一端进行(链头作为栈顶)</li>
<li>链表的头部作为栈顶，意味着：<ul>
<li>在实现数据”入栈”操作时，需要将数据从链表的头部插入；</li>
<li>在实现数据”出栈”操作时，需要删除链表头部的首元节点；</li>
</ul>
</li>
</ul>
<p><strong>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表;</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125;*LiStack;                      <span class="comment">//栈类型的定义</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<ol>
<li>链栈的基本操作 (类比单链表的操作 / <strong>带头结点&amp;不带头结点</strong>)</li>
</ol>
<p><a href="https://blog.csdn.net/Xulidanga/article/details/108895669">参考：链栈基本操作(带头结点及不带头结点)</a></p>
<ul>
<li>初始化</li>
<li>进栈</li>
<li>出栈</li>
<li>获取栈顶元素</li>
<li>判空、判满</li>
</ul>
<p><strong>带有头结点的链栈基本操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    Linknode *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;L)</span>&#123;   <span class="comment">//L为头指针</span></span><br><span class="line">    L = new Linknode; </span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 进栈(：链栈基本上不会出现栈满的情况)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = new Linknode;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    Linknode s;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="comment">//栈空不能出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s = L-&gt;next;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L-&gt;next = L-&gt;next-&gt;next;</span><br><span class="line">    delete(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span></span><br></pre></td></tr></table></figure>
<p><strong>不带头结点的链栈基本操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    Linknode *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        teturn <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = new Linknode;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = L;</span><br><span class="line">    L = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    Linknode s; </span><br><span class="line">    <span class="keyword">if</span>(L = <span class="literal">NULL</span>)     <span class="comment">//栈空不出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s = L;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    delete(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-队列-Queue"><a href="#3-2-队列-Queue" class="headerlink" title="3.2 队列(Queue)"></a>3.2 队列(Queue)</h2><h3 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h3><ol>
<li>队列的定义</li>
</ol>
<ul>
<li>队列是操作受限的<strong>线性表</strong>，只允许在一端进行插入 (入队)，另一端进行删除 (出队)</li>
<li>操作特性：<strong>先进先出 FIFO</strong></li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>空队列：不含任何元素的空表</li>
</ul>
<ol>
<li>队列的基本操作</li>
</ol>
<h3 id="“创-amp-销”-1"><a href="#“创-amp-销”-1" class="headerlink" title="“创&amp;销”"></a><strong>“创&amp;销”</strong></h3><ul>
<li><code>InitQueue(&amp;Q)</code>: 初始化队列，构造一个空列表Q</li>
<li><code>DestroyQueue(&amp;Q)</code>: 销毁队列，并释放队列Q所占用的内存空间</li>
</ul>
<h3 id="“增-amp-删”-1"><a href="#“增-amp-删”-1" class="headerlink" title="“增&amp;删”"></a><strong>“增&amp;删”</strong></h3><ul>
<li><code>EnQueue(&amp;Q, x)</code>: 入队，若队列Q未满，将x加入，使之成为新的队尾</li>
<li><code>DeQueue(&amp;Q, &amp;x)</code>: 出队，若队列Q非空，删除队头元素，并用x返回</li>
</ul>
<h3 id="“查-amp-其他”-1"><a href="#“查-amp-其他”-1" class="headerlink" title="“查&amp;其他”"></a><strong>“查&amp;其他”</strong></h3><ul>
<li><code>GetHead(Q,&amp;x)</code>: 读队头元素，若队列Q非空，则将队头元素赋值给x</li>
<li><code>QueueEmpty(Q)</code>: 判队列空，若队列Q为空，则返回true</li>
</ul>
<h3 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h3><ul>
<li>队头指针：指向队头元素；</li>
<li>队尾指针：指向队尾元素的后一个位置（下一个应该插入的位置）</li>
</ul>
<ol>
<li>队列的顺序存储结构的基本操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列的顺序存储类型</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">                              <span class="comment">//连续的存储空间，大小为——MaxSize*sizeof(ElemType)</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> test&#123;</span><br><span class="line">    SqQueue Q;                <span class="comment">//声明一个队列</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue <span class="number">0</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)    <span class="comment">//判空条件后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>
<ol>
<li>循环队列</li>
</ol>
<p><strong>Q:</strong> 能否用 <code>Q.rear == MaxSize</code> 作为队列满的条件？</p>
<p><strong>A:</strong> 不能！会有假溢出, 所以需要用 <strong>模运算</strong> 将存储空间 {0,1,2,…,MaxSize} 在逻辑上变成“环状”——<strong>循环队列！</strong></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7CPbzxxS-1620744230788)(循环队列.PNG)]</p>
<blockquote>
<p>a%b == a除以b的余数</p>
<p>初始：Q.front = Q.rear = 0;</p>
<p>队首指针进1：Q.front = (Q.front + 1) % MaxSize</p>
<p>队尾指针进1：Q.rear = (Q.rear + 1) % MaxSize —— 队尾指针后移，当移到最后一个后，下次移动会到第一个位置</p>
<p>队列长度：(Q.rear + MaxSize - Q.front) % MaxSize</p>
</blockquote>
<h3 id="循环队列如何判满"><a href="#循环队列如何判满" class="headerlink" title="循环队列如何判满"></a><strong>循环队列如何判满</strong></h3><p><strong>Q:</strong> 能否用<code>Q.rear == Q.front</code> 作为队列满的条件？</p>
<p><strong>A:</strong> 不能！这已经作为队列空的判断条件了；</p>
<h3 id="方案一-牺牲一个单元来区分队空和队满"><a href="#方案一-牺牲一个单元来区分队空和队满" class="headerlink" title="方案一: 牺牲一个单元来区分队空和队满"></a><strong>方案一</strong>: 牺牲一个单元来区分队空和队满</h3><p>队尾指针的再下一个位置就是队头，即 <code>(Q.rear+1)%MaxSize == Q.front</code></p>
<ul>
<li>循环队列——入队：只能从队尾插入（判满使用方案一）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front)        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;                      <span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;         <span class="comment">//队尾指针加1取模</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<ul>
<li>循环队列——出队：只能让队头元素出队</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队，删除一个队头元素，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针后移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ul>
<li>循环队列——获得队头元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="方案二-不牺牲存储空间，设置size"><a href="#方案二-不牺牲存储空间，设置size" class="headerlink" title="方案二: 不牺牲存储空间，设置size"></a><strong>方案二</strong>: 不牺牲存储空间，设置size</h3><p>定义一个变量 <code>size</code>用于记录队列此时记录了几个数据元素，初始化 <code>size = 0</code>，进队成功 <code>size++</code>，出队成功<code>size--</code>，根据size的值判断队满与队空</p>
<p>队满条件：<code>size == MaxSize</code></p>
<p>队空条件：<code>size == 0</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">//队列当前长度</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<h3 id="方案三-不牺牲存储空间，设置tag"><a href="#方案三-不牺牲存储空间，设置tag" class="headerlink" title="方案三: 不牺牲存储空间，设置tag"></a><strong>方案三</strong>: 不牺牲存储空间，设置tag</h3><p>定义一个变量 <code>tag</code>，<code>tag = 0</code> —最近进行的是删除操作；<code>tag = 1</code> —最近进行的是插入操作；</p>
<ul>
<li>每次删除操作成功时，都令<code>tag = 0</code>；只有删除操作，才可能导致队空；</li>
<li>每次插入操作成功时，都令<code>tag = 1</code>；只有插入操作，才可能导致队满；</li>
</ul>
<p>队满条件：<code>Q.front == Q.rear &amp;&amp; tag == 1</code></p>
<p>队空条件：<code>Q.front == Q.rear &amp;&amp; tag == 0</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> tag;               <span class="comment">//最近进行的是删除or插入</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="其他出题方法——队尾指针指向队尾元素"><a href="#其他出题方法——队尾指针指向队尾元素" class="headerlink" title="其他出题方法——队尾指针指向队尾元素"></a>其他出题方法——队尾指针指向队尾元素</h3><ul>
<li>判空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(Q.rear + <span class="number">1</span>) % MaxSize == Q.front</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判满<ul>
<li>方案一：牺牲一个存储单元</li>
<li>方案二：增加辅助变量</li>
</ul>
</li>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize; <span class="comment">//后移一位</span></span><br><span class="line">Q.data[Q.rear] = x; </span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bJHGyMSI-1620744230792)(队列顺序实现.PNG)]</p>
<h3 id="3-2-3-队列的链式存储结构"><a href="#3-2-3-队列的链式存储结构" class="headerlink" title="3.2.3 队列的链式存储结构"></a>3.2.3 队列的链式存储结构</h3><ol>
<li>队列的链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>      <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>               <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ol>
<li>链式队列的基本操作——<strong>带头结点</strong></li>
</ol>
<ul>
<li>初始化 &amp; 判空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)     <span class="comment">//也可用 Q.front -&gt; next == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//s作为最后一个结点，指针域指向NULL</span></span><br><span class="line">    Q.rear-&gt;next = s;   <span class="comment">//新结点插入到当前的rear之后</span></span><br><span class="line">    Q.rear = s;         <span class="comment">//表尾指针指向新的表尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>出队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                    <span class="comment">//空队</span></span><br><span class="line">    </span><br><span class="line">    LinkNode *p = Q.front-&gt;next;         <span class="comment">//p指针指向即将删除的结点 (头结点所指向的结点)</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;             <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)                      <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear = Q.front;                <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                             <span class="comment">//释放结点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<ul>
<li>队列满的条件</li>
</ul>
<p>顺序存储：预分配存储空间</p>
<p>链式存储：一般不会队满，除非内存不足</p>
<ul>
<li>计算链队长度 (遍历链队)</li>
</ul>
<p>设置一个<code>int length</code> 记录链式队列长度</p>
<ol>
<li>链式队列的基本操作——<strong>不带头结点</strong></li>
</ol>
<ul>
<li>初始化 &amp; 判空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)     <span class="comment">//也可以用 Q.rear == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素入队时需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front = <span class="literal">NULL</span>)&#123;            <span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;               <span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;           <span class="comment">//新结点插入到rear结点之后</span></span><br><span class="line">        Q.rear = s;                 <span class="comment">//修改rear指针指向新的表尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h3><ol>
<li>定义</li>
</ol>
<ul>
<li>双端队列允许从<strong>两端插入</strong>、<strong>两端删除</strong>的线性表；</li>
<li>如果只使用其中一端的插入、删除操作，则等同于栈；</li>
<li>输入受限的双端队列：允许<strong>一端插入</strong>，<strong>两端删除</strong>的线性表；</li>
<li>输出受限的双端队列：允许<strong>两端插入</strong>，<strong>一端删除</strong>的线性表；</li>
</ul>
<ol>
<li><strong>考点：</strong> 判断输出序列的合法化（视频07）</li>
</ol>
<p><strong>例</strong>: 数据元素输入序列为 <code>1,2,3,4</code>，判断 4!=24 个输出序列的合法性</p>
<p><em>PS: 栈中合法的序列，双端队列中一定也合法</em></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>栈</th>
<th>输入受限的双端队列</th>
<th>输出受限的双端队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>14个合法(卡特兰数)</td>
<td>验证在栈中不合法的序列</td>
<td>验证在栈中不合法的序列</td>
</tr>
<tr>
<td></td>
<td>只有 4213 和 4231 不合法</td>
<td>只有 4132 和 4231 不合法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-3-栈的应用"><a href="#3-3-栈的应用" class="headerlink" title="3.3 栈的应用"></a>3.3 栈的应用</h2><h3 id="3-3-1-栈在括号匹配中的应用"><a href="#3-3-1-栈在括号匹配中的应用" class="headerlink" title="3.3.1 栈在括号匹配中的应用"></a>3.3.1 栈在括号匹配中的应用</h3><p>用栈实现括号匹配</p>
<ul>
<li><code>((()))</code> 最后出现的左括号最先被匹配 (栈的特性—LIFO);</li>
<li>遇到左括号就入栈;</li>
<li>遇到右括号，就“消耗”一个左括号 (出栈);</li>
</ul>
<p>匹配失败情况：</p>
<ul>
<li>扫描到右括号且栈空，则该右括号单身;</li>
<li>扫描完所有括号后，栈非空，则该左括号单身;</li>
<li>左右括号不匹配;</li>
</ul>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UBr5m1ue-1622726764306)(括号匹配.png)]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">InitStack(SqStack &amp;S)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, <span class="type">char</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶元素出栈，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, <span class="type">char</span> &amp;x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack S;      <span class="comment">//声明</span></span><br><span class="line">    InitStack(S);   <span class="comment">//初始化栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            Push(S, str[i]);       <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))      <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//匹配失败</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> topElem;          <span class="comment">//存储栈顶元素</span></span><br><span class="line">            Pop(S, topElem);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StackEmpty(S);                <span class="comment">//栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-栈在表达式求值中的应用"><a href="#3-3-2-栈在表达式求值中的应用" class="headerlink" title="3.3.2 栈在表达式求值中的应用"></a>3.3.2 栈在表达式求值中的应用</h3><h3 id="1-中缀表达式-需要界限符"><a href="#1-中缀表达式-需要界限符" class="headerlink" title="1. 中缀表达式 (需要界限符)"></a><strong>1. 中缀表达式</strong> (需要界限符)</h3><p>运算符在两个操作数中间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① a + b</span><br><span class="line">② a + b - c</span><br><span class="line">③ a + b - c*d</span><br><span class="line">④ ((15 ÷ (7-(1+1)))×3)-(2+(1+1))</span><br><span class="line">⑤ A + B × (C - D) - E ÷ F</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<h3 id="2-后缀表达式-逆波兰表达式"><a href="#2-后缀表达式-逆波兰表达式" class="headerlink" title="2. 后缀表达式 (逆波兰表达式)"></a><strong>2. 后缀表达式</strong> (逆波兰表达式)</h3><p>运算符在两个操作数后面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① a b +</span><br><span class="line">② ab+ c - / a bc- +</span><br><span class="line">③ ab+ cd* -</span><br><span class="line">④ 15 7 1 1 + - ÷ 3 × 2 1 1 + + -</span><br><span class="line">⑤ A B C D - × + E F ÷ - (机算结果)</span><br><span class="line">  A B C D - × E F ÷ - + (不选择)</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>中缀表达式转后缀表达式-手算</strong></li>
</ul>
<p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p>
<p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[左操作数 右操作数 运算符]</code>的方式组合成一个新的操作数</p>
<p><strong>步骤3：</strong> 如果还有运算符没被处理，继续步骤2</p>
<p><strong>“左优先”原则:</strong> 只要左边的运算符能先计算，就优先算左边的 (保证运算顺序唯一)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中缀：A + B - C * D / E + F</span><br><span class="line">       ①   ④   ②   ③   ⑤     </span><br><span class="line">后缀：A B + C D * E / - F +</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<h3 id="重点：中缀表达式转后缀表达式-机算"><a href="#重点：中缀表达式转后缀表达式-机算" class="headerlink" title="重点：中缀表达式转后缀表达式-机算"></a><strong>重点：中缀表达式转后缀表达式-机算</strong></h3><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<strong>从左到右</strong>处理各个元素，直到末尾。可能遇到三种情况:</p>
<ul>
<li>遇到<strong>操作数</strong>: 直接加入后缀表达式。</li>
<li>遇到<strong>界限符</strong>: 遇到 <code>&#39;(&#39;</code> 直接入栈; 遇到 <code>&#39;)&#39;</code> 则依次弹出栈内运算符并加入后缀表达式，直到弹出 <code>&#39;(&#39;</code> 为止。注意: <code>&#39;(&#39;</code> 不加入后缀表达式。</li>
<li>遇到<strong>运算符</strong>: 依次弹出栈中优先级<strong>高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式，若碰到 <code>&#39;(&#39;</code> 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<ul>
<li><strong>后缀表达式的计算—手算:</strong></li>
</ul>
<p>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应的运算，合体为一个操作数；</p>
<p><strong>注意：</strong> 两个操作数的左右顺序</p>
<h3 id="重点：后缀表达式的计算—机算"><a href="#重点：后缀表达式的计算—机算" class="headerlink" title="重点：后缀表达式的计算—机算"></a><strong>重点：后缀表达式的计算—机算</strong></h3><p>用栈实现后缀表达式的计算（栈用来存放当前暂时不能确定运算次序的操作数）</p>
<p><strong>步骤1:</strong> 从左往后扫描下一个元素，直到处理完所有元素;</p>
<p><strong>步骤2:</strong> 若扫描到操作数，则压入栈，并回到<code>步骤1</code>;否则执行<code>步骤3</code>;</p>
<p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压回栈顶，回到<code>步骤1</code>;</p>
<p><strong>注意:</strong> 先出栈的是“右操作数”</p>
<h3 id="3-前缀表达式-波兰表达式"><a href="#3-前缀表达式-波兰表达式" class="headerlink" title="3.前缀表达式 (波兰表达式)"></a><strong>3.前缀表达式</strong> (波兰表达式)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运算符在两个操作数前面:</span><br><span class="line">① + a b</span><br><span class="line">② - +ab  c</span><br><span class="line">③ - +ab *cd</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>中缀表达式转前缀表达式—手算</strong></li>
</ul>
<p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p>
<p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[运算符 左操作数 右操作数]</code>的方式组合成一个新的操作数</p>
<p><strong>步骤3：</strong> 如果还有运算符没被处理，就继续执行<code>步骤2</code></p>
<p><strong>“右优先”原则:</strong> 只要右边的运算符能先计算，就优先算<strong>右边</strong>的;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中缀：A + B * (C - D) - E / F</span><br><span class="line">       ⑤   ③    ②    ④   ①</span><br><span class="line">前缀：+ A - * B - C D / E F</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>前缀表达式的计算—机算</strong></li>
</ul>
<p>用栈实现前缀表达式的计算</p>
<p><strong>步骤1:</strong> 从右往左扫描下一个元素，直到处理完所有元素；</p>
<p><strong>步骤2:</strong> 若扫描到操作数则压入栈，并回到<code>步骤1</code>，否则执行<code>步骤3</code></p>
<p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到<code>步骤1</code>；</p>
<p><strong>注意:</strong> 先出栈的是“左操作数”</p>
<h3 id="4-中缀表达式的计算-用栈实现"><a href="#4-中缀表达式的计算-用栈实现" class="headerlink" title="4.中缀表达式的计算(用栈实现)"></a><strong>4.中缀表达式的计算(用栈实现)</strong></h3><p>两个算法的结合： <a href="#重点中缀表达式转后缀表达式-机算">中缀转后缀</a> + <a href="#重点后缀表达式的计算机算">后缀表达式的求值</a></p>
<ul>
<li>初始化两个栈，<strong>操作数栈</strong> 和<strong>运算符栈</strong></li>
<li>若扫描到操作数，压人操作数栈</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈 (期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈项元素并执行相应运算，运算结果再压回操作数栈)</li>
</ul>
<h3 id="3-3-3-栈在递归中的应用"><a href="#3-3-3-栈在递归中的应用" class="headerlink" title="3.3.3 栈在递归中的应用"></a>3.3.3 栈在递归中的应用</h3><p>函数调用的特点：最后被调用的函数最先执行结束(LIFO)</p>
<p>函数调用时，需要用一个栈存储：</p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
<p>递归调用时，函数调用栈称为 “递归工作栈”:</p>
<ul>
<li>每进入一层递归，就将递归调用所需信息压入栈顶；</li>
<li>每退出一层递归，就从栈顶弹出相应信息；</li>
</ul>
<p><strong>缺点</strong>：太多层递归可能回导致栈溢出；</p>
<p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题；</p>
<h2 id="3-3-队列的应用"><a href="#3-3-队列的应用" class="headerlink" title="3.3 队列的应用"></a>3.3 队列的应用</h2><h3 id="3-3-1-树的层次遍历"><a href="#3-3-1-树的层次遍历" class="headerlink" title="3.3.1 树的层次遍历"></a>3.3.1 树的层次遍历</h3><p><em>（详见“树”章节）</em></p>
<h3 id="3-3-2-图的广度优先遍历"><a href="#3-3-2-图的广度优先遍历" class="headerlink" title="3.3.2 图的广度优先遍历"></a>3.3.2 图的广度优先遍历</h3><p><em>（详见“图”章节）</em></p>
<h3 id="3-3-3-队列在操作系统中的应用"><a href="#3-3-3-队列在操作系统中的应用" class="headerlink" title="3.3.3 队列在操作系统中的应用"></a>3.3.3 队列在操作系统中的应用</h3><p>多个进程争抢着使用优先的系统资源时，FCFS（先来先服务）是一种常用策略</p>
<p>Eg: CPU资源分配、打印数据缓冲区</p>
<h2 id="3-4-特殊矩阵的压缩存储"><a href="#3-4-特殊矩阵的压缩存储" class="headerlink" title="3.4 特殊矩阵的压缩存储"></a>3.4 特殊矩阵的压缩存储</h2><h3 id="3-4-1-数组的存储结构"><a href="#3-4-1-数组的存储结构" class="headerlink" title="3.4.1 数组的存储结构"></a>3.4.1 数组的存储结构</h3><ol>
<li>一维数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elemtype a[10];</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>各数组元素大小相同，物理上连续存放；</p>
<p>起始地址：<code>LOC</code></p>
<p>数组下标：默认从0开始！</p>
<p>数组元素 <code>a[i]</code> 的存放地址 = <code>LOC + i × sizeof(ElemType)</code></p>
<ol>
<li>二维数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elemtype b[2][4]; //2行4列的二维数组</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>行优先/列优先存储优点：实现随机存储</p>
<p>起始地址：<code>LOC</code></p>
<p>M行N列的二维数组 <code>b[M][N]</code> 中，<code>b[i][j]</code>的存储地址：</p>
<ul>
<li>行优先存储: <code>LOC + (i×N + j) × sizeof(ElemType)</code></li>
<li>列优先存储：<code>LOC + (j×M + i) × sizeof(ElemType)</code></li>
</ul>
<h3 id="3-4-2-普通矩阵的存储"><a href="#3-4-2-普通矩阵的存储" class="headerlink" title="3.4.2 普通矩阵的存储"></a>3.4.2 普通矩阵的存储</h3><p>二维数组存储</p>
<ul>
<li>描述矩阵元素时，行、列号通常从<code>1</code>开始；</li>
<li>描述数组时，通常下标从 <code>0</code> 开始；</li>
</ul>
<h3 id="3-4-3-特殊矩阵的存储"><a href="#3-4-3-特殊矩阵的存储" class="headerlink" title="3.4.3 特殊矩阵的存储"></a>3.4.3 特殊矩阵的存储</h3><p><em>特殊矩阵——压缩存储空间</em></p>
<ol>
<li>对称矩阵(方阵)</li>
<li>三角矩阵(方阵)</li>
<li>三对角矩阵(方阵)</li>
<li>稀疏矩阵</li>
</ol>
<ul>
<li>顺序存储——三元组</li>
<li>链式存储——十字链表法</li>
</ul>
<h1 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h1><h2 id="4-1-串的定义和实现"><a href="#4-1-串的定义和实现" class="headerlink" title="4.1 串的定义和实现"></a>4.1 串的定义和实现</h2><h3 id="4-1-1-串的定义"><a href="#4-1-1-串的定义" class="headerlink" title="4.1.1 串的定义"></a>4.1.1 串的定义</h3><ol>
<li>串: 零个或多个字符组成的有限序列，如 <code>S = &#39;iPhone 11 Pro Max?&#39;</code>；</li>
<li>串名：S是串名；</li>
<li>串的长度：串中字符的个数n；</li>
<li>空串：n=0时的串；</li>
<li>子串：串中任意多个连续的字符组成的子序列称为该串的子串；</li>
<li>主串：包含子串的串；</li>
<li>字符在主串中的位置：某个字符在串中的序号（从1开始）；</li>
<li>子串在主串中的位置：子串的第一个字符在主串中的位置；</li>
<li>空串 V.S 空格串：<ul>
<li><code>M = &#39;&#39;</code> 是空串；</li>
<li><code>N = &#39; &#39;</code> 是空格串；</li>
</ul>
</li>
<li>串 V.S 线性表：<ul>
<li>串是特殊的线性表，数据元素之间呈线性关系（逻辑结构相似）；</li>
<li>串的数据对象<strong>限定</strong>为字符集：中文字符、英文字符、数字字符、标点字符…</li>
<li>串的基本操作，如增删改除通常以<strong>子串</strong>为操作对象</li>
</ul>
</li>
</ol>
<h3 id="4-1-2-串的基本操作"><a href="#4-1-2-串的基本操作" class="headerlink" title="4.1.2 串的基本操作"></a>4.1.2 串的基本操作</h3><p>假设有串 <code>T = &#39;&#39;</code>, <code>S = &#39;iPhone 11 Pro Max?&#39;</code>, <code>W = &#39;Pro&#39;</code></p>
<ul>
<li><p><code>StrAssign(&amp;T, chars)</code>: 赋值操作，把串T赋值为chars；</p>
</li>
<li><p><code>StrCopy(&amp;T, S)</code>: 复制操作，把串S复制得到串T；</p>
</li>
<li><p><code>StrEmpty(S)</code>: 判空操作，若S为空串，则返回TRUE，否则返回False；</p>
</li>
<li><p>```<br>StrLength(S)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  : 求串长，返回串S的元素个数；</span><br><span class="line"></span><br><span class="line">  &gt; 返回`length`值</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  ClearString(&amp;S)</span><br></pre></td></tr></table></figure>
<p>: 清空操作，将S清为</p>
<p>空串</p>
<p>；</p>
<blockquote>
<p>将<code>length = 0</code>，逻辑上清空，但是内存中还有</p>
</blockquote>
</li>
<li><p><code>DestroyString(&amp;S)</code>: 销毁串，将串S销毁——<strong>回收存储空间</strong>；</p>
</li>
<li><p>```<br>Concat(&amp;T, S1, S2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  : 串联联接，用T返回由S1和S2联接而成的新串———可能会导致存储空间的扩展；</span><br><span class="line"></span><br><span class="line">  &gt; Concat(&amp;T, S, W)</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; T = ‘iPhone 11 Pro Max?Pro’</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  SubString(&amp;Sub, S, pos, len)</span><br></pre></td></tr></table></figure>
<p>: 求子串，用Sub返回串S的第pos个字符起长度为len的子串；</p>
<blockquote>
<p>SubString(&amp;T, S, 4, 6)</p>
<p>T = ‘one 11’</p>
</blockquote>
</li>
<li><p>```<br>Index(S, T)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  : 定位操作，若主串S中存在与串T值相同的子串，则返回它再主串S中第一次出现的位置，否则函数值为0；</span><br><span class="line"></span><br><span class="line">  &gt; Index(S, T)</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; &gt; 11</span><br><span class="line"></span><br><span class="line">- `StrCompare(S, T)`: 串的比较操作，参照英文词典排序方式；若S &gt; T,返回值&gt;0; S = T,返回值=0 **(需要两个串完全相同)** ; S &lt; T,返回值&lt;0;</span><br><span class="line"></span><br><span class="line">### 拓展：字符集编码</span><br><span class="line"></span><br><span class="line">1. 字符集:</span><br><span class="line">2. 编码方案</span><br><span class="line">3. 乱码问题</span><br><span class="line"></span><br><span class="line">### 4.1.3 串的存储结构</span><br><span class="line"></span><br><span class="line">1. 定长顺序存储表示</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#define MAXLEN 255   //预定义最大串长为255</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXLEN];   //静态数组实现（定长顺序存储）</span><br><span class="line">                       //每个分量存储一个字符</span><br><span class="line">                       //每个char字符占1B</span><br><span class="line">    int length;        //串的实际长度</span><br><span class="line">&#125;SString;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
</li>
<li><p>串长的两种表示法：</p>
<ul>
<li><p>方案一：用一个额外的变量<code>length</code>来存放串的长度（保留<code>ch[0]</code>）；</p>
</li>
<li><p>方案二：用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch[0]</span><br></pre></td></tr></table></figure>
<p>充当</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length</span><br></pre></td></tr></table></figure>
<p>；</p>
<ul>
<li>优点：字符的位序和数组下标相同；</li>
</ul>
</li>
<li><p>方案三：没有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length</span><br></pre></td></tr></table></figure>
<p>变量，以字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;\0&#x27;</span><br></pre></td></tr></table></figure>
<p>表示结尾（对应ASCII码的0）；</p>
<ul>
<li>缺点：需要从头到尾遍历；</li>
</ul>
</li>
<li><p><strong>方案四——最终使用方案：</strong><code>ch[0]</code>废弃不用，声明int型变量<code>length</code>来存放串的长度（方案一与方案二的结合）</p>
</li>
</ul>
</li>
<li><p>基本操作实现（基于方案四）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   </span><br><span class="line">    <span class="type">int</span> length;       </span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos+len<span class="number">-1</span> &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=pos; i&lt;pos+len; i++)</span><br><span class="line">        Sub.cn[i-pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">    </span><br><span class="line">    Sub.length = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 比较两个串的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i; i&lt;S.length &amp;&amp; i&lt;T.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定位操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    n = StrLength(S);</span><br><span class="line">    m = StrLength(T);</span><br><span class="line">    SString sub;        <span class="comment">//用于暂存子串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(Sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(Sub,T)!=<span class="number">0</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> i;    <span class="comment">// 返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;            <span class="comment">//S中不存在与T相等的子串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647</span></span><br></pre></td></tr></table></figure>
<p><em>ps:结合顺序表思考优缺点</em></p>
<ol>
<li>堆分配存储表示</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;           <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S；</span><br><span class="line">S.ch = (<span class="type">char</span> *) <span class="built_in">malloc</span>(MAXLINE * <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">//基地址指针指向连续空间的起始位置</span></span><br><span class="line">                                                <span class="comment">//malloc()需要手动free()</span></span><br><span class="line">S.length;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ol>
<li>串的链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;           <span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>问题：存储密度低，每个字符1B，每个指针4B；<br>解决方案：每一个链表的结点存储多个字符——每个结点称为块——块链结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];           <span class="comment">//每个结点存多个个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><em>ps:结合链表思考优缺点</em></p>
<ul>
<li>存储分配角度：链式存储的字符串无需占用连续空间，存储空间分配更灵活；</li>
<li>操作角度：若要在字符串中插入或删除某些字符，则顺序存储方式需要移动大量字符，而链式存储不用；</li>
<li>若要按位序查找字符，则顺序存储支持随机访问，而链式存储只支持顺序访问；</li>
</ul>
<h2 id="4-2-串的模式匹配"><a href="#4-2-串的模式匹配" class="headerlink" title="4.2 串的模式匹配"></a>4.2 串的模式匹配</h2><h3 id="4-2-1-朴素模式匹配算法"><a href="#4-2-1-朴素模式匹配算法" class="headerlink" title="4.2.1 朴素模式匹配算法"></a>4.2.1 朴素模式匹配算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;                <span class="comment">//扫描主串S</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;                <span class="comment">//扫描模式串T</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;             <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;             <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析：</strong></p>
<ul>
<li><p>主串长度为n，模式串长度为m</p>
</li>
<li><p>最多比较<code>n-m+1</code>个子串</p>
</li>
<li><p>最坏时间复杂度 =</p>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(nm)</span><br></pre></td></tr></table></figure>
<ul>
<li>每个子串都要对比m个字符(对比到最后一个字符才匹配不上)，共要对比n-m+1个子串，复杂度 = <code>O((n-m+1)m) = O(nm - m^2 + m) = O(nm)</code></li>
<li><em>PS:大多数时候，n&gt;&gt;m</em></li>
</ul>
<ul>
<li>最好时间复杂度 =</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n)</span><br></pre></td></tr></table></figure>
<ul>
<li>每个子串的第一个字符就匹配失败，共要对比n-m+1个子串，复杂度 = <code>O(n-m+1) = O(n)</code></li>
</ul>
<h3 id="4-2-2-改进的模式匹配算法——KMP算法"><a href="#4-2-2-改进的模式匹配算法——KMP算法" class="headerlink" title="4.2.2 改进的模式匹配算法——KMP算法"></a>4.2.2 改进的模式匹配算法——KMP算法</h3><ul>
<li><p>不匹配的字符之前，一定是和模式串一致的；</p>
</li>
<li><p>根据模式串T，求出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next数组</span><br></pre></td></tr></table></figure>
<p>（只与模式串有关，与主串无关），利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next数组</span><br></pre></td></tr></table></figure>
<p>进行匹配，</p>
<p>当匹配失败时，主串的指针 <code>i</code> 不再回溯！</p>
<blockquote>
<p>当第一个元素匹配失败时，匹配下一个相邻子串，令<code>j=0,i++,j++</code></p>
</blockquote>
</li>
</ul>
<ol>
<li>求<code>next数组</code>（会手算即可）</li>
</ol>
<ul>
<li>作用：当模式串的第<code>j</code>个字符失配时，从模式串的第<code>next[j]</code>继续往后匹配;</li>
<li>对于任何模式串，当第1个字符不匹配时，只能匹配下一个子串，因此，<code>next[1] = 0</code>——表示模式串应右移一位，主串当前指针后移一位，再和模式串的第一字符进行比较；</li>
<li>对于任何模式串，当第2个字符不匹配时，应尝试匹配模式串的第一个字符，因此，<code>next[2] = 0</code>;</li>
</ul>
<p>例：对于串 <code>T = &#39;abaabc&#39;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>next[0]</th>
<th>next[1]</th>
<th>next[2]</th>
<th>next[3]</th>
<th>next[4]</th>
<th>next[5]</th>
<th>next[6]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>利用<code>next数组</code>进行模式匹配</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;     <span class="comment">//主串</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;     <span class="comment">//模式串</span></span><br><span class="line">    <span class="keyword">while</span>（i&lt;S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j])&#123;      <span class="comment">//第一个元素匹配失败时</span></span><br><span class="line">            ++j;</span><br><span class="line">            ++i;         <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j]   <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length; <span class="comment">//匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 时间复杂度分析：</strong></p>
<ul>
<li>求next数组时间复杂度 = <code>O(m)</code></li>
<li>模式匹配过程最坏时间复杂度 = <code>O(n)</code></li>
<li>KMP算法的最坏时间复杂度 = <code>O(m+n)</code></li>
</ul>
<h3 id="4-2-3-KMP算法的进一步优化"><a href="#4-2-3-KMP算法的进一步优化" class="headerlink" title="4.2.3 KMP算法的进一步优化"></a>4.2.3 KMP算法的进一步优化</h3><h1 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h1><h2 id="5-1-树的基本概念"><a href="#5-1-树的基本概念" class="headerlink" title="5.1 树的基本概念"></a>5.1 树的基本概念</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><ul>
<li>空树</li>
<li>根结点、分支结点、叶子结点</li>
<li>非空树的特性</li>
<li>子树</li>
</ul>
<h3 id="5-1-2-基本术语"><a href="#5-1-2-基本术语" class="headerlink" title="5.1.2 基本术语"></a>5.1.2 基本术语</h3><ol>
<li>结点之间的关系描述<ul>
<li>祖先、子孙、双亲、兄弟…结点</li>
<li><strong>路径、路径长度</strong></li>
</ul>
</li>
<li>结点、树的属性描述<ul>
<li>结点的层次（深度）——从上往下</li>
<li>结点的高度——从下往上</li>
<li>树的高度——总共多少层</li>
<li><strong>结点的度</strong>——有几个孩子</li>
<li><strong>树的度</strong>——各结点的度的最大值</li>
</ul>
</li>
<li>有序树、无序树</li>
<li>森林</li>
</ol>
<h3 id="5-1-3-树的性质"><a href="#5-1-3-树的性质" class="headerlink" title="5.1.3 树的性质"></a>5.1.3 树的性质</h3><ol>
<li>结点数 = 总度数 + 1</li>
<li>度为<code>m</code>的数、<code>m</code>叉数的区别</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>度为 <code>m</code> 的树</th>
<th><code>m</code> 叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>树的度：<code>m</code>为各结点的度的最大值</td>
<td><code>m</code>叉树：每个结点最多只能有 <code>m</code> 个孩子的树</td>
</tr>
<tr>
<td>任意结点的度 ≦ m</td>
<td>任意结点的度 ≦ m</td>
</tr>
<tr>
<td>至少有一个结点度 = m</td>
<td>允许所有结点的度 &lt; m</td>
</tr>
<tr>
<td>一定是非空树，至少有m+1个结点</td>
<td>可以是空树</td>
</tr>
<tr>
<td>第i层至多有 <code>m^(i-1)</code>个结点</td>
<td>第i层至多有 <code>m^(i-1)</code>个结点</td>
</tr>
<tr>
<td>高度为<code>h</code>、度为 <code>m</code> 的树至少有<code>h+m-1</code>个结点</td>
<td>高度为<code>h</code>的<code>m</code>叉树至多有<code>(m^h-1)/(m-1)</code>个结点；至少有<code>h</code>个结点</td>
</tr>
<tr>
<td></td>
<td>具有<code>n</code>个结点的<code>m</code>叉树，最小高度为<code>⌈ logm(n(m-2)+1)⌉</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-2-二叉树的概念"><a href="#5-2-二叉树的概念" class="headerlink" title="5.2 二叉树的概念"></a>5.2 二叉树的概念</h2><h3 id="5-2-1-二叉树的定义与特性"><a href="#5-2-1-二叉树的定义与特性" class="headerlink" title="5.2.1 二叉树的定义与特性"></a>5.2.1 二叉树的定义与特性</h3><ol>
<li>二叉树有左右之分，次序不能颠倒</li>
</ol>
<h3 id="5-2-2几种特殊的二叉树"><a href="#5-2-2几种特殊的二叉树" class="headerlink" title="5.2.2几种特殊的二叉树"></a>5.2.2几种特殊的二叉树</h3><ol>
<li>满二叉树</li>
<li>完全二叉树</li>
<li>二叉排序树</li>
<li>平衡二叉树</li>
</ol>
<h3 id="5-2-3-二叉树的存储结构"><a href="#5-2-3-二叉树的存储结构" class="headerlink" title="5.2.3 二叉树的存储结构"></a>5.2.3 二叉树的存储结构</h3><ol>
<li>顺序存储</li>
</ol>
<p>二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p><strong>考点：</strong></p>
<ul>
<li><code>i</code>的左孩子：<code>2i</code></li>
<li><code>i</code>的右孩子：<code>2i + 1</code></li>
<li><code>i</code>的父节点：<code>⌊i/2⌋</code></li>
<li><code>i</code>所在的层次：<code>⌊log2n + 1⌋</code> or <code>⌈ log2n+1)⌉</code></li>
</ul>
<p><strong>若完全二叉树中共有n个结点</strong>（非完全二叉树不能用）</p>
<ul>
<li>判断<code>i</code>是否有左孩子：<code>2i ≦ n</code></li>
<li>判断<code>i</code>是否有右孩子：<code>2i+1 ≦ n</code></li>
<li>判断<code>i</code>是否时叶子/分支结点：<code>i &gt; ⌊n/2⌋</code></li>
</ul>
<p><strong>最坏情况：</strong> 高度为h且只有h个结点的单支树（所有结点只有右孩子），也至少需要2^h-1个存储单元；</p>
<p><strong>结论：</strong> 二叉树的顺序存储结构，只适合存储完全二叉树和满二叉树</p>
<ol>
<li>链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root -&gt; data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p -&gt; data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">p -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; lchild = p; <span class="comment">//作为根节点的左孩子</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>
<ul>
<li>找到指定结点p的左/右孩子；</li>
<li>找到指定节点p的父结点: 只能从根结点开始遍历，也可以使用<strong>三叉链表</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>          <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<ul>
<li>n个结点的二叉链表共有n+1个空链域</li>
</ul>
<h2 id="5-3-二叉树的遍历和线索二叉树"><a href="#5-3-二叉树的遍历和线索二叉树" class="headerlink" title="5.3 二叉树的遍历和线索二叉树"></a>5.3 二叉树的遍历和线索二叉树</h2><h3 id="5-3-1-二叉树的遍历"><a href="#5-3-1-二叉树的遍历" class="headerlink" title="5.3.1 二叉树的遍历"></a>5.3.1 二叉树的遍历</h3><ol>
<li>先序遍历（根左右）</li>
</ol>
<ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p><strong>空间复杂度：</strong> O(h)</p>
<ol>
<li>中序遍历（左根右）</li>
</ol>
<ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>先序遍历左子树</li>
<li>访问根节点</li>
<li>先序遍历右子树</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      InOrder(T-&gt;lchild);       <span class="comment">//递归遍历左子树</span></span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">      InOrder(T-&gt;rchild);       <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<ol>
<li>后续遍历（左右根）</li>
</ol>
<ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
<li>访问根节点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTnode</span>&#123;</span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild; </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">PostOrder</span>(T-&gt;lchild);       <span class="comment">//递归遍历左子树    </span></span><br><span class="line">      <span class="built_in">PostOrder</span>(T-&gt;rchild);       <span class="comment">//递归遍历右子树</span></span><br><span class="line">      <span class="built_in">visit</span>(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树的层次遍历</li>
</ol>
<p>算法思想：</p>
<ul>
<li>初始化一个辅助队列</li>
<li>根节点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，依次将其左、右孩子插入队尾（如果有的话）</li>
<li>重复以上操作直至队列为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">   BiTNode * data;</span><br><span class="line">   <span class="keyword">typedef</span> LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   LinkNode *front, *rear;  </span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue (Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<ol>
<li>由遍历序列构造二叉树</li>
</ol>
<ul>
<li>先序序列 + 中序序列</li>
<li>后序序列 + 中序序列</li>
<li>层序序列 + 中序序列</li>
</ul>
<p><strong>key:</strong> 找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点、</p>
<h3 id="5-3-2-线索二叉树"><a href="#5-3-2-线索二叉树" class="headerlink" title="5.3.2 线索二叉树"></a>5.3.2 线索二叉树</h3><ol>
<li>线索二叉树的概念与作用</li>
<li>线索二叉树的存储结构</li>
</ol>
<ul>
<li>中序线索二叉树——线索指向中序前驱、中序后继</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>tag == 0: 指针指向孩子</p>
<p>tag == 1: 指针是“线索”</p>
</blockquote>
<ul>
<li>先序线索二叉树——线索指向先序前驱、先序后继</li>
<li>后序线索二叉树——线索指向后序前驱、后序后继</li>
</ul>
<ol>
<li>二叉树的线索化</li>
</ol>
<ul>
<li>中序线索化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);    <span class="comment">//中序遍历左子树</span></span><br><span class="line">        visit(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        InThread(T-&gt;rchild);    <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      InThread(T);            <span class="comment">//中序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先序线索化</li>
</ul>
<p><em>注意【转圈】问题，当<code>ltag==0</code>时，才能对左子树先序线索化</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);</span><br><span class="line">      <span class="keyword">if</span>(T-&gt;ltag == <span class="number">0</span>)         <span class="comment">//lchild不是前驱线索</span></span><br><span class="line">         PreThread(T-&gt;lchild);</span><br><span class="line">      PreThread(T-&gt;rchild);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PreThread(T);            <span class="comment">//先序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>
<ul>
<li>后序线索化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      PostThread(T-&gt;lchild);</span><br><span class="line">      PostThread(T-&gt;rchild);</span><br><span class="line">      visit(T);                  <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PostThread(T);            <span class="comment">//后序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>
<ol>
<li>线索二叉树中找前驱、后继</li>
</ol>
<ul>
<li><p>中序线索二叉树找中序后继：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 则 next = p的右子树中最左下结点;</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最左下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//右子树最左下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p!=<span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度 = O(1)</p>
<ul>
<li><p>中序线索二叉树找中序前驱：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序前驱 <code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子, 则 next = p的左子树中最右下结点;</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最右下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;rchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//左子树最右下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//rtag==1，直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p!=<span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>先序线索二叉树找先序后继：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子（左孩子不知道）</p>
<blockquote>
<p>case1: 若p有左孩子 ——— 根 <strong>左</strong> 右 / 根 (<strong>根</strong> 左 右) 右</p>
<p>case2: 若p没有左孩子 ——— 根 <strong>右</strong> / 根 (<em>*根</em> *左 右)</p>
</blockquote>
</blockquote>
</li>
<li><p>先序线索二叉树找先序前驱：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序前驱<code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找p的先序前驱，（除非从头开始遍历/三叉链表</p>
<blockquote>
<p>case1: 如果能够找到p的父节点，且p是左孩子 —— p的父节点就是p的前驱；</p>
<p>case2: 如果能够找到p的父节点，且p是右孩子，且其左兄弟为空 —— p的父节点就是p的前驱；</p>
<p>case3: 如果能够找到p的父节点，且p是右孩子，且其左兄弟非空 —— p的前驱为左兄弟子树中最后一个被先序遍历到的结点（根节点出发，先往右，右没有往左，找到最下一层的结点）；</p>
<p>case4: p没有父节点，即p为根节点，则p没有先序前驱</p>
</blockquote>
</blockquote>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YjVVJjtQ-1623943811481)(先序线索二叉树找先序前驱.PNG)]</p>
</li>
<li><p>后序线索二叉树找后序前驱：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序前驱<code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子（不知道有没有右孩子）</p>
<blockquote>
<p>case1: 若p有右孩子 ——— 左 <strong>右</strong> 根 / 左 (左 右 <strong>根</strong>) 根</p>
<p>case2: 若p没有右孩子 ——— <strong>左</strong> 根 （左子树按后序遍历，最后一个结点，p的左孩子）</p>
</blockquote>
</blockquote>
</li>
<li><p>后序线索二叉树找后序后继：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序后继<code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非从头开始遍历/三叉链表</p>
<blockquote>
<p>case1: 如果能找到p的父节点，且p是右孩子 —— p的父节点即为其后继</p>
<p>case2: 如果能找到p的父节点，且p是左孩子，其右兄弟为空 —— p的父节点即为其后继</p>
<p>case3: 如果能找到p的父节点，且p是左孩子，其右兄弟非空 —— p的后继为其右兄弟子树中第一个被后序遍历的结点；</p>
<p>case4: p没有父节点，即p为根节点，则p没有后序后继；</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>中序线索二叉树</th>
<th>先序线索二叉树</th>
<th>后续线索二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>找前驱</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>找后继</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-4-树、森林"><a href="#5-4-树、森林" class="headerlink" title="5.4 树、森林"></a>5.4 树、森林</h2><h3 id="5-4-1-树的存储结构"><a href="#5-4-1-树的存储结构" class="headerlink" title="5.4.1 树的存储结构"></a>5.4.1 树的存储结构</h3><ol>
<li>双亲表示法(顺序存储)：每个结点中保存指向双亲的指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100  <span class="comment">//树中最多结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>      <span class="comment">//树的结点定义</span></span><br><span class="line">   ElemType data; </span><br><span class="line">   <span class="type">int</span> parent;      <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的类型定义</span></span><br><span class="line">   PTNode nodes[MAX_TREE_SIZE];   <span class="comment">//双亲表示</span></span><br><span class="line">   <span class="type">int</span> n;                         <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<ul>
<li>增：新增数据元素，无需按逻辑上的次序存储；（需要更改结点数<code>n</code>）</li>
<li>删（叶子结点）：① 将伪指针域设置为<code>-1</code>；②用后面的数据填补；（需要更改结点数<code>n</code>）</li>
<li>查询：①优点-查指定结点的双亲很方便；②缺点-查指定结点的孩子只能从头遍历，空数据导致遍历更慢；</li>
</ul>
<ol>
<li>孩子表示法(顺序+链式)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> child;    <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>    <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">   <span class="type">int</span> n, r;   <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<ol>
<li>孩子兄弟表示法（链式）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">   ElemType data;                               <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>     <span class="comment">//第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针</span></span><br><span class="line">&#125;CSNode. *CSTree;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-树、森林与二叉树的转换"><a href="#5-4-2-树、森林与二叉树的转换" class="headerlink" title="5.4.2 树、森林与二叉树的转换"></a>5.4.2 树、森林与二叉树的转换</h3><p>本质：森林中各个树的根节点之间视为兄弟关系</p>
<h3 id="5-4-3-树、森林的遍历"><a href="#5-4-3-树、森林的遍历" class="headerlink" title="5.4.3 树、森林的遍历"></a>5.4.3 树、森林的遍历</h3><ol>
<li>树的遍历</li>
</ol>
<ul>
<li>先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历；（与对应二叉树的先序遍历序列相同）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PreOrder(T);      <span class="comment">//先跟遍历下一个子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<ul>
<li>后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再返回根节点；（与对应二叉树的中序遍历序列相同）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PostOrder(T);      <span class="comment">//后跟遍历下一个子树</span></span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<ul>
<li>层序遍历（队列实现）：<ul>
<li>若树非空，则根结点入队；</li>
<li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；</li>
<li>重复以上操作直至队尾为空；</li>
</ul>
</li>
</ul>
<ol>
<li>森林的遍历</li>
</ol>
<ul>
<li>先序遍历：等同于依次对各个树进行<strong>先根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>先序遍历</strong>；</li>
<li>中序遍历：等同于依次对各个树进行<strong>后根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>中序遍历</strong>；</li>
</ul>
<h2 id="5-5-树与二叉树的应用"><a href="#5-5-树与二叉树的应用" class="headerlink" title="5.5 树与二叉树的应用"></a>5.5 树与二叉树的应用</h2><h3 id="5-5-1-二叉排序树（BST）"><a href="#5-5-1-二叉排序树（BST）" class="headerlink" title="5.5.1 二叉排序树（BST）"></a>5.5.1 二叉排序树（BST）</h3><ol>
<li>二叉排序树的定义</li>
</ol>
<p>左子树结点值&lt;跟结点值&lt;右子树结点值</p>
<ol>
<li>查找操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（非递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(1)</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;key)&#123;        <span class="comment">//若树空或等于跟结点值，则结束循环</span></span><br><span class="line">      <span class="keyword">if</span>(key&lt;T-&gt;key)       <span class="comment">//值小于根结点值，在左子树上查找</span></span><br><span class="line">         T = T-&gt;lchild;</span><br><span class="line">      <span class="keyword">else</span>                  <span class="comment">//值大于根结点值，在右子树上查找</span></span><br><span class="line">         T = T-&gt;rchild;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)</span></span><br><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(Kry == T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;lchild, key);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>
<ol>
<li>插入操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中插入关键字为k的新结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;           <span class="comment">//原树为空，新插入的结点为根结点</span></span><br><span class="line">      T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">      T-&gt;key = k;</span><br><span class="line">      T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">//插入成功</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(K == T-&gt;key)               <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)                 </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<ol>
<li>二叉排序树的构造</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Crear_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">   T = <span class="literal">NULL</span>;                     <span class="comment">//初始时T为空树</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">      BST_Insert(T,str[i]);     <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<ol>
<li>删除操作</li>
<li>查找效率分析</li>
</ol>
<ul>
<li>查找长度：查找运算中，需要对比关键字的次数，反映了查找操作时间复杂度；</li>
<li>查找成功的平均查找长度<code>ASL</code></li>
<li>查找失败的平均查找长度<code>ASL</code></li>
</ul>
<h3 id="5-5-2-平衡二叉树（AVL）"><a href="#5-5-2-平衡二叉树（AVL）" class="headerlink" title="5.5.2 平衡二叉树（AVL）"></a>5.5.2 平衡二叉树（AVL）</h3><ol>
<li>平衡二叉树的定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;         <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> balance;     <span class="comment">//平衡因子</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>;</span> *rchild; </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<ol>
<li>平衡二叉树的插入</li>
<li>插入新节点后如何调整“不平衡”问题</li>
</ol>
<p>调整最小不平衡子树</p>
<ul>
<li>LL:</li>
</ul>
<p>  在A结点的左孩子的左子树中插入导致不平衡</p>
<ul>
<li>调整： A的左孩子结点右上旋</li>
</ul>
<ul>
<li>RR:</li>
</ul>
<p>  在A结点的右孩子的右子树中插入导致不平衡</p>
<ul>
<li>调整： A的右孩子结点左上旋</li>
</ul>
<ul>
<li>LR:</li>
</ul>
<p>  在A结点的左孩子的右子树中插入导致不平衡</p>
<ul>
<li>调整： A的左孩子的右孩子，先左上旋再右上旋</li>
</ul>
<ul>
<li>RL:</li>
</ul>
<p>  在A结点的右孩子的左子树中插入导致不平衡</p>
<ul>
<li>调整： A的右孩子的左孩子，先右上旋再左上旋</li>
</ul>
<ol>
<li>平衡二叉树的查找与效率分析</li>
</ol>
<p>若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过<code>O(h)</code>;</p>
<h3 id="5-5-3-哈夫曼树"><a href="#5-5-3-哈夫曼树" class="headerlink" title="5.5.3 哈夫曼树"></a>5.5.3 哈夫曼树</h3><ol>
<li>带权路径长度</li>
<li>哈夫曼树的定义</li>
<li>哈夫曼树的构造（重点）</li>
<li>哈杜曼编码（重点）</li>
</ol>
<h1 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h1><h1 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h1><h1 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h1><h2 id="8-1-排序的基本概念"><a href="#8-1-排序的基本概念" class="headerlink" title="8.1 排序的基本概念"></a>8.1 排序的基本概念</h2><ol>
<li>排序：重新排列表中的元素，使表中元素满足按关键字有序的过程（关键字可以相同）</li>
<li>排序算法的评价指标：时间复杂度、空间复杂度；</li>
<li>排序算法的稳定性：关键字相同的元素在排序之后相对位置不变，称为稳定的；（选择题考查）<br><strong>Q：</strong> 稳定的排序算法一定比不稳定的好？<br><strong>A：</strong> 不一定，要看实际需求；</li>
<li>排序算法的分类：<br><strong>内部排序：</strong> 数据都在内存——关注如何使时间、空间复杂度更低；<br><strong>外部排序：</strong> 数据太多，无法全部放入内存——关注如何使时间、空间复杂度更低，如何使读/写磁盘次数更少；</li>
</ol>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">美国旧金山大学-可视化学习网站</a></p>
<h2 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h2><h3 id="8-2-1-直接插入排序"><a href="#8-2-1-直接插入排序" class="headerlink" title="8.2.1 直接插入排序"></a>8.2.1 直接插入排序</h3><ol>
<li><strong>算法思想：</strong> 每次将一个待排序的记录按其关键字大小，插入（依次对比、移动）到前面已经排好序的子序列中，直到全部记录插入完成</li>
<li><strong>代码实现：</strong></li>
</ol>
<ul>
<li>不带“哨兵”</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;    <span class="comment">//A中共n个数据元素</span></span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;    <span class="comment">//A[i]关键字小于前驱</span></span><br><span class="line">            temp = A[i];  </span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; --j)</span><br><span class="line">                A[j<span class="number">-1</span>] = A[j];     <span class="comment">//所有大于temp的元素都向后挪</span></span><br><span class="line">            A[j+<span class="number">1</span>] = temp;         <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ul>
<li>带“哨兵” ，优点：不用每轮循环都判断<code>j&gt;=0</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;    <span class="comment">//A中从1开始存储，0放哨兵</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;    </span><br><span class="line">            A[<span class="number">0</span>] = A[i];     <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)  <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];     <span class="comment">//向后挪动</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];          <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：主要来自于对比关键字、移动关键字，若有n个元素，则需要n-1躺处理<ul>
<li><strong>最好情况：</strong> 原本为有序，共n-1趟处理，每一趟都只需要对比1次关键字，不需要移动元素，共对比n-1次 —— <strong>O(n)</strong></li>
<li><strong>最差情况：</strong> 原本为逆序 —— O(n²)</li>
<li><strong>平均情况：</strong> O(n²)</li>
</ul>
</li>
<li>算法稳定性：稳定</li>
</ul>
<ol>
<li><strong>对链表进行插入排序</strong></li>
</ol>
<ul>
<li>移动元素的次数变少了，因为只需要修改指针，不需要依次右移；</li>
<li>但是关键字对比的次数依然是<strong>O(n²)\</strong>数量级，因此整体看来*<em>时间复杂度仍然是O(n²)*</em></li>
</ul>
<h3 id="8-2-2-折半插入排序"><a href="#8-2-2-折半插入排序" class="headerlink" title="8.2.2 折半插入排序"></a>8.2.2 折半插入排序</h3><ol>
<li><strong>思路：</strong> 先用折半查找找到应该插入的位置，再移动元素；</li>
<li>为了保证稳定性，当查找到和插入元素关键字一样的元素时，应该继续在这个元素的右半部分继续查找以确认位置; 即当 <code>A[mid] == A[0]</code> 时，应继续在mid所指位置右边寻找插入位置</li>
<li>当<code>low&gt;high</code>时，折半查找停止，应将[low,i-1]or[high+1,i-1]内的元素全部右移，并将A[0]复制到low所指的位置；</li>
<li><strong>代码实现</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123; </span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];                    <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;            <span class="comment">//折半查找的范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;               <span class="comment">//折半查找</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;       <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])             <span class="comment">//查找左半子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//查找右半子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;high+<span class="number">1</span>;--j)       <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        A[high+<span class="number">1</span>] = A[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>
<ol>
<li>与<code>直接插入排序</code>相比，比较关键字的次数减少了，但是移动元素的次数没有变，<strong>时间复杂度仍然是O(n²)</strong></li>
</ol>
<h3 id="8-2-3-希尔排序"><a href="#8-2-3-希尔排序" class="headerlink" title="8.2.3 希尔排序"></a>8.2.3 希尔排序</h3><ol>
<li><strong>思路：</strong> 先追求表中元素的部分有序，再逐渐逼近全局有序；</li>
<li>更适用于基本有序的排序表和数据量不大的排序表，<strong>仅适用于线性表为顺序存储的情况</strong></li>
<li><strong>代码实现：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//A[0]为暂存单元</span></span><br><span class="line">    <span class="keyword">for</span>(dk=n/<span class="number">2</span>; dk&gt;=<span class="number">1</span>; dk=dk/<span class="number">2</span>)   <span class="comment">//步长递减（看题目要求，一般是1/2</span></span><br><span class="line">        <span class="keyword">for</span>(i=dk+<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-dk])&#123;</span><br><span class="line">                A[<span class="number">0</span>]=A[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-dk; j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=dk)</span><br><span class="line">                    A[j+dk]=A[j];         <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+dk]=A[<span class="number">0</span>;]             <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间效率：空间复杂度=<strong>O(1)</strong></li>
<li>时间效率: 最坏情况下时间复杂度=<strong>O(n²)</strong></li>
<li>稳定性：希尔排序是一种<strong>不稳定</strong>的排序方法</li>
</ul>
<h2 id="8-3-交换排序"><a href="#8-3-交换排序" class="headerlink" title="8.3 交换排序"></a>8.3 交换排序</h2><p><strong>基于“交换”的排序：</strong>根据序列中两个元素关键字的比较结果来对换这两个记录再序列中的位置；</p>
<h3 id="8-3-1-冒泡排序"><a href="#8-3-1-冒泡排序" class="headerlink" title="8.3.1 冒泡排序"></a>8.3.1 冒泡排序</h3><ol>
<li>第一趟排序使关键字值最小的一个元素“冒”到最前面（其最终位置）—— <strong>每趟冒泡的结果是把序列中最小元素放到序列的最终位置，这样最多做<code>n-1</code>趟冒泡就能把所有元素排好序</strong>；</li>
<li>为保证稳定性，关键字相同的元素不交换；</li>
<li><strong>代码实现</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;   <span class="comment">//从0开始存放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i; j--) <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;      <span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);  <span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;       <span class="comment">//本趟遍历后没有发生交换，说明表已经有序，可以结束算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间复杂度：<strong>O(1)</strong></li>
<li>时间复杂度<ul>
<li>最好情况 (有序) ：只需要一趟排序，比较次数=n-1，交换次数=0，最好时间复杂度=O(n)</li>
<li>最坏情况 (逆序) ：比较次数 = <code>(n-1)+(n-2)+...+1 = n(n-1)/2</code> = 交换次数，最坏时间复杂度 = O(n²)，平均时间复杂度 = O(n²)</li>
</ul>
</li>
</ul>
<ol>
<li>冒泡排序可以用于链表、顺序表</li>
</ol>
<h3 id="8-3-2-快速排序"><a href="#8-3-2-快速排序" class="headerlink" title="8.3.2 快速排序"></a>8.3.2 快速排序</h3><ol>
<li>每一趟排序都可使一个<strong>中间元素确定其最终位置</strong></li>
<li>用一个元素（不一定是第一个）把待排序序列“划分”为两个部分，左边更小，右边更大，该元素的最终位置已确认</li>
<li>算法实现（重点）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分为左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];          <span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high; <span class="comment">//high所指元素大于枢轴，high左移</span></span><br><span class="line">        A[low] = A[high];   <span class="comment">//high所指元素小于枢轴，移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot)  ++low; <span class="comment">//low所指元素小于枢轴，low右移</span></span><br><span class="line">        A[high] = A[low];   <span class="comment">//low所指元素大于枢轴，移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot   <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low；     <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> QuickSort(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)   <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos = Partition(A, low, high);   <span class="comment">//划分</span></span><br><span class="line">        QuickSort（A, low, pivotpos - <span class="number">1</span>);    <span class="comment">//划分左子表</span></span><br><span class="line">        QuickSort（A, pivotpos + <span class="number">1</span>, high);   <span class="comment">//划分右子表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>每一层的<code>QuickSort</code>只需要处理剩余的待排序元素，时间复杂度不超过O(n);</li>
<li></li>
<li>把n个元素组织成二叉树，二叉树的层数就是递归调用的层数，n个结点的二叉树<strong>最小高度</strong> = <code>⌊log₂n⌋ + 1</code>, <strong>最大高度</strong> = <code>n</code></li>
<li><strong>时间复杂度 = O(n×递归层数)</strong> （递归层数最大为n）<ul>
<li>最好 = <code>O(nlog₂n)</code> : 每次选的枢轴元素都能将序列划分成均匀的两部分；</li>
<li>最坏 = <code>O(n²)</code> ：序列本就有序或逆序，此时时间、空间复杂度最高；</li>
<li>平均时间复杂度 = <code>O(nlog₂n)</code> （接近最好而不是最坏）</li>
</ul>
</li>
<li><strong>空间复杂度 = O(递归层数)</strong>（递归层数最小为log₂n）<ul>
<li>最好 = <code>O(log₂n)</code></li>
<li>最坏 = <code>O(n)</code></li>
</ul>
</li>
<li>若每一次选中的“枢轴”可以将待排序序列划分为<strong>均匀</strong>的两个部分，则递归深度最小，算法效率最高；</li>
<li>若初始序列本就<strong>有序或者逆序</strong>,则快速排序的性能最差；</li>
<li><strong>快速排序算法优化思路：</strong> 尽量选择可以把数据中分的枢轴元素<ul>
<li>选头、中、尾三个位置的元素，取中间值作为枢轴元素；</li>
<li>随机选一个元素作为枢轴元素；</li>
</ul>
</li>
<li>快速排序使所有内部排序算法中平均<strong>性能最优</strong>的排序算法；</li>
<li><strong>稳定性：</strong> 不稳定；</li>
</ul>
<h2 id="8-4-选择排序"><a href="#8-4-选择排序" class="headerlink" title="8.4 选择排序"></a>8.4 选择排序</h2><p><strong>选择排序思想：</strong> 每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列；</p>
<h3 id="8-4-1-简单选择排序"><a href="#8-4-1-简单选择排序" class="headerlink" title="8.4.1 简单选择排序"></a>8.4.1 简单选择排序</h3><ol>
<li><code>n</code>个元素的简单选择排序需要<code>n-1</code>趟处理；</li>
<li>代码实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;       <span class="comment">//A从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;          <span class="comment">//一共进行n-1趟，i指向待排序序列中第一个元素</span></span><br><span class="line">        <span class="type">int</span> min = i;                   <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)       <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min]) min = j;   <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i)                     </span><br><span class="line">            swao(A[i],A[min]);         <span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li><strong>空间复杂度</strong> = <code>O(1)</code></li>
<li>无论有序、逆序、乱序，都需要n-1的处理，总共需要<strong>对比关键字</strong> <code>(n-1)+(n-2)+...+1 = n(n-2)/2</code> 次，元素<strong>交换次数</strong> &lt; <code>n-1</code>; <strong>时间复杂度</strong> = <code>O(n²)</code></li>
<li><strong>稳定性：</strong> 不稳定</li>
<li><strong>适用性：</strong> 既可以用于顺序表，也可以用于链表；</li>
</ul>
<h3 id="8-4-2-堆排序"><a href="#8-4-2-堆排序" class="headerlink" title="8.4.2 堆排序"></a>8.4.2 堆排序</h3><ol>
<li><strong>什么是“堆（Heap）”？</strong></li>
</ol>
<p>可理解为顺序存储的二叉树，注意</p>
<blockquote>
<p>可以将堆视为一棵 <strong>完全二叉树</strong> (✔)</p>
<p>可以将堆视为一棵 <strong>二叉排序树</strong> (✖)</p>
</blockquote>
<ul>
<li>大根堆：完全二叉树中，根 ≥ 左、右</li>
<li>小根堆：完全二叉树中，根 ≤ 左、右</li>
</ul>
<ol>
<li><strong>如何基于“堆”进行排序</strong></li>
</ol>
<p>基本思路：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列，<strong>堆顶元素的关键字最大或最小</strong> （以下以大根堆为例）</p>
<p>① 将给定初始序列(n个元素)，<strong>建立初始大根堆</strong>：把所有<strong>非终端结点</strong> <strong>从后往前</strong>都检查一遍，是否满足大根堆的要求——<code>根 ≥ 左、右</code>，若不满足，则将当前结点与更大的孩子互换</p>
<ul>
<li>在顺序存储的完全二叉树中:<ul>
<li>非终端结点的编号 <code>i≤⌊n/2⌋</code></li>
<li><code>i</code> 的左孩子 <code>2i</code></li>
<li><code>i</code> 的右孩子 <code>2i+1</code></li>
<li><code>i</code> 的父节点<code>⌊i/2⌋</code></li>
</ul>
</li>
<li>更小的元素“下坠”后，可能导致下一层的子树不符合大根堆的要求，则采用相同的方法继续往下调整 —— <strong>小元素不断“下坠”</strong></li>
</ul>
<p>② <strong>基于大根堆进行排序</strong>：每一趟将堆顶元素加入有序子序列中，堆顶元素与待排序序列中最后一个元素交换后，即最大元素换到末尾，之后该位置就不用改变，即移出完全二叉树(<code>len=len-1</code>)，把剩下的待排序元素序列再调整为大根堆；————<strong>“一趟处理”</strong></p>
<p>③ 剩下最后一个元素则不需要再调整；</p>
<ol>
<li><strong>代码实现</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对初始序列建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)   <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="comment">从最底层的分支结点开始调整*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                      <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">                                      <span class="comment">// i为当前所选根结点的左孩子</span></span><br><span class="line">                                      <span class="comment">//i*=2是为了判断调整后再下一层是否满足大根堆</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])      <span class="comment">//判断：当前所选根结点的左、右结点哪个更大</span></span><br><span class="line">            i++;                      <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) </span><br><span class="line">            <span class="keyword">break</span>;                    <span class="comment">//筛选结束：i指向更大的子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];              <span class="comment">//将A[i]调整至双亲结点上</span></span><br><span class="line">            k=i;                      <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]                       <span class="comment">//被筛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> swap(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于大根堆进行排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);          <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;      <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);          <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);       <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>
<h2 id="8-5-归并排序和基数排序"><a href="#8-5-归并排序和基数排序" class="headerlink" title="8.5 归并排序和基数排序"></a>8.5 归并排序和基数排序</h2><h3 id="8-5-1-归并排序"><a href="#8-5-1-归并排序" class="headerlink" title="8.5.1 归并排序"></a>8.5.1 归并排序</h3><ul>
<li><strong>归并（Merge）</strong>：把两个或多个已经有序的序列合并成一个；</li>
<li><strong>k路归并：\</strong>每选出一个元素，需对比关键字*<em>k-1*</em>次；</li>
<li>外部排序通常采用归并排序，内部排序一般采用2路归并；</li>
<li><strong>代码实现</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建辅助数组B</span></span><br><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low,...,mid],A[mid+1,...,high] 各自有序，将这两个部分归并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low; k&lt;=high; k++)</span><br><span class="line">        B[k] = A[k];           <span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;= high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])          <span class="comment">//为保证稳定性两个元素相等时，优先使用靠前的那个</span></span><br><span class="line">            A[k]=B[i++];        <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//没有归并完的部分复制到尾部，while只会执行一个 </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)  A[k++]=B[i++];     <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];     <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;    <span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A, low, mid);    <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A, mid+<span class="number">1</span>, high); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);     <span class="comment">//归并</span></span><br><span class="line">    &#125;<span class="keyword">if</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>
<ul>
<li>算法效率分析<ul>
<li>归并排序的比较次数与序列的初始状态无关；</li>
<li>2路归并的“归并树”——倒立的二叉树，树高<code>h</code>，归并排序趟数<code>m = h-1</code>，第<code>h</code>层最多<code>2^(h-1)</code>个结点，则满足<code>n ≤ 2^(h-1)</code>，即<code>h-1 = ⌈log₂n⌉</code>; <strong>结论: n个元素进行2路归并排序，归并趟数 m = ⌈log₂n⌉</strong></li>
<li>每趟归并时间复杂度为<code>O(n)</code>, 算法<strong>总时间复杂度</strong>为<code>O(nlog₂n)</code>;</li>
<li><strong>空间复杂度</strong>为<code>O(n)</code>; (归并排序算法可视为本章占用辅助空间最多的排序算法)</li>
<li>稳定性：归并排序是<strong>稳定</strong>的</li>
<li>对于<code>N</code>个元素进行<code>k</code>路归并排序，排序的趟数<code>m</code>满足 <code>k^m = N, m = ⌈logkN⌉</code></li>
</ul>
</li>
</ul>
<h3 id="8-5-2-基数排序"><a href="#8-5-2-基数排序" class="headerlink" title="8.5.2 基数排序"></a>8.5.2 基数排序</h3><ol>
<li><strong>算法效率分析</strong></li>
</ol>
<ul>
<li>空间效率：<code>O(r)</code>, 其中r为基数，需要的辅助空间(队列)为r；</li>
<li>时间效率：一共进行<code>d</code>趟分配收集，一趟分配需要<code>O(n)</code>, 一趟收集需要<code>O(r)</code>, 时间复杂度为 <strong><code>O[d(n+r)]</code></strong>，且<strong>与序列的初始状态无关</strong></li>
<li>稳定性：稳定！</li>
</ul>
<ol>
<li>基数排序擅长解决的问题</li>
</ol>
<p>①数据元素的关键字可以方便地拆分为d组，且d较小；<br>②每组关键字的取值范围不大，即r较小；<br>③数据元素个数n较大；</p>
<h3 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h3><h3 id="1-稳定性"><a href="#1-稳定性" class="headerlink" title="1. 稳定性"></a>1. <strong>稳定性</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>稳定</th>
<th>不稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>简单选择排序</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>希尔排序</td>
</tr>
<tr>
<td>归并排序</td>
<td>快速排序</td>
</tr>
<tr>
<td>基数排序</td>
<td>堆排序</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2. 时间复杂度"></a>2. <strong>时间复杂度</strong></h3><ul>
<li>平均情况下：<strong>快速排序、希尔排序、归并排序、堆排序</strong> 均为 O(nlog2n)； <strong>基数排序</strong>为O(d(n+r))； <strong>其余</strong>全是O(n²);</li>
<li>最坏情况下：<strong>快速排序、希尔排序</strong> 为O(n²)，其余与平均情况一样；</li>
<li>最好情况下：<strong>直接插入排序、冒泡排序、希尔排序</strong> 为 O(n)，其余与平均情况一样；</li>
</ul>
<h3 id="3-空间复杂度"><a href="#3-空间复杂度" class="headerlink" title="3. 空间复杂度"></a>3. <strong>空间复杂度</strong></h3><ul>
<li><strong>快速排序</strong> ：平均 —— O(log2n)；最坏 —— O(n);</li>
<li><strong>2路归并排序</strong>：O(n)；</li>
<li><strong>基数排序</strong>：O®;</li>
<li>其余都是 O(1);</li>
<li>就辅助空间而言：堆排序&lt;快速排序&lt;归并排序</li>
</ul>
<h3 id="4-过程特征"><a href="#4-过程特征" class="headerlink" title="4. 过程特征"></a>4. <strong>过程特征</strong></h3><ul>
<li>经过一趟排序，能够保证一个元素到达最终位置： 交换类——<strong>冒泡、快速</strong>；选择类———<strong>简单选择、堆</strong>；</li>
<li>排序方法的<strong>元素比较次数</strong>与原始序列<strong>无关</strong>：<strong>简单选择、折半插入</strong></li>
<li>排序方法的<strong>排序趟数</strong>与原始序列<strong>有关</strong>：<strong>交换类——冒泡、快速</strong></li>
<li>排序方法中，<strong>元素的移动次数</strong>与原始序列<strong>无关</strong>：<strong>基数排序</strong></li>
<li>初始序列有序时，冒泡排序比较<code>n-1</code>次，不需要移动元素；</li>
<li><strong>希尔排序</strong>和<strong>堆排序</strong>利用顺序存储的随机访问特征，注意链式存储不支持这种性质；</li>
</ul>
<h3 id="5-排序算法的选择"><a href="#5-排序算法的选择" class="headerlink" title="5. 排序算法的选择"></a>5. <strong>排序算法的选择</strong></h3><ul>
<li>若<strong>n较小</strong>，可采用时间复杂度为<strong>O(n²)</strong>的排序方法：<strong>直接插入排序、简单选择排序</strong>，该情况下，若记录本身信息量较大，用简单选择排序；</li>
<li>若<strong>n较大</strong>，应采用时间复杂度为<strong>O(nlog2n)</strong>的排序方法：<strong>快速排序、归并排序、堆排序</strong></li>
<li><strong>快速排序</strong>——目前基于比较的内部排序方法中<strong>最好</strong>的方法，当关键字随机分布时，平均实际最短；</li>
<li>若<strong>n很大</strong>，记录的关键字位数较少且可分解，选择<strong>基数排序</strong></li>
<li>若记录本上信息量较大，可用链表作为存储结构；</li>
<li>若要求排序稳定且时间复杂度为O(nlog2n)，则选择<strong>归并排序</strong>，通常和直接插入排序结合使用：先利用直接插入排序求得较长的有序子文件，再两两归并，仍是稳定；</li>
<li>基数排序不能对<code>float</code>和<code>double</code>类型的实数进行排序；</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
